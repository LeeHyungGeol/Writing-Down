package com.brothergeol;import com.brothergeol.MyAnnotation;import com.brothergeol.MySample;import com.brothergeol.Sample;import org.junit.jupiter.api.DisplayName;import org.junit.jupiter.api.Test;import java.lang.reflect.Modifier;import java.util.Arrays;class ReflectionApiTest {    @Test    @DisplayName("1. Class<T>에_접근하는 3가지 방법")    void approachClass() throws ClassNotFoundException {        //1. 모든 클래스를 로딩하고 나면, Class<T> 의 인스턴스가 생긴다. 타입.class 형태로 접근 가능하다.        Class<Sample> sampleClass1 = Sample.class;        //2. 모든 인스턴스는 getClass() 메소드를 가지고 있다. 인스턴스.getClass() 로 접근할 수 있다.        Sample sample = new Sample();        Class<? extends Sample> sampleClass2 = sample.getClass();        //3. 클래스 full qualified class name 인 문자열로 읽어오는 방법 : Class.forName("Fully Qualified Class Name");        //- 클래스 패스에 해당 클래스가 없다면 ClassNotFoundException 발생한다.        Class<?> sampleClass3 = Class.forName("com.brothergeol.Sample");        System.out.println(sampleClass1);        System.out.println(sampleClass2);        System.out.println(sampleClass3);        //class com.brothergeol.Sample        //class com.brothergeol.Sample        //class com.brothergeol.Sample    }    @DisplayName("2. 필드 목록 가져오기")    @Test    void getFields() {        Class<Sample> sampleClass = Sample.class;        Arrays.stream(sampleClass.getFields()).forEach(System.out::println);   //public 필드만        System.out.println();        Arrays.stream(sampleClass.getDeclaredFields()).forEach(System.out::println);   //모든 필드        System.out.println();    }    @DisplayName("2-1. 필드 값 가져오기")    @Test    void getFieldsValue() {        Class<Sample> sampleClass = Sample.class;        Sample Sample = new Sample();        Arrays.stream(sampleClass.getDeclaredFields()).forEach(f -> {            f.setAccessible(true);            System.out.println(f);            try {                System.out.println(f.get(Sample));  //instance 를 통해서 가져올 수 있다.            } catch (IllegalAccessException e) {                e.printStackTrace();            }        });//        private java.lang.String com.brothergeol.Sample.one//            one//        private static java.lang.String com.brothergeol.Sample.two//            two//        private static final java.lang.String com.brothergeol.Sample.three//            three//        public java.lang.String com.brothergeol.Sample.four//            four//        protected java.lang.String com.brothergeol.Sample.five//            five    }    @DisplayName("2-2. 필드 접근제어자 확인하기")    @Test    void getFieldsModifier() {        Class<Sample> sampleClass = Sample.class;        Sample Sample = new Sample();        Arrays.stream(sampleClass.getDeclaredFields()).forEach(f -> {            int modifiers = f.getModifiers();            System.out.println(f);            System.out.println(Modifier.isPrivate(modifiers));            System.out.println(Modifier.isPublic(modifiers));        });//        private java.lang.String com.brothergeol.Sample.one//        true//        false    }    @DisplayName("3. 메소드 목록 가져오기")    @Test    void getMethods() {        Class<Sample> SampleClass = Sample.class;        Arrays.stream(SampleClass.getMethods()).forEach(System.out::println);        System.out.println();        Arrays.stream(SampleClass.getDeclaredMethods()).forEach(System.out::println);        System.out.println();//        public void com.brothergeol.Sample.eight()//        public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException//        public final void java.lang.Object.wait() throws java.lang.InterruptedException//        public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException//        public boolean java.lang.Object.equals(java.lang.Object)//        public java.lang.String java.lang.Object.toString()//        public native int java.lang.Object.hashCode()//        public final native java.lang.Class java.lang.Object.getClass()//        public final native void java.lang.Object.notify()//        public final native void java.lang.Object.notifyAll()////        private void com.brothergeol.Sample.six()//        protected void com.brothergeol.Sample.seven()//        public void com.brothergeol.Sample.eight()    }    @DisplayName("3-1. 메소드 관련 정보 가져오기")    @Test    void getMethodInfos() {        Class<Sample> SampleClass = Sample.class;        Arrays.stream(SampleClass.getDeclaredMethods()).forEach(f -> {            System.out.println(f);            Arrays.stream(f.getParameterTypes()).forEach(System.out::println);            System.out.println(f.getReturnType());        });//        private void com.brothergeol.Sample.six()//        void//        protected void com.brothergeol.Sample.seven()//        void//        public void com.brothergeol.Sample.eight()//        void    }    @DisplayName("4. 상위 클래스 가져오기")    @Test    void getSuperClass() {        Class<Sample> SampleClass = Sample.class;        System.out.println(SampleClass.getSuperclass());        // class java.lang.Object    }    @DisplayName("5. 인터페이스 목록 가져오기")    @Test    void getInterface() {        Arrays.stream(MySample.class.getInterfaces()).forEach(System.out::println);        //interface com.brothergeol.MyInterface    }    @DisplayName("6. 생성자 가져오기")    @Test    void getConstructor() {        Arrays.stream(Sample.class.getConstructors()).forEach(System.out::println);//        public com.brothergeol.Sample()//        public com.brothergeol.Sample(java.lang.String,java.lang.String,java.lang.String)    }    @DisplayName("7. 어노테이션 가져오기")    @Test    void getAnnotation() {        // Annotation 은 근본적으로 주석 취급을 받기 때문에 이 정보가 클래스 까지는 남는다. 소스에도 남고, 클래스에도 남는다.        // 이 클래스를 바이트코드(.class 파일)로 메모리에 로딩했을 때, 이 정보가 남아있지 않는다.        // 런타임까지도 이 어노테이션을 유지하고 싶다고 하면, RetentionPolicy 를 RUNTIME 으로 설정해야 한다.        // 어노테이션이 상속되게 하고 싶다면, @Inherited 를 붙여주면 된다.        // getDeclaredAnnotations() 는 해당 클래스에 붙어있는 어노테이션만 가져온다.        Arrays.stream(Sample.class.getAnnotations()).forEach(System.out::println);        System.out.println();        Arrays.stream(MySample.class.getAnnotations()).forEach(System.out::println);        System.out.println();        Arrays.stream(MySample.class.getDeclaredAnnotations()).forEach(System.out::println);        System.out.println();        Arrays.stream(Sample.class.getDeclaredFields()).forEach(f -> {            Arrays.stream(f.getAnnotations()).forEach(annotation -> {                if (annotation instanceof MyAnnotation) {                    MyAnnotation myAnnotation = (MyAnnotation) annotation;                    System.out.println(myAnnotation);                }            });        });        // @com.brothergeol.MyAnnotation()        // @com.brothergeol.MyAnnotation()    }    @DisplayName("7-1. 어노테이션 목록 조회하기")    @Test    void getAnnotationList() {        /**         * 커스텀 어노테이션은 java code, java byte code (class file)까지도 남아있지만, runtime 까지 남아있지는 않는다.         * 그래서 getAnnotations() 에서는 사용자 정의 어노테이션은 조회되지 않는다.         * 조회 방법 : @Retention 설정하기         * */        Arrays.stream(Sample.class.getAnnotations()).forEach(System.out::println);//        @com.brothergeol.MyAnnotation()    }    @DisplayName("7-2. @Inherited 상속 클래스에서 상위 클래스 어노테이션 조회")    @Test    void getSuperClassAnnotation() {        Arrays.stream(MySample.class.getAnnotations()).forEach(System.out::println);//        @com.brothergeol.MyAnnotation()    }    @DisplayName("7-3. 상속받은 어노테이션까지 조회하기/하지않기")    @Test    void getAnnotations() {        Arrays.stream(MySample.class.getAnnotations()).forEach(System.out::println);        System.out.println();//        @com.brothergeol.MyAnnotation()//        @com.brothergeol.SecondAnnotation()        Arrays.stream(MySample.class.getDeclaredAnnotations()).forEach(System.out::println);//        @com.brothergeol.SecondAnnotation()    }}