# 3.reflection<br/>## 목차- Spring Dependency Injection 은 어떻게 동작할까?- Reflection API<br/><br/><br/># 💡 Spring Dependency Injection 은 어떻게 동작할까?```java@Repositorypublic class ReflectionRepository {}@Servicepublic class ReflectionService {    @Autowired ReflectionRepository reflectionRepository;}@SpringBootTestpublic class ReflectionServiceTest {    @Autowired    ReflectionService reflectionService;    @Test    void diTest() {        Assertions.assertThat(reflectionService).isNotNull();        Assertions.assertThat(reflectionService.reflectionRepository).isNotNull();    }}```- 위의 테스트가 어떻게 성공할까?   - reflectionRepository 인스턴스는 어떻게 null 이 아닐까?  - Spring 은 어떻게 ReflectionService 인스턴스에 ReflectionRepository 인스턴스를 주입할까? - 비밀은 `Reflection` 에 있다.<br/><br/><br/># 💡 Reflection API## ⚡️ 클래스 정보 조회```javaclass ReflectionApiTest {    @Test    @DisplayName("1. Class<T>에_접근하는 3가지 방법")    void approachClass() throws ClassNotFoundException {        //1. 모든 클래스를 로딩하고 나면, Class<T> 의 인스턴스가 생긴다. 타입.class 형태로 접근 가능하다.        Class<Sample> sampleClass1 = Sample.class;        //2. 모든 인스턴스는 getClass() 메소드를 가지고 있다. 인스턴스.getClass() 로 접근할 수 있다.        Sample sample = new Sample();        Class<? extends Sample> sampleClass2 = sample.getClass();        //3. 클래스 full qualified class name 인 문자열로 읽어오는 방법 : Class.forName("Fully Qualified Class Name");        //- 클래스 패스에 해당 클래스가 없다면 ClassNotFoundException 발생한다.        Class<?> sampleClass3 = Class.forName("com.brothergeol.Sample");        System.out.println(sampleClass1);        System.out.println(sampleClass2);        System.out.println(sampleClass3);        //class com.brothergeol.Sample        //class com.brothergeol.Sample        //class com.brothergeol.Sample    }    @DisplayName("2. 필드 목록 가져오기")    @Test    void getFields() {        Class<Sample> sampleClass = Sample.class;        Arrays.stream(sampleClass.getFields()).forEach(System.out::println);   //public 필드만        System.out.println();        Arrays.stream(sampleClass.getDeclaredFields()).forEach(System.out::println);   //모든 필드        System.out.println();    }    @DisplayName("2-1. 필드 값 가져오기")    @Test    void getFieldsValue() {        Class<Sample> sampleClass = Sample.class;        Sample Sample = new Sample();        Arrays.stream(sampleClass.getDeclaredFields()).forEach(f -> {            f.setAccessible(true);            System.out.println(f);            try {                System.out.println(f.get(Sample));  //instance 를 통해서 가져올 수 있다.            } catch (IllegalAccessException e) {                e.printStackTrace();            }        });//        private java.lang.String com.brothergeol.Sample.one//            one//        private static java.lang.String com.brothergeol.Sample.two//            two//        private static final java.lang.String com.brothergeol.Sample.three//            three//        public java.lang.String com.brothergeol.Sample.four//            four//        protected java.lang.String com.brothergeol.Sample.five//            five    }    @DisplayName("2-2. 필드 접근제어자 확인하기")    @Test    void getFieldsModifier() {        Class<Sample> sampleClass = Sample.class;        Sample Sample = new Sample();        Arrays.stream(sampleClass.getDeclaredFields()).forEach(f -> {            int modifiers = f.getModifiers();            System.out.println(f);            System.out.println(Modifier.isPrivate(modifiers));            System.out.println(Modifier.isPublic(modifiers));        });//        private java.lang.String com.brothergeol.Sample.one//        true//        false    }    @DisplayName("3. 메소드 목록 가져오기")    @Test    void getMethods() {        Class<Sample> SampleClass = Sample.class;        Arrays.stream(SampleClass.getMethods()).forEach(System.out::println);        System.out.println();        Arrays.stream(SampleClass.getDeclaredMethods()).forEach(System.out::println);        System.out.println();//        public void com.brothergeol.Sample.eight()//        public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException//        public final void java.lang.Object.wait() throws java.lang.InterruptedException//        public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException//        public boolean java.lang.Object.equals(java.lang.Object)//        public java.lang.String java.lang.Object.toString()//        public native int java.lang.Object.hashCode()//        public final native java.lang.Class java.lang.Object.getClass()//        public final native void java.lang.Object.notify()//        public final native void java.lang.Object.notifyAll()////        private void com.brothergeol.Sample.six()//        protected void com.brothergeol.Sample.seven()//        public void com.brothergeol.Sample.eight()    }    @DisplayName("3-1. 메소드 관련 정보 가져오기")    @Test    void getMethodInfos() {        Class<Sample> SampleClass = Sample.class;        Arrays.stream(SampleClass.getDeclaredMethods()).forEach(f -> {            System.out.println(f);            Arrays.stream(f.getParameterTypes()).forEach(System.out::println);            System.out.println(f.getReturnType());        });//        private void com.brothergeol.Sample.six()//        void//        protected void com.brothergeol.Sample.seven()//        void//        public void com.brothergeol.Sample.eight()//        void    }    @DisplayName("4. 상위 클래스 가져오기")    @Test    void getSuperClass() {        Class<Sample> SampleClass = Sample.class;        System.out.println(SampleClass.getSuperclass());        // class java.lang.Object    }    @DisplayName("5. 인터페이스 목록 가져오기")    @Test    void getInterface() {        Arrays.stream(MySample.class.getInterfaces()).forEach(System.out::println);        //interface com.brothergeol.MyInterface    }    @DisplayName("6. 생성자 가져오기")    @Test    void getConstructor() {        Arrays.stream(Sample.class.getConstructors()).forEach(System.out::println);//        public com.brothergeol.Sample()//        public com.brothergeol.Sample(java.lang.String,java.lang.String,java.lang.String)    }```- Class API를 사용하여 리플렉션을 사용할 수 있음### 🔋 Reflection을 사용하여 참조할 수 있는 정보- 클래스의 필드- 상위클래스- 인터페이스- 메소드 목록 등 ..### 🔋 Reflection 사용해보기- Reflection 을 사용하기 이전 참조할 클래스를 생성해보자`Book, MySample, MyInterface````java// 기본적으로 annotation 은 주석(comment) 와 같다.@MyAnnotationpublic class Sample {  private String one = "one";  private static String two = "two";  private static final String three = "three";  public String four = "four";  // @MyAnnotation //@Target({ElementType.METHOD, ElementType.CONSTRUCTOR})  protected String five = "five";  public Sample() { }  public Sample(String one, String four, String five) {    this.one = one;    this.four = four;    this.five = five;  }  @MyAnnotation  private void six() {    System.out.println("six");  }  protected void seven() {    System.out.println("seven");  }  public void eight() {    System.out.println("eight");  }}public class MySample extends Sample implements MyInterface {}public interface MyInterface {}````Reflection 사용하기`### 🔋 Class 인스턴스를 참조하는 방법- class 인스턴스를 참조하는 방법은 3가지이다.- 1.Sample.class 와 같이 클래스 로드시 힙에 저장되는 class 인스턴스를 참조하는 방법- 2.특정 인스턴스의 getClass() 메소드로 참조하는 방법- 3.FQCN (Fully Qualified Class Name) 을 이용해 Class.forName() 메소드로 참조하는 방법```java// Class 로딩이 끝나면 class타입의 인스턴스를 만들어 힙에 저장됨Class<Sample> sampleClass = Sample.class;// 특정 인스턴스가 있다면 getClass() 를 사용해 가져올 수 있다.Sample sample = new Sample();Class<? extends Sample> aClass = sample.getClass();// FQCN 으로 접근이 가능함Class<?> aClass1 = Class.forName("com.brothergeol.Sample");```### 🔋 특정 클래스의 필드 참조하기- getFields() 메소드와 getDeclaredFields() 메소드를 통해 클래스의 필드에 접근이 가능하다.- 이때 getFields() 메소드는 public 한 필드에만 접근이 가능하다.```java// 클래스의 필드들에 접근// 이 메소드는 public한 것만 접근이 가능하다Field[] fields = sampleClass.getFields();Arrays.stream(fields).forEach(System.out::println);// 모든 필드에 접근이 가능하다.Field[] declaredFields = sampleClass.getDeclaredFields();Arrays.stream(declaredFields).forEach(System.out::println);```### 🔋 특정 클래스의 필드값 가져오기- 이전과 같은 방법으로 필드의 값을 가져올수 있는데 이때 해당 필드의 접근제어자가 private 이라면 예외가 발생한다.- private한 필드에도 접근이 가능하도록 setAccessible(true); 로 설정을 해주어야 한다.```java// 필드의 값을 가져오기Arrays.stream(declaredFields).forEach(f -> {    try {        // private 한 변수의 값을 가져오기 위한 옵션        f.setAccessible(true);        System.out.printf("%s %s", f, f.get(sample));    } catch (IllegalAccessException e) {        e.printStackTrace();    }});```### 🔋 특정 클래스의 생성자에 접근하는 방법- getDeclaredConstructors() 메소드로 생성자에 접근이 가능하다.```java// 생성자들 접근Arrays.stream(sampleClass.getDeclaredConstructors()).forEach(System.out::println);```### 🔋 특정 클래스의 부모클래스에 접근하는 방법- getSuperclass() 메소드로 부모 클래스에 접근이 가능하다.- 이때 부모클래스는 하나만 존재하기 때문에 Class 타입으로 하나의 인스턴스만 가져올 수 있다.```java// 부모클래스 접근Class<? super MySample> superclass = MySample.class.getSuperclass();System.out.println(superclass);```### 🔋 특정 클래스의 인터페이스에 접근하는 방법- getInterfaces() 메소드로 인터페이스에 접근이 가능하다.```java// 인터페이스 접근Arrays.stream(MySample.class.getInterfaces()).forEach(System.out::println);```## 정리- 앞에서 살펴본것 외에도 다양한 클래스 정보가 참조 가능하다.- https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html<br/><br/><br/>## ⚡️ Annotation Reflection```javapackage com.brothergeol;import com.brothergeol.MyAnnotation;import com.brothergeol.MySample;import com.brothergeol.Sample;import org.junit.jupiter.api.DisplayName;import org.junit.jupiter.api.Test;import java.lang.reflect.Modifier;import java.util.Arrays;class ReflectionApiTest {    @DisplayName("7. 어노테이션 가져오기")    @Test    void getAnnotation() {        // Annotation 은 근본적으로 주석 취급을 받기 때문에 이 정보가 클래스 까지는 남는다. 소스에도 남고, 클래스에도 남는다.        // 이 클래스를 바이트코드(.class 파일)로 메모리에 로딩했을 때, 이 정보가 남아있지 않는다.        // 런타임까지도 이 어노테이션을 유지하고 싶다고 하면, RetentionPolicy 를 RUNTIME 으로 설정해야 한다.        // 어노테이션이 상속되게 하고 싶다면, @Inherited 를 붙여주면 된다.        // getDeclaredAnnotations() 는 해당 클래스에 붙어있는 어노테이션만 가져온다.        Arrays.stream(Sample.class.getAnnotations()).forEach(System.out::println);        System.out.println();        Arrays.stream(MySample.class.getAnnotations()).forEach(System.out::println);        System.out.println();        Arrays.stream(MySample.class.getDeclaredAnnotations()).forEach(System.out::println);        System.out.println();        Arrays.stream(Sample.class.getDeclaredFields()).forEach(f -> {            Arrays.stream(f.getAnnotations()).forEach(annotation -> {                if (annotation instanceof MyAnnotation) {                    MyAnnotation myAnnotation = (MyAnnotation) annotation;                    System.out.println(myAnnotation);                }            });        });        // @com.brothergeol.MyAnnotation()        // @com.brothergeol.MyAnnotation()    }    @DisplayName("7-1. 어노테이션 목록 조회하기")    @Test    void getAnnotationList() {        /**         * 커스텀 어노테이션은 java code, java byte code (class file)까지도 남아있지만, runtime 까지 남아있지는 않는다.         * 그래서 getAnnotations() 에서는 사용자 정의 어노테이션은 조회되지 않는다.         * 조회 방법 : @Retention 설정하기         * */        Arrays.stream(Sample.class.getAnnotations()).forEach(System.out::println);//        @com.brothergeol.MyAnnotation()    }    @DisplayName("7-2. @Inherited 상속 클래스에서 상위 클래스 어노테이션 조회")    @Test    void getSuperClassAnnotation() {        Arrays.stream(MySample.class.getAnnotations()).forEach(System.out::println);//        @com.brothergeol.MyAnnotation()    }    @DisplayName("7-3. 상속받은 어노테이션까지 조회하기/하지않기")    @Test    void getAnnotations() {        Arrays.stream(MySample.class.getAnnotations()).forEach(System.out::println);        System.out.println();//        @com.brothergeol.MyAnnotation()//        @com.brothergeol.SecondAnnotation()        Arrays.stream(MySample.class.getDeclaredAnnotations()).forEach(System.out::println);//        @com.brothergeol.SecondAnnotation()    }}```### 🔋 Annotation애노테이션은 다양한 목적으로 사용되지면 주로 **메타 데이터**의 비중이 가장 크다.>메타 데이터(Meta-Data): 데이터를 위한 데이터, 한 데이터에 대한 설명을 의미한다`MyAnnotation````java@Retention(RetentionPolicy.RUNTIME)@Target({ElementType.TYPE, ElementType.FIELD})@Inheritedpublic @interface MyAnnotation {    String name() default "brothergeol";    int number() default 100;    String value() default "default value";}````@Retention`- 컴파일러가 애노테이션을 다루는 방법을 기술하며, 어느 시점까지 정보를 유지할것인지 결정한다.- RetentionPolicy.SOURCE : 컴파일 전까지만 유효. (컴파일 이후에는 사라짐)- RetentionPolicy.CLASS : 컴파일러가 클래스를 참조할 때까지 유효.- RetentionPolicy.RUNTIME : 컴파일 이후에도 JVM에 의해 계속 참조가 가능. (리플렉션 사용)- 기본값은 CLASS`@Target`- 애노테이션을 적용할 위치를 결정한다.- ElementType.PACKAGE : 패키지 선언- ElementType.TYPE : 타입 선언- ElementType.ANNOTATION_TYPE : 어노테이션 타입 선언- ElementType.CONSTRUCTOR : 생성자 선언- ElementType.FIELD : 멤버 변수 선언- ElementType.LOCAL_VARIABLE : 지역 변수 선언- ElementType.METHOD : 메서드 선언- ElementType.PARAMETER : 전달인자 선언- ElementType.TYPE_PARAMETER : 전달인자 타입 선언- ElementType.TYPE_USE : 타입 선언`@Inherited`- 애노테이션을 상속이 가능하게 한다.- 애노테이션은 값들을 가질수 있는데 가질수 있는 데이터의 타입은 제한되어있다.- 기본형 타입과, enum,  Wrapper 타입들만 속성으로 가질수 있다.- 해당 속성의 기본값도 지정이 가능하다.```javaString name() default "brothergeol";```속성을 지정하면 애노테이션을 사용할때 다음과 같이 속성에 값을 지정할수 있다.```java@MyAnnotation(name = "default value")```만약 **값을 받을 속성의 이름을 value 로 지정하면 속성명을 생략**할 수 있다.```java@MyAnnotation("default value")```### 🔋 Reflection으로 Annotation 정보 참조하기애노테이션은 기본적으로 주석과 동일한 취급을하기 때문에 바이트코드 로드시 해당 애노테이션의 정보는 제외하고 로드된다.- Reflection으로 해당 정보를 참조 할 수 없다.Reflection으로 해당 정보를 참조하고 싶다면 (애노테이션의 정보를 RUNTIME시 까지 유지) @Retention을 사용하여 해당 애노테이션 정보를 언제까지 유지할것인지 지정해 주어야한다.getAnnoitations()- 상위 클래스의 상속가능한 애노테이션 정보 까지 참조한다.getDeclaredAnnotations()- 타겟 클래스의 애노테이션 정보만 참조한다.```java// getAnnotations() : 상위 클래스의 상속가능한 애노테이션정보까지 가져온다.// getDeclaredAnnotations() : 현재 클래스의 애노테이션 정보만 가져온다.Arrays.stream(MySample.class.getAnnotations()).forEach(System.out::println);Arrays.stream(MySample.class.getDeclaredAnnotations()).forEach(System.out::println);```<br/><br/><br/>## ⚡️ 클래스 정보 수정, 조회```javaclass ClassModificationSampleTest {    @DisplayName("class instance 만들기")    @Test    void createInstance() throws InstantiationException, IllegalAccessException {        /**         * 주의 : ClassModification.class.newInstance(); 는 Deprecated 되었으므로 사용하지 않도록 한다.         * */        ClassModificationSample classModification = ClassModificationSample.class.newInstance();        System.out.println(classModification);      //com.brothergeol.ClassModificationSample@3e27ba32    }    @DisplayName("생성자로 인스턴스 만들기")    @Test    void constructorInstance() throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {        Class<?> clazz = Class.forName("com.brothergeol.ClassModificationSample");        Constructor<?> constructor = clazz.getConstructor(null);        ClassModificationSample classModification = (ClassModificationSample) constructor.newInstance();        System.out.println(classModification);      //com.brothergeol.ClassModificationSample@3e27ba32    }    @DisplayName("static 필드 접근하기, 수정하기")    @Test    void editStaticFields() throws NoSuchFieldException, IllegalAccessException {        Field a = ClassModificationSample.class.getDeclaredField("A");        System.out.println(a.get(null));        //Static 필드를 가져올 때는 object가 없어도 되니까 null        a.set("A", "hey");        System.out.println(a.get(null));    }    @DisplayName("instance 필드 접근하기, 수정하기")    @Test    void editInstanceFields() throws ClassNotFoundException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchMethodException, NoSuchFieldException {        Class<?> aClass = Class.forName("com.brothergeol.ClassModificationSample");        Constructor<?> constructor = aClass.getConstructor(String.class);        ClassModificationSample instance = (ClassModificationSample) constructor.newInstance("input");        Field b = ClassModificationSample.class.getDeclaredField("b");        b.setAccessible(true);        System.out.println(b.get(instance));        b.set(instance, "output");     //set(instance, value);        System.out.println(b.get(instance));    }    @DisplayName("메소드 실행하기 : Object Method.invoke(object, params)")    @Test    void methodExecution() throws NoSuchMethodException, ClassNotFoundException, InvocationTargetException, InstantiationException, IllegalAccessException {        Class<?> aClass = Class.forName("com.brothergeol.ClassModificationSample");        Constructor<?> constructor = aClass.getConstructor(String.class);        ClassModificationSample instance = (ClassModificationSample) constructor.newInstance("input");        Method c = ClassModificationSample.class.getDeclaredMethod("c");        c.setAccessible(true);        c.invoke(instance);        Method d = ClassModificationSample.class.getDeclaredMethod("sum", int.class, Integer.class);        System.out.println(d.invoke(instance, 1, 2));    }}```### 🔋 Reflection API 를 활용해 인스턴스 생성하기`기본생성자를 가져와 인스턴스 생성`- 기본생성자로 인스턴스를 생성하는 방법은 getConstructor 메소드에서 인자를 null로 지정해주어 생성자를 가져온다.- 가져온 생성자의 newInstance 메소드를 통해 인스턴스를 생성해준다.```java// 기본생성자를 가져와 인스턴스 생성Constructor<Sample> constructor = sampleClass.getConstructor(null);Sample sample = constructor.newInstance();````파라메터가 존재하는 생성자를 가져와 인스턴스 생성`- 파라메터가 존재하는 생성자로 인스턴스를 생성하는 방법은 getConstructor 메소드에서 인자를 Class type 인스턴스를 지정해주어 생성자를 가져온다.- 기본 생성자와 마찬가지로 newInstance 메소드를 통해 인스턴스르 생성해준다.```java// 파라메터가 존재하는 생성자를 가져와 인스턴스를 생성Constructor<Sample> constructor1 = sampleClass.getConstructor(String.class);Sample hello = constructor1.newInstance("Hello");```### 🔋 Reflection API 를 활용해 필드 정보 참조하기`static 필드 정보 참조하기`- getDeclaredField메소드를 사용해 필드 메타정보를 가져온다.- 가져온 field의 get, set 메소드를 활용해 필드의 값을 가져오거나, 수정할 수 있다.- 이때 해당 필드가 static 필드가 아니라면, 첫번째 인자로 특정 인스턴스를 넘겨주어야한다.```javaField a = Sample.class.getDeclaredField("A");// 값을 가져올때 해당 필드가 특정한 인스턴스에 해당하는 필드라면, 인스턴스를 넘겨줄 수 있다.// 하지만 지금은 static한 필드이기 때문에 null을 넘겨주면 가져올 수 있다.a.get(null);// 마찬가지로 첫번째인자는 특정 인스턴스, 두번째는 값을 지정해 변경할 수 있다.a.set(null, "BBBBB");````instance 필드 정보 참조하기`- static 필드와 마찬가지로 getDeclaredField메소드를 사용해 필드 메타정보를 가져온다.- 가져온 field의 get, set 메소드를 활용해 필드의 값을 가져오거나, 수정할수 있으며 첫번째 인자로 인스턴스를 넘겨주어야 한다.```javaField b = Sample.class.getDeclaredField("B");// B는 특정 인스턴스에 해당하는 필드이기 때문에 book 인스턴스를 넘겨주어야 한다.// private 변수이기 때문에 접근지시자를 무시하고 가져오도록 한다.b.setAccessible(true);b.get(book1);b.set(book1, "CXCCCCCC");```### 🔋 Reflection API 를 활용해 메소드 정보 참조하기`매개변수가 없는 메소드 정보 참조하기`- getDeclaredMethod 메소드를 활용해 메소드 정보를 참조할 수 있다.- invoke 메소드를 사용해여 메소드를 실행할 수 있다.- 특정 인스턴스에 해당하는 메소드라면 해당 인스턴스를 넘겨 주어야 한다.```javaMethod c = Sample.class.getDeclaredMethod("c");// 특정 인스턴스에 해당하는 메소드라면 인스턴스를 넘겨주어야한다.// private 메소드이기 떄문에 접근지시자를 무시하고 실행하도록 한다.c.setAccessible(true);c.invoke(book1);````매개변수가 있는 메소드 정보 참조하기`- 이전과 마찬가지로 getDeclaredMethod 메소드를 활용해 메소드 정보를 참조할 수 있다.  - 메소드 정보를 참조할때 해당 메소드의 파라미터의 type은 기본형 타입과 Wrapper 타입을 구분하기 떄문에 주의해야한다.- invoke 메소드를 사용하여 메소드를 실행할 수 있다```java// 메소드를 가져올때 Primitive type, Wrapper type을 구분하므로 주의할것Method d = Sample.class.getDeclaredMethod("sum", int.class, Integer.class);int invoke = (int) d.invoke(book1, 1, 2);```<br/><br/><br/>