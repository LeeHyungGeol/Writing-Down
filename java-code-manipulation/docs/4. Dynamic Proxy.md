# 4. Dynamic Proxy<br/>## 목차- Spring Data JPA 는 어떻게 동작할까?- 프록시 패턴(Proxy Pattern)- Java 에서 제공하는 Dynamic Proxy- 클래스의 Proxy- <br/><br/><br/># 💡 Spring Data JPA 는 어떻게 동작할까?## ⚡️ 스프링 데이터 JPA 에서 인터페이스 타입의 인스턴스는 누가 어떻게 만들어주는 것일까?```javaimport org.springframework.data.jpa.repository.JpaRepository;public interface SampleRepository extends JpaRepository<Sample, Long> {}``````java@SpringBootTestclass SampleServiceTest {    @Autowired SampleRepository sampleRepository;    @Test    public void di_test() {        Assertions.assertNotNull(sampleRepository);    }}```- 우리는 @Repository annotation 이나 기타 다른 어노테이션이 없는 JPARepository 를 extend 하여 인터페이스 내부의 함수들을 유용하게 사용하고 있다.- interface 인데 이게 어떻게 instance 가 만들어졌을까?- 테스트를 해보면 실제로 query 가 날라가는 것을 볼 수가 있다. 구현체가 만들어진 것이다.## ⚡️ 정답은 Proxy```javapackage org.springframework.aop.framework;import org.aopalliance.intercept.Interceptor;import org.springframework.aop.TargetSource;import org.springframework.lang.Nullable;import org.springframework.util.ClassUtils;/** * Factory for AOP proxies for programmatic use, rather than via declarative * setup in a bean factory. This class provides a simple way of obtaining * and configuring AOP proxy instances in custom user code. */@SuppressWarnings("serial")public class ProxyFactory extends ProxyCreatorSupport {}``````javapublic abstract class RepositoryFactorySupport implements BeanClassLoaderAware, BeanFactoryAware {    public <T> T getRepository(Class<T> repositoryInterface, RepositoryFragments fragments) {        ...        // Create proxy        StartupStep repositoryProxyStep = onEvent(applicationStartup,            "spring.data.repository.proxy", repositoryInterface);        ProxyFactory result = new ProxyFactory();        result.setTarget(target);        result.setInterfaces(repositoryInterface, Repository.class, TransactionalProxy.class);        ...        return repository;    }}```- Spring Data JPA 에서는 Spring AOP 를 사용하고, `Spring AOP` 는 `RepositoryFactorySupport` 를 사용한다.- 이것이 Java 에서 추상화해놓은 Spring AOP 핵심 클래스이고, Spring Data JPA 에서는 이것을 사용한다.- `Spring AOP` 를 기반으로 동작하며 `RepositoryFactorySupport` 에서 `ProxyFactory` 클래스를 통해 Proxy 객체를 만든다.- 여기서 만들어주는 프록시 객체가 bean 으로 등록이 되어서 우리가 만든 application 에 `@Autowired` 된 Repository 들에게 주입된다.<br/><br/><br/># 💡 프록시 패턴(Proxy Pattern)<img width="769" alt="스크린샷 2024-07-16 오후 5 00 28" src="https://github.com/user-attachments/assets/4fd26a4b-734b-4061-b0f5-086a5e8a2218"><img width="352" alt="스크린샷 2024-07-16 오후 5 10 09" src="https://github.com/user-attachments/assets/2b033508-595a-42a5-9ebd-2ac73492b64e">**프록시 패턴은 위와 같이 구성된다.**- Proxy 클래스와 RealSubject 클래스가 공통의 부모로 인터페이스를 가지고 있다. - 클라이언트는 인터페이스 타입, Proxy 를 거쳐 RealSubject 에 접근한다. - 즉, Client -> Interface -> Proxy -> RealSubject 순서로 접근한다.RealSubject 에 접근할 필요가 없을 때에는 Proxy 에서 바로 리턴하기도 한다.## ⚡️ 장점- RealSubject 에서는 그가 맡은 단일 책임에만 집중하면 된다. (SRP)  - 본인이 가진 역할 이외에는 추가가 되면 안된다.   - 하나의 클래스는 하나의 역할만 해야한다. 다른 역할을 하는것을 추가할땐 해당 클래스가 수정이 되어선 안된다.   - 로깅 기능을 추가한다던가, 권한 체크 기능을 추가하는 등 의 경우에 리얼 서브젝트를 직접 수정해서 안된다.Proxy 에서는 RealSubject 에 필요한 접근제한, 로깅, 트랜잭션 등 부가적인 기능을 제공한다. ## ⚡️ 프록시 패턴 구현 예시```javapublic interface SampleService {    void test(Sample sample);}public class DefaultSampleService implements SampleService {    public void test(Sample sample) {        System.out.println("SampleService.test(): " + sample.getName());    }}public class SampleServiceProxy implements SampleService {    SampleService sampleService;    public SampleServiceProxy(SampleService sampleService) {        this.sampleService = sampleService;    }    @Override    public void test(Sample sample) {        System.out.println("proxy 객체에서 변경하고 싶은 사항들을 여기서 처리할 수 있습니다.");        sampleService.test(sample);    }}``````javaclass SampleServiceTest {    SampleService sampleService = new SampleServiceProxy(new DefaultSampleService());    @Test    public void di_test() {        Sample sample = new Sample();        sample.setName("spring");        sampleService.test(sample);    }}```## ⚡️ 직접 구현의 문제점- 일반적인 프록시 패턴을 이용하게 되면, 각 서비스마다 그에 해당하는 프록시가 하나씩 생성되어, 너무 많은 클래스가 생성되고, 그 내부의 코드도 중복된다는 문제점이 발생하게 된다.- 이를 효과적으로 해결하기 위해 `Reflection API` 에서는 `Dynamic Proxy` 라는 개념을 지원한다.- `Dynamic Proxy` 를 이용해서 컴파일 타임에 미리 만들어진 클래스가 아니라, **`Runtime` 에 유동적으로 클래스 타입에 맞는 프록시 객체를 만들수 있다.**## 참고- https://www.oodesign.com/proxy-pattern.html- https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9D%EC%8B%9C_%ED%8C%A8%ED%84%B4- https://en.wikipedia.org/wiki/Proxy_pattern- https://en.wikipedia.org/wiki/Single_responsibility_principle- https://wiki.mhson.world/java-spring/java/undefined-4<br/><br/><br/># Java 에서 제공하는 Dynamic Proxy> **Java 에서는** > > 매번 프록시 디자인 패턴을 구현하여, 타입에 맞는 프록시 클래스를 생성하는 방식이 아니라, 런타임에 동적으로 클래스 타입에 맞는 프록시 객체를 생성한다.## ⚡️ 구현```javapublic class ProxyServiceTest {    SampleService bookService = (SampleService) Proxy.newProxyInstance(SampleService.class.getClassLoader(), new Class[]{SampleService.class},        new InvocationHandler() {            SampleService bookService = new DefaultSampleService();            @Override            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {                if (method.getName().equals("test")) {                    System.out.println("aaaa");                    Object invoke = method.invoke(bookService, args);                    System.out.println("bbbb");                    return invoke;                }                return method.invoke(bookService, args); }        });    @Test    void proxy_test() {        Sample sample = new Sample();        sample.setName("spring");        bookService.test(sample);    }}```## Java 에서 제공하는 Dynamic Proxy 의 문제점1. Java 에서 제공해주는 dynamic proxy 는 모든 매소드에 일괄적으로 적용되며 일부 매소드에만 적용하고 싶을 때에는 위의 코드처럼 if 분기를 해주어 수동적으로 설정해야한다. 확장성이 매우 안좋고 유연하지 못한 구조라고 할 수 있다.   - 그래서 스프링 AOP 가 등장하게 되었다.2. 인터페이스 타입의 프록시만 제공하지, 클래스 타입의 프록시는 제공하지 않는다는 점이다.  - 클래스의 경우에는 Java 에서 제공하는 Dynamic Proxy 는 사용하지 못한다.  - 클래스의 경우에는 CGLIB 라는 라이브러리를 사용하여 프록시를 생성한다.## 참고- https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html- https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Proxy.html#newProxyInstance-java.lang.ClassLoader-java.lang.Class:A-java.lang.reflect.InvocationHandler-<br/><br/><br/># 💡 클래스의 Proxy