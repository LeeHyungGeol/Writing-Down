# 2. 바이트 코드 조작<br/>## 목차- JAVA 바이트 코드 조작의 여러가지 쓰임새- JAVA bytecode(.class 파일)을 조작하여 테스트 커버리지 측정하기- 바이트 코드 조작하는 방법(bytebuddy, javaagent)- Spring 은 asm 을 이용하여 컴포넌트 스캔을 한다<br/><br/><br/># 💡 JAVA 바이트 코드 조작의 여러가지 쓰임새## ⚡️ 프로그램 분석- 코드에서 버그를 찾는 툴- 코드 복잡도 계산 툴## ⚡️ 클래스파일 생성- 프록시    - Spring AOP, Hibernate Lazy Loading, Mock- 특정 API 호출 접근 제한- 스칼라와 같은 언어의 컴파일러## ⚡️ 자바 소스코드를 건드리지 않고 할 수 있는 이것 저것들 (transparent 하게 무엇인가를 할 수 있는 곳)- 프로파일러 (spring 에서 나온 newrelic)- 최적화 - 로깅 등## ⚡️ 스프링의 컴포넌트 스캔- ASM을 사용한다.- 컴포넌트 스캔으로 빈으로 등록할 대상 클래스를 찾는데 상요함- ClassPathScanningCandidateComponentProvider  -> SimpleMetadataReader 를 사용해서 메타데이터를 읽어온다.- 스프링에서 버전문제 때문에 패키징을 했을뿐 ASM을 사용한다.<br/><br/><br/># 💡JAVA bytecode(.class 파일)을 조작하여 테스트 커버리지 측정하기> 바이트 코드를 조작하는 대표적인 예시인 코드 커버리지 툴을 살펴보자.## ⚡️ 코드 커버리지란 ?- 코드 커버리지는 테스트코드가 내 소스코드의 어느정도를 테스트하는지 확인하는 툴이다.- 최근에 가장 많이 사용하는 `JaCoCo` 라는 툴을 사용해보자.## ⚡️ JaCoCo 플러그인 추가하기 (using gradle)- [jacoco 플러그인 추가하기](https://docs.gradle.org/current/userguide/jacoco_plugin.html)위의 링크에 참고된 문서에 따라 차례대로 JaCoCo 플러그인을 설치한 뒤,   gradle java project 에서 테스트 코드를 실행하면,  `build/customJacocoReportDir/test/html/default/index.html` 에 테스트 결과 리포트가 생성된다.```groovyplugins {    id 'jacoco'}test {    finalizedBy jacocoTestReport // report is always generated after tests run}jacocoTestReport {    dependsOn test // tests are required to run before generating the report}jacoco {    toolVersion = "0.8.8"    reportsDirectory = layout.buildDirectory.dir('customJacocoReportDir')}```<br/><br/>## ⚡️ 테스트 코드 작성하기- 그룹에는 최대 참가자와 현재 신청자 정보를 가지고 있으며, isFull() 메소드를 통해 참가신청이 완료되었는지 확인할 수 있다.```javapublic class Group {    /* 최대 참가자 */    int maxNumberOfAttendees;    /* 현재 신청자 */    int numberOfEnrollment;    public boolean isFull () {        if (maxNumberOfAttendees == 0) {            return false;        }        if (numberOfEnrollment < maxNumberOfAttendees) {            return false;        }        return true;    }}````GroupTest`- group을 생성하고, 최대 참가자를 100명으로 설정한다.- 현재 참가자수를 100명으로 지정한뒤, isFull() 메소드를 통해 현재 참가신청이 완료되었는지 확인해본다.- 기대값은 True 이다.```javapublic class GroupTest {    @Test    public void isFull () {        Group group = new Group();        group.maxNumberOfAttendees = 100;        group.numberOfEnrollment = 100;        assertTrue(group.isFull());    }}```<br/><br/>## ⚡️ JaCoCo 실행테스트 코드를 실행하면, JaCoCo 플러그인도 함께 실행된다.`build/customJaCoCoReportDir/test/html/default/index.html`  (build.gradle 에 지정한 directory) 에 테스트 결과 리포트가 생성된다.## ⚡️ 실행 결과<img width="554" alt="스크린샷 2024-07-09 오후 2 42 06" src="https://github.com/LeeHyungGeol/Algorithm_BaekJoon/assets/56071088/49a930b3-f316-45c0-82b3-e9b0090d09db"><img width="831" alt="스크린샷 2024-07-09 오후 3 05 37" src="https://github.com/LeeHyungGeol/Algorithm_BaekJoon/assets/56071088/db9d59c1-2722-4a47-93c1-db149a2da77c">실행 결과를 보면 소스 코드레벨에서 노란색, 붉은색, 초록색 라인이 존재한다.- 노란색 라인은 해당 조건식의 한가지 경우만 테스트했다는 것을 의미한다.    - 즉 true, false중 하나의 케이스만 테스트된것- 붉은색 라인은 해당 라인이 실행되는 테스트가 존재하지 않는다는 의미이다.- 초록색 라인은 해당 라인이 통과되었다는 의미이다.## ⚡️ 작동원리- 바이트 코드를 읽어서 바이트 코드에서 코드 커버리지를 챙겨야 되는 부분의 개수를 미리 다 세어놓는다.   - 그리고 코드를 돌리면서 그 중에 몇개를 지나갔는지를 세어서 코드 커버리지를 측정한다.<br/><br/><br/># 💡 바이트 코드 조작하는 방법(bytebuddy, javaagent)## ⚡️ 바이트 코드 조작 라이브러리 비교`ASM`: https://asm.ow2.io/- 매우 어렵다고 한다. 러닝 커브가 높고, 자바의 바이트코드 구조를 어느정도 알고 있고 디자인 패턴에 익숙해도 이해하고 사용하기거 어렵다고 한다.- 스프링 프레임워크를 포함하여 많은 곳에서 쓰이고 있음`Javassist`: https://www.javassist.org/- ASM 보다는 아니지면 여전히 사용하기가 어렵다고 한다.`ByteBuddy`: https://bytebuddy.net/#/- 비교적 가장 최근에 나온 라이브러리이다.- 자바 바이트 코드에 대해서 깊게 몰라도 충분히 사용 가능하며, 러닝커브가 낮다.- ByteBuddy는 쉽게 사용 하는것을 목적으로 만들어진 라이브러리 이다.- ByteBuddy는 ByteBuddy API만 사용할줄 안다면 쉽게 바이트코드 조작이 가능하다.- 코드를 작성하기는 편하지만, 체이닝이 심해서 가독성은 좀 떨어지는 편 <br/><br/>## ⚡️ ByteBuddy 사용하기### 🔋 ByteBuddy gradle 의존성 추가```groovydependencies {    //ByteBuddy - for bytecode manipulation    implementation 'net.bytebuddy:byte-buddy:1.14.0'}```### 🔋 파일 내부에서 호출 전에 변경하기- ByteBuddy 라이브러리를 통해 특정 클래스에 대해 새롭게 정의된 클래스 파일을 덮어씌우면, - 이후 코드에서 객체를 생성하고 매소드를 호출할 때, 원래 코드와는 전혀 다른 값이 반환될 수 있다. ```javapublic class Magician {    public static void main(String[] args) {        //1. Hat.class 내의 pullOut 매소드가 고정값인 Rabbit!!! 을 반환하도록 조작한 새로운 .class 파일로 덮어 씌우기        try {            new ByteBuddy()                .redefine(Hat.class)                .method(named("pullOut"))                .intercept(FixedValue.value("Rabbit!!!"))                .make()                .saveIn(new File("/Users/ihyeong-geol/Desktop/workspace/Writing-Down/java-code-manipulation/jacoco/build/classes/java/main/"));        } catch (IOException e) {            e.printStackTrace();        }        //2. 위의 코드 실행 후 주석처리. 아래 코드 실행 -> Rabbit!!! 이 반환된다.        System.out.println(new Hat().pullOut());       //return Rabbit!!!    }}```> ### **두 코드를 동시에 실행할 수 없는 이유는?**> - 1번 구간의 코드를 실행할 때, Hat.class 를 한번 읽어들인다. `읽는 시점`에는 해당 클래스의 pullOut() 매소드는 바뀌기 전 값인 "nothing" 값을 가지고 있다. > - 이미 클래스 로더에서 Hat 클래스를 읽어들였기 때문에, 1번 구간 수행 후, Hat 의 클래스 파일이 변경되었다고 하더라도 2번 구간을 수행할 때, **다시 새롭게 클래스 파일을 읽어들이지 않는다.** > - 결과적으로 1번 구간에서 최초 로드 후 클래스 파일은 변경되었지만 (Rabbit 반환코드) 2번 구간에서는 **이미 로딩된 클래스 정보 (메소드 영역에 있는)** 를 보고 있기 때문에 이전에 읽어들인 Hat 클래스 파일 (nothing 반환코드) 을 실행하게 되는 것이다. <br/>### 🔋 클래스 파일을 로드하지 않고 클래스 파일을 변경하기```javapublic class Magician2 {    public static void main(String[] args) {        //1. 클래스 파일을 로드하지 않고 클래스 파일을 변경        ClassLoader classLoader = Magician2.class.getClassLoader();        TypePool typePool = TypePool.Default.of(classLoader);        try {            new ByteBuddy()                .redefine(typePool.describe("Hat").resolve(),                    ClassFileLocator.ForClassLoader.of(classLoader))                .method(named("pullOut"))                .intercept(FixedValue.value("Rabbit!!!"))                .make()                .saveIn(new File(                    "/Users/ihyeong-geol/Desktop/workspace/Writing-Down/java-code-manipulation/jacoco/build/classes/java/main/"));        } catch (IOException e) {            e.printStackTrace();        }        //2. 변경된 클래스 파일을 로드 후 실행, Rabbit!!! 반환        System.out.println(new Hat().pullOut());       //Rabbit!!!    }}```- 풀패키지 경로로 재정의할 Hat.class, classLoader 를 주면, - 2번의 코드를 실행하기 전 까지는 Hat 클래스를 읽지 않아도 되기 때문에, 클래스 파일이 변경된다.하지만, 위의 코드는 결국 실행 순서에 따라 결과가 달라지므로, 아직 한계점이 있다. 다른 곳에서 Moja 클래스를 먼저 로드해서 읽어버리는 경우에는 먹히지 않는 방법이다.완벽하게 바이트 코드를 조작하려면, 결국 다른 곳에서 먼저 위의 조치를 취해주어야 한다. ## ⚡️javaagent 사용하기> javaagent 사용하여 어플리케이션 실행시에 바이트 코드 조작하기### 🔋 build.gradle```groovyjar {    manifest.attributes(            'Premain-Class' : 'MagicianAgent',            'Can-Redefine-Classes' : true,            'Can-Retransform-Classes' : true    )}dependencies {    //ByteBuddy - for bytecode manipulation    implementation 'net.bytebuddy:byte-buddy:1.14.0';    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.8.1'    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.8.1'}```### 🔋 premain 함수 작성```javapublic class MagicianAgent {    public static void premain(String arguments, Instrumentation instrumentation) {        new AgentBuilder.Default()            .type(ElementMatchers.any())            .transform(                (builder, typeDescription, classLoader, module, protectionDomain)                    -> builder.method(named("pullOut")).intercept(FixedValue.value("Rabbit!"))            ).installOn(instrumentation);    }}```### 🔋 gradle 로 jar 파일 생성<img width="437" alt="스크린샷 2024-07-09 오후 4 59 49" src="https://github.com/LeeHyungGeol/Algorithm_BaekJoon/assets/56071088/b812fede-5a7b-4508-a739-585a82626d3c"><img width="367" alt="스크린샷 2024-07-09 오후 5 00 37" src="https://github.com/LeeHyungGeol/Algorithm_BaekJoon/assets/56071088/b6e4ec50-f770-4531-bdb9-6c5e7fa1d5f5">### 🔋 bytebuddy 코드를 제거한 아무것도 없는 코드 생성```javapackage agent;public class Magician3 {    public static void main(String[] args) {        System.out.println(new Hat3().pullOut());       //Rabbit!!!    }}package agent;public class Hat3 {  public String pullOut() {    return "nothing";  }}```### 🔋 VM Options 추가<img width="800" alt="스크린샷 2024-07-09 오후 4 57 14" src="https://github.com/LeeHyungGeol/Algorithm_BaekJoon/assets/56071088/1c0ce2cc-8428-4e65-99bd-2333e24bfde9">`-javaagent:/Users/.../masulsa-agent/build/libs/masulsa-agent-1.0-SNAPSHOT.jar`### 🔋 실행 결과<img width="364" alt="스크린샷 2024-07-09 오후 5 06 13" src="https://github.com/LeeHyungGeol/Algorithm_BaekJoon/assets/56071088/b29bf0b5-bcfd-480f-93e0-8ba435e7d2a5"><img width="469" alt="스크린샷 2024-07-09 오후 5 07 04" src="https://github.com/LeeHyungGeol/Algorithm_BaekJoon/assets/56071088/702e1e29-b613-49e2-8cfd-2594db502be7">- **원래 코드의 바이트 코드는 전혀 바꾸지 않고도, `javaagent` 에 의해서 Rabbit 으로 바뀐 코드가 출력된다.**<br/><br/>## ⚡️ 정리총 3가지 방법을 통해서 java class 파일을 조작해보았다.1. 클래스 파일을 읽고 변경한 뒤, 재호출시에는 다시 클래스파일을 로드하지 않고, 변경된 클래스 파일을 사용하도록 하는 방식  -> 변경된 클래스 파일을 사용한다.2. 클래스 로드 전, 메모리에 있는 바이트 코드 파일을 직접 건드려 클래스 로드 시에는 처음부터 바뀐 파일이 읽히도록 하는 방식  -> 클래스 파일이 변경된다.3. 외부에서 javaagent jar 파일 내 premain() 매소드를 통해서 클래스 로드 시에 바이트 코드 파일 (클래스파일)을 변경하는 방법 -> 클래스 파일이 변경되지 않고 바꿔치기한 파일이 사용된다.   - 클래스 로더가 클래스를 읽어올 때, javaagent 를 거쳐서 변경된 바이트코드를 읽어들여 사용한다. 따라서 실제 바이트 코드는 변경이 없다.**처음 두 방법은 코드의 실행 순서에 따라서 결과가 달라지므로, 3번 방법이 가장 정확하고 transparent(기존 코드를 변경하지 않는 깨끗한) 한 방법이라고 할 수 있겠다.****시중에 바이트 코드를 조작하여 만든 툴들은 결국 이처럼 기존 소스코드를 건드리지 않는 방법을 사용하여 구현된 형태일 것이다.** <br/><br/><br/># 💡 Spring 은 asm 을 이용하여 컴포넌트 스캔을 한다SpringApplication 의 시작점에 붙은 @SpringBootApplication 내부를 살펴보면, @ComponantScan 이라고 하는 어노테이션이 있다.해당 어노테이션은 해당 위치부터 모든 하위 디렉토리를 돌면서 `@Component`, `@Bean` 어노테이션이 붙은 모든 클래스들을 스캔하여 빈으로 등록해준다.```java@SpringBootApplicationpublic class ExampleApplication {    public static void main(String[] args) {        SpringApplication.run(ExampleApplication.class, args);    }}@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })public @interface SpringBootApplication {...}```이처럼 컴포넌트를 스캔하는 과정에서 사용되는 것이 바로 `ClassPathScanningCandidateComponentProvider`, `SimpleMetadataReader` 이다.<br/>### 🔋 ClassPathScanningCandidateComponentProvider실제로 코드의 docs 를 보면,  ASM ClassReader 를 이용하고 있다는 것을 알 수 있다.<img width="879" alt="스크린샷 2024-07-09 오후 5 26 32" src="https://github.com/LeeHyungGeol/Algorithm_BaekJoon/assets/56071088/69293f13-1273-4a24-816e-44a6767f78e1">```java	private Set<BeanDefinition> addCandidateComponentsFromIndex(CandidateComponentsIndex index, String basePackage) {    ...    for (String type : types) {        MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(type);        ...}```type 으로부터 메타데이터를 읽어온다. 메타데이터를 읽는 reader가 바로 SimpleMetadataReader<br/>### 🔋 SimpleMetadataReaderclassReader, AnnotaionMetadataReadingVisitor 를 이용하여 클래스, 메서드에 붙어있는 어노테이션 정보를 가져온다.```javaSimpleMetadataReader(Resource resource, @Nullable ClassLoader classLoader) throws IOException {		SimpleAnnotationMetadataReadingVisitor visitor = new SimpleAnnotationMetadataReadingVisitor(classLoader);		getClassReader(resource).accept(visitor, PARSING_OPTIONS);		this.resource = resource;		this.annotationMetadata = visitor.getMetadata();}```<br/>### 🔋 ClassReaderasm 라이브러리를 스프링에서 아예 패키지 내부로 포함시킴<img width="727" alt="스크린샷 2024-07-09 오후 5 33 30" src="https://github.com/LeeHyungGeol/Algorithm_BaekJoon/assets/56071088/86b5d57c-7328-44d1-a042-fbf1a8818a48"><br/><br/><br/>## 참고- https://wiki.mhson.world/java-spring/java/undefined-1-1- https://www.youtube.com/watch?v=39kdr1mNZ_s- ASM, ByteBuddy, CGlib, PinPoint