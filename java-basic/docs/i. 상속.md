# 9. 상속# 💡 상속> **객체 지향 프로그래밍의 핵심 요소**> > 기존 클래스의 필드와 메서드를 새로운 클래스에서 재사용하게 해준다. 이름 그대로 **기존 클래스의 속성과 기능을 그대로 물려받는 것이다.**- **객체 지향 프로그래밍의 핵심 요소**- `extends` 키워드 사용- 부모클래스(슈퍼클래스): 상속을 통해 자신의 필드와 메서드를 다른 클래스에 제공- 자식클래스(서브클래스): 부모 클래스로부터 필드와 메서드를 받아 사용- **자바는 다중 상속을 지원하지 않음 -> 인터페이스 다중 구현 허용으로 한계 돌파**- 중복 코드 제거- 부모 클래스에 있는 멤버를 물려받으면서 기능을 확장(`extends`)<br/>## ⚡️ 상속과 메모리 구조<img width="454" alt="스크린샷 2024-07-10 오후 6 54 02" src="https://github.com/LeeHyungGeol/Algorithm_BaekJoon/assets/56071088/0ce7b20a-6387-48cd-b02f-b9fbf5227ca7"><img width="454" alt="스크린샷 2024-07-10 오후 6 54 18" src="https://github.com/LeeHyungGeol/Algorithm_BaekJoon/assets/56071088/d59a58b2-1518-47af-a0fe-8cbbeae20742">- 상속 관계의 객체를 생성하면 그 내부에는 부모와 자식이 모두 생성됨  - 자식 클래스의 인스턴스를 생성할 때, 부모 클래스의 인스턴스도 내부적으로 함께 생성됩니다.   - 하지만 **실제로 메모리에 할당되는 객체는 `자식 클래스의 인스턴스 하나`입니다.**   - **이 인스턴스에는 부모 클래스의 멤버(필드와 메서드)가 포함되어 있습니다.**- 상속 관계의 객체를 호출할 때 대상 타입을 정해야함. 호출하는 변수의 타입(클래스)을 기준으로 선택- 현재 타입에서 기능을 찾지 못하면 부모 타입으로 기능을 찾아서 실행함. 기능을 찾지못하면 컴파일 에러가 발생함<br/>## ⚡️ 메서드 오버라이딩 조건- **메서드 이름**: 메서드 이름이 같아야 한다.- **메서드 매개변수(파라미터)**: 매개변수(파라미터) 타입, 순서, 개수가 같아야 한다.- **반환 타입**: **반환 타입이 같아야 한다**. 단 반환 타입이 하위 클래스 타입일 수 있다.- **접근 제어자**는 상위 클래스의 메서드보다 더 제한적이어서는 안된다.- **예외**: 상위 클래스의 메서드보다 더 많은 체크 예외를 `throws` 로 선언할 수 없다.- `private`, `static`, `final` 은 오버라이딩 불가하다.- **생성자**는 오버라이딩 불가함<br/>## ⚡️**접근 제어와 메모리 구조**<img width="676" alt="스크린샷 2024-07-11 오후 1 25 08" src="https://github.com/LeeHyungGeol/Algorithm_BaekJoon/assets/56071088/dcf170fb-4715-4e9f-acab-3306a3e7c303">본인 타입에 없으면 부모 타입에서 기능을 찾는데, 이때 접근 제어자가 영향을 준다.  왜냐하면 객체 내부에서는 자식과 부모가 구분되어 있기 때문이다.  결국 자식 타입에서 부모 타입의 기능을 호출할 때, 부모 입장에서 보면 외부에서 호출 한 것과 같다.### 🔋 접근제어자 UML 표기법- `+`: `public`: 모든 외부 호출 가능- `#`: `protected`: 같은 패키지안에서 호출 허용, 패키지가 달라도 상속관계 호출 허용- `~`: `default`: 같은 패키지 호출 허용- `-`: `private`: 모든 외부호출 막음<br/>## ⚡️ super 생성자<img width="669" alt="스크린샷 2024-07-11 오후 2 16 22" src="https://github.com/LeeHyungGeol/Algorithm_BaekJoon/assets/56071088/3adbda6a-2d37-4ad3-9b8c-ee5376aaa907">- 상속 관계의 생성자 호출은 결과적으로 부모에서 자식 순서로 실행된다. 따라서 부모의 데이터를 먼저 초기화하고 그 다음에 자식의 데이터를 초기화한다.- **상속 관계에서 자식 클래스의 생성자 첫줄에 반드시 `super(...)` 를 호출해야 한다.** 단 기본 생성자(`super()`)인 경우 생략할 수 있다.### 🔋 this(...)와 함께 사용<img width="674" alt="스크린샷 2024-07-11 오후 2 15 16" src="https://github.com/LeeHyungGeol/Algorithm_BaekJoon/assets/56071088/80465d1c-f6ce-47a2-a44d-95d2e9f38618">코드의 첫줄에 `this(...)` 를 사용하더라도 반드시 한번은 `super(...)` 를 호출해야 한다.