# 3. 절차 지향 프로그래밍 vs 객체 지향 프로그래밍# 💡 절차 지향 프로그래밍- **실행 순서**를 중요하게 생각하는 방식- 프로그램의 흐름을 순차적으로 따르며 처리하는 방식- `어떻게`를 중심으로 프로그래밍- 데이터와 기능이 분리되어 있기 때문에 유지보수와 변경에 용이하지 않음<br/># 💡 객체 지향 프로그래밍- 객체를 지향함- 실제 세계의 사물이나 사건을 객체로 보고 이 **객체들 간의 상호작용을 중심으로 처리하는 방식**- `무엇`을 중심으로 프로그래밍- **객체 지향 프로그래밍은 `모든 사물을 속성과 기능을 가진 객체`로 생각하는 것이다. 객체에는 속성과 기능만 존재한다.**- 참고로 실세계와 객체가 항상 1:1로 매칭되는 것은 아니다.- 객체지향 대표적인 특징(캡슐화, 상속, 다형성, 추상화, 메시지 전달 등)<br/>## ⚡️ 차이점- 절차 지향은 `데이터`와 해당 `데이터에 대한 처리 방식`이 **분리**되어 있음- 객체 지향은 데이터와 그 데이터에 대한 행동(메서드)이 하나의 **`객체`안에 포함되어 있음**<br/>## ⚡️ 절차 지향 프로그래밍의 한계점<details><summary>절차 지향 프로그래밍의 한계점 예시</summary>```javapackage oop1;public class MusicPlayerData {    int volume = 0;    boolean isOn = false;}``````javapackage oop1;public class MusicPlayerMain3 {    public static void main(String[] args) {        MusicPlayerData data = new MusicPlayerData();        //음악 플레이어 켜기        on(data);        //볼륨 증가        volumeUp(data);        //볼륨 증가        volumeUp(data);        //볼륨 감소        volumeDown(data);        //음악 플레이어 상태        showStatus(data);        //음악 플레이어 끄기        off(data);    }    static void on(MusicPlayerData data) {        data.isOn = true;        System.out.println("음악 플레이어를 시작합니다");    }    static void off(MusicPlayerData data) {        data.isOn = false;        System.out.println("음악 플레이어를 종료합니다");    }    static void volumeUp(MusicPlayerData data) {        data.volume++;        System.out.println("음악 플레이어 볼륨:" + data.volume);    }    static void volumeDown(MusicPlayerData data) {        data.volume--;        System.out.println("음악 플레이어 볼륨:" + data.volume);    }    static void showStatus(MusicPlayerData data) {        System.out.println("음악 플레이어 상태 확인");        if (data.isOn) {            System.out.println("음악 플레이어 ON, 볼륨:" + data.volume);        } else {            System.out.println("음악 플레이어 OFF");        }    }}```</details>**우리가 작성한 코드의 한계는 바로 `데이터와 기능이 분리되어 있다는 점`이다.**   (음악 플레이어의 데이터는 `MusicPlayerData` 에 있는데, 그 데이터를 사용하는 기능은 `MusicPlayerMain3` 에 있는 각각의 메서드에 분리 되어 있다.)**`데이터`와 그 `데이터를 사용하는 기능`은 매우 밀접하게 연관되어 있다.**  (이후에 `MusicPlayerData` 관련 데이터가 변경되면 `MusicPlayerMain3` 부분의 메서드들도 함께 변경해야 한다.)**이렇게 데이터와 기능이 분리되어 있으면 유지보수 관점에서도 관리 포인트가 2곳으로 늘어난다.**객체 지향 프로그래밍이 나오기 전까지는 지금과 같이 데이터와 기능이 분리되어 있었다. 따라서 지금과 같은 코드가 최선이었다.  하지만 객체 지향 프로그래밍이 나오면서 데이터와 기능을 온전히 하나로 묶어서 사용할 수 있게 되었다.## ⚡️ 객체 지향 프로그래밍 예시<details><summary>객체 지향 프로그래밍 예시</summary>```javapackage oop1;public class MusicPlayer {    int volume = 0;    boolean isOn = false;    void on() {        isOn = true;        System.out.println("음악 플레이어를 시작합니다");    }    void off() {        isOn = false;        System.out.println("음악 플레이어를 종료합니다");    }    void volumeUp() {        volume++;        System.out.println("음악 플레이어 볼륨:" + volume);    }    void volumeDown() {        volume--;        System.out.println("음악 플레이어 볼륨:" + volume);    }    void showStatus() {        System.out.println("음악 플레이어 상태 확인");        if (isOn) {            System.out.println("음악 플레이어 ON, 볼륨:" + volume);        } else {            System.out.println("음악 플레이어 OFF");        }    }}``````javapackage oop1;public class MusicPlayerMain4 {    public static void main(String[] args) {        MusicPlayer player = new MusicPlayer();        //음악 플레이어 켜기        player.on();        //볼륨 증가        player.volumeUp();        //볼륨 증가        player.volumeUp();        // 볼륨 감소        player.volumeDown();        // 음악 플레이어 상태        player.showStatus();        // 음악 플레이어 끄기        player.off();    }}```</details>