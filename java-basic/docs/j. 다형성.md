# 10. 다형성<br/>`다형성을 이루는 핵심 이론`- **다형적 참조**: 하나의 변수 타입으로 다양한 자식 인스턴스를 참조할 수 있는 기능 - **메서드 오버라이딩**: 기존 기능을 하위 타입에서 새로운 기능으로 재정의<br/><br/><br/>## ⚡️ 다형적 참조> **하나의 변수 타입으로 다양한 자식 인스턴스를 참조할 수 있는 기능이다.**> > 이것이 바로 다양한 형태를 참조할 수 있다고 해서 `다형적 참조`라 한다.- `Parent poly = new Parent()`- `Parent poly = new Child()`- `Parent poly = new Grandson()` : `Child` 하위에 손자가 있다면 가능- `Child child1 = new Parent()` : **컴파일 오류 발생**- **부모는 자식을 담을 수 있다.**- **반대로 자식 타입은 부모 타입을 담을 수 없다.**<br/>## ⚡️ 캐스팅> **부모는 자식을 담을 수 있지만 자식은 부모를 담을 수 없다.**- `업캐스팅`: 부모 타입으로 변경  - **업캐스팅은 생략할 수 있다. 다운캐스팅은 생략할 수 없다. 참고로 업캐스팅은 매우 자주 사용하기 때문에 생략을 권장한 다.**- `다운캐스팅`: 자식 타입으로 변경  - 다운캐스팅 주의점  - 객체를 생성할 때 하위 자식은 생성되지 않기 때문에 하위로 내려가는 다운케스팅은 인스턴스 내부에 없는 부분을 선택하는 문제가 발생할 수 있다.  - `ClassCastException` **런타임 오류 발생**### 🔋 instanceof> **인스턴스의 타입을 확인**> > 자바 16부터는 `instanceof` 를 사용하면서 동시에 변수를 선언할 수 있다.```javaparent instanceof Parent //parent는 Child의 인스턴스new Parent() instanceof Parent //parent가 Parent의 인스턴스를 참조하는 경우: truenew Child() instanceof Parent //parent가 Child의 인스턴스를 참조하는 경우: true// 자바 16 - Pattern Matching for instanceofparent instanceof Child child```<br/>## ⚡️ 메서드 오버라이딩<img width="457" alt="스크린샷 2024-07-11 오후 4 26 20" src="https://github.com/LeeHyungGeol/Algorithm_BaekJoon/assets/56071088/1873bfe8-f0f1-4205-9557-e0d7d41b8390">```javaParent poly = new Child();System.out.println("value = "+poly.value); //변수는 오버라이딩X poly.method(); //메서드 오버라이딩!```> **오버라이딩 된 메서드가 항상 우선권을 가진다!!!**- **변수는 오버라이딩이 되지 않는다.**- 인스턴스 안에서 오버라이딩 된 메서드는 항상 우선권을 가짐- **메서드 오버라이딩**: **기존 기능을 하위 타입에서 새로운 기능으로 재정의**<br/><br/><br/>## ⚡️ 추상 클래스```javapublic abstract class AbstractAnimal {    public abstract void sound();    public void move() {        System.out.println("움직인다.");    }}```> `추상 클래스` : **상속을 목적으로 사용되는 클래스**- `abstract` 키워드를 클래스 선언 앞에 붙여준다.- **인스턴스화 불가하다**: 실체가 없는 메서드이기 때문에 사용할 수 없으므로 클래스가 인스턴스화되면 안되기 때문에 인스턴스화 하는 개발자 실수 방지## ⚡️ 추상 메서드> 추상 메서드는 선언할 때 메서드 앞에 추상이라는 의미의 `abstract` 키워드를 붙여주면 된다.- 추상 메서드는 메서드 바디가 없다.- **추상 메서드는 상속 받는 자식 클래스가 `반드시 오버라이딩` 해서 사용해야 한다.**: 오버라이딩 메서드를 깜박하고 개발하지 않는 개발자 실수 방지- **추상 메서드가 하나라도 있는 클래스는 `추상 클래스로 선언`해야 한다.**: 실체가 없는 메서드이기 때문에 사용할 수 없으므로 클래스가 인스턴스화되면 안되기 때문이다.  ## ⚡️ 순수 추상 클래스 -> 인터페이스```java public abstract class AbstractAnimal {     public abstract void sound();     public abstract void move();}```- 인스턴스를 생성할 수 없다.- 상속시 모든 메서드를 오버라이딩 해야 한다. - 주로 다형성을 위해 사용된다.- 자바에서는 사용하지 않는 개념 -> 자바에서는 순수 추상 클래스를 위해 인터페이스라는 개념을 제공함<br/><br/>## ⚡️ 인터페이스> **메서드 이름만 있는 설계도**- `public abstract` 키워드 생략 가능하고, **생략을 권장**- 순수 추상 클래스와 같으며 약간의 편의 기능이 추가되었다.- **다중 구현(상속)** 을 지원함- 인터페이스에 `멤버 변수` 사용 가능: 인터페이스의 멤버변수는 `public static final`이 모두 포함되어 있다고 간주됨: **`상수(CONSTANT)` 가 된다.**- 자바8의 `default 메서드`, 자바9의 `private 메서드`## **⚡️ 인터페이스를 사용해야 하는 이유**> - `제약` = 순수 추상클래스는 미래에 누군가가 추상 메서드가 아닌 메서드를 생성할 수 있음 -> **자식 클래스에서 실수하고 구현하지 않을 수 있으며 순수 클래스가 아니게 된다.**> - **`다중 구현`(다중 상속)**## ⚡️ 추상 클래스와 인터페이스의 쓰임새- 인터페이스는 구현이 전혀 없이 형식만 제공할 때 사용하고,- 추상 클래스는 일부 메서드의 구현이 필요할 때 사용합니다.- 실무에서도 많은 코드들이 추상클래스를 상속받아 사용합니다<br/><br/><br/># 💡 다형성- 객체지향 프로그래밍의 꽃 -> 가장 중요함- 다양한 형태, 한 객체가 여러 타입의 객체로 취급됨- 역할과 구현을 분리하게 해줌- 클라이언트는 내부구조를 몰라도됨- 세상이 단순해지고, 유연해지며 변경이 용이해짐- 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있음- 협력이라는 객체 사이의 관계 이해 필요- 클라이언트를 변경하지 않고 서버 구현 기능을 유연하게 변경(구현체 교체)할 수 있음- 디자인 패턴 대부분은 다형성을 활용함- 스프링 핵심 제어인 IOC(제어의 역전), DI(의존 관계 주입) 등### OCP- 확장에 열려 있음(구현체를 마음대로 추가 가능)- 코드 수정은 닫혀 있음    - 변하지 않는 부분 = 인터페이스를 사용하는 클라이언트 코드는 수정하지 않아도됨    - 변하는 부분 = 프로그램을 조율하는 부분(main 등)### 다중 상속 문제- 클래스 계층 구조가 복잡해짐- 부모에 같은 메서드가 있을시 어떤 메서드를 호출할지 애매해짐, 다이아몬드 문제### 다중 구현- 인터페이스에서는 다이아몬드 문제가 발생하지 않음