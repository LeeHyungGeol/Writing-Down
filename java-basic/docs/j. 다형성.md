# 10. 다형성<br/>`다형성을 이루는 핵심 이론`- **다형적 참조**: 하나의 변수 타입으로 다양한 자식 인스턴스를 참조할 수 있는 기능 - **메서드 오버라이딩**: 기존 기능을 하위 타입에서 새로운 기능으로 재정의<br/><br/><br/>## ⚡️ 다형적 참조> **하나의 변수 타입으로 다양한 자식 인스턴스를 참조할 수 있는 기능이다.**> > 이것이 바로 다양한 형태를 참조할 수 있다고 해서 `다형적 참조`라 한다.- `Parent poly = new Parent()`- `Parent poly = new Child()`- `Parent poly = new Grandson()` : `Child` 하위에 손자가 있다면 가능- `Child child1 = new Parent()` : **컴파일 오류 발생**- **부모는 자식을 담을 수 있다.**- **반대로 자식 타입은 부모 타입을 담을 수 없다.**<br/>## ⚡️ 캐스팅> **부모는 자식을 담을 수 있지만 자식은 부모를 담을 수 없다.**- `업캐스팅`: 부모 타입으로 변경  - **업캐스팅은 생략할 수 있다. 다운캐스팅은 생략할 수 없다. 참고로 업캐스팅은 매우 자주 사용하기 때문에 생략을 권장한 다.**- `다운캐스팅`: 자식 타입으로 변경  - 다운캐스팅 주의점  - 객체를 생성할 때 하위 자식은 생성되지 않기 때문에 하위로 내려가는 다운케스팅은 인스턴스 내부에 없는 부분을 선택하는 문제가 발생할 수 있다.  - `ClassCastException` **런타임 오류 발생**### 🔋 instanceof> **인스턴스의 타입을 확인**> > 자바 16부터는 `instanceof` 를 사용하면서 동시에 변수를 선언할 수 있다.```javaparent instanceof Parent //parent는 Child의 인스턴스new Parent() instanceof Parent //parent가 Parent의 인스턴스를 참조하는 경우: truenew Child() instanceof Parent //parent가 Child의 인스턴스를 참조하는 경우: true// 자바 16 - Pattern Matching for instanceofparent instanceof Child child```<br/>## ⚡️ 메서드 오버라이딩<img width="457" alt="스크린샷 2024-07-11 오후 4 26 20" src="https://github.com/LeeHyungGeol/Algorithm_BaekJoon/assets/56071088/1873bfe8-f0f1-4205-9557-e0d7d41b8390">```javaParent poly = new Child();System.out.println("value = "+poly.value); //변수는 오버라이딩X poly.method(); //메서드 오버라이딩!```> **오버라이딩 된 메서드가 항상 우선권을 가진다!!!**- **변수는 오버라이딩이 되지 않는다.**- 인스턴스 안에서 오버라이딩 된 메서드는 항상 우선권을 가짐- **메서드 오버라이딩**: **기존 기능을 하위 타입에서 새로운 기능으로 재정의**<br/><br/><br/>## ⚡️ 추상 클래스```javapublic abstract class AbstractAnimal {    public abstract void sound();    public void move() {        System.out.println("움직인다.");    }}```> `추상 클래스` : **상속을 목적으로 사용되는 클래스**- `abstract` 키워드를 클래스 선언 앞에 붙여준다.- **인스턴스화 불가하다**: 실체가 없는 메서드이기 때문에 사용할 수 없으므로 클래스가 인스턴스화되면 안되기 때문에 인스턴스화 하는 개발자 실수 방지## ⚡️ 추상 메서드> 추상 메서드는 선언할 때 메서드 앞에 추상이라는 의미의 `abstract` 키워드를 붙여주면 된다.- 추상 메서드는 메서드 바디가 없다.- **추상 메서드는 상속 받는 자식 클래스가 `반드시 오버라이딩` 해서 사용해야 한다.**: 오버라이딩 메서드를 깜박하고 개발하지 않는 개발자 실수 방지- **추상 메서드가 하나라도 있는 클래스는 `추상 클래스로 선언`해야 한다.**: 실체가 없는 메서드이기 때문에 사용할 수 없으므로 클래스가 인스턴스화되면 안되기 때문이다.  ## ⚡️ 순수 추상 클래스 -> 인터페이스```java public abstract class AbstractAnimal {     public abstract void sound();     public abstract void move();}```- 인스턴스를 생성할 수 없다.- 상속시 모든 메서드를 오버라이딩 해야 한다. - 주로 다형성을 위해 사용된다.- 자바에서는 사용하지 않는 개념 -> 자바에서는 순수 추상 클래스를 위해 인터페이스라는 개념을 제공함<br/><br/>## ⚡️ 인터페이스> **메서드 이름만 있는 설계도**- `public abstract` 키워드 생략 가능하고, **생략을 권장**- 순수 추상 클래스와 같으며 약간의 편의 기능이 추가되었다.- **다중 구현(상속)** 을 지원함- 인터페이스에 `멤버 변수` 사용 가능: 인터페이스의 멤버변수는 `public static final`이 모두 포함되어 있다고 간주됨: **`상수(CONSTANT)` 가 된다.**- 자바8의 `default 메서드`, 자바9의 `private 메서드`## **⚡️ 인터페이스를 사용해야 하는 이유**> - `제약` = 순수 추상클래스는 미래에 누군가가 추상 메서드가 아닌 메서드를 생성할 수 있음 -> **자식 클래스에서 실수하고 구현하지 않을 수 있으며 순수 클래스가 아니게 된다.**> - **`다중 구현`(다중 상속)**## ⚡️ 추상 클래스와 인터페이스의 쓰임새- 인터페이스는 구현이 전혀 없이 형식만 제공할 때 사용하고,- 추상 클래스는 일부 메서드의 구현이 필요할 때 사용합니다.- 실무에서도 많은 코드들이 추상클래스를 상속받아 사용합니다### 🔋 다중 상속 문제- 클래스 계층 구조가 복잡해짐- **부모에 같은 메서드가 있을시 어떤 메서드를 호출할지 애매해짐**, 다이아몬드 문제### 🔋 다중 구현- 인터페이스에서는 다이아몬드 문제가 발생하지 않음<br/><br/><br/># 💡 다형성다형성은 객체지향 프로그래밍의 꽃. 다형성이 가장 중요하다!!!> <u>중요한 것은 **역할**과 **구현**을 **분리**하는 것!!!</u>- 역할: 인터페이스- 구현: 인터페이스를 구현한 클래스, 구현 객체> <u>세상이 단순해지고, **유연**해지며 **변경이 용이**해진다.</u>- 클라이언트는 구현 대상의 *내부 구조가 변경*되어도 _영향을 받지 않는다._- 클라이언트는 구현 *대상 자체가 변경*되어도 _영향을 받지 않는다._클라이언트: 요청하는 것  서버: 요청에 응답하는 것> <u>`다형성의 본질`: **클라이언트를 변경하지 않고 서버의 구현 기능을 유연하게 변경할 수 있다.**</u>- 객체의 협력이라는 관계부터 생각- 수 많은 객체 클라이언트와 객체 서버는 서로 협력 관계를 가진다.- 인터페이스를 구현한 객체 인스턴스를 **실행 시점**에 **유연**하게 **변경**할 수 있다.## ⚡️ 정리- 역할과 구현을 분리- 확장에 용이하다.- 클라이언트에 영향을 주지 않는 변경 가능- 디자인 패턴 대부분은 다형성을 활용함  - 스프링 핵심 제어인 IOC(제어의 역전), DI(의존 관계 주입) 등> 따라서, <u>**인터페이스를 안정적으로 잘 설계하는 것이 중요하다.**</u><br/><br/>## ⚡️ OCP- **Open for extension**: 새로운 기능의 추가나 변경 사항이 생겼을 때, 기존 코드는 확장할 수 있어야 한다. (구현체를 마음대로 추가 가능하다.)- **Closed for modification**: 기존의 코드는 수정되지 않아야 한다.  - `확장에 열려있다`: 인터페이스를 통해서 구현체를 마음대로 추가, 변경할 수 있다.  - `코드 수정에 닫혀 있다`: 기능을 추가하면, 당연히 새로운 코드는 작성해야 하고, 당연히 어딘가의 코드는 수정해야 하지만, 클라이언트의 코드는 변경하지 않아도 된다는 뜻이다.    - `변하지 않는 부분`: 인터페이스를 사용하는 **클라이언트 코드는 수정하지 않아도 된다.**  - `변하는 부분`: 프로그램을 조율하는 부분(main 등)<br/>## ⚡️ 전략 패턴(Strategy Pattern)<img width="772" alt="스크린샷 2024-07-17 오후 7 32 30" src="https://github.com/user-attachments/assets/268e811d-1cac-420e-9b01-1c824ca21802">- `디자인 패턴` 중에 **가장 중요한 패턴을 하나** 뽑으라고 하면 `전략 패턴`을 뽑을 수 있다. - `전략 패턴`은 **알고리즘을 클라이언트 코드의 변경 없이 쉽게 교체할 수 있다.**  위의 그림이 바로 전략 패턴을 사용한 것이다.   `Car` 인 터페이스가 바로 전략을 정의하는 인터페이스가 되고, 각각의 차량이 전략의 구체적인 구현이 된다.  그리고 전략을 클라이언트 코드(`Driver`)의 변경 없이 손쉽게 교체할 수 있다.<br/>### 🔋 null object pattern```javapublic class DefaultPay implements Pay {     @Override     public boolean pay(int amount) {         System.out.println("결제 수단이 없습니다.");         return false;    } }```> **null 대신에 객체를 넣어서 null 을 처리하는 방법**> > : `null` 체크를 피할 수 있다.