# 7. 자바 메모리 구조와 static# 💡 자바 메모리 구조## ⚡️ 비유<img width="905" alt="스크린샷 2024-07-12 오후 2 09 17" src="https://github.com/user-attachments/assets/6ee4a9d5-edd8-4efc-a276-f0a281f6e4b6">- `메서드 영역`: 클래스 정보 보관(붕어빵 틀)- `스택 영역`: 실제 프로그램이 실행되는 영역, 메서드를 실행할 때마다 하나씩 쌓임- `힙 영역`: 객체(인스턴스)가 생성되는 영역, new 명령어를 사용하면 이 영역을 사용함, 붕어빵 틀로부터 생성된 붕어빵이 존재하는 공간, 배열도 이 공간을 사용함## ⚡️ 실제<img width="904" alt="스크린샷 2024-07-12 오후 2 09 41" src="https://github.com/user-attachments/assets/b478fe2e-7e40-408c-9953-a1532bcf56d2">- `메서드 영역(method area)`: 프로그램 실행에 필요한 공통 데이터 관리  - `클래스 정보`: 클래스의 실행 코드(바이트 코드), 필드, 메서드와 생성자 코드 등  - `static 영역`: static 변수들을 보관  - `런타임 상수 풀`: 프로그램을 실행하는데 필요한 공통 리터럴 상수를 보관, "hello"라는 문자열가 있으면 이런 문자를 공통으로 묶어서 관리함- `스택 영역(stack area)`: 자바 실행 시 하나의 실행 스택이 생성됨, 각 스택 프레임은 지역 변수, 중간 연산결과, 메서드 호출 정보등을 포함함  - `스택 프레임`: 스택 영역에 쌓이는 네모 박스가 하나의 스택 프레임임, 메서드 호출할 떄마다 하나의 스택 프레임이 쌓이고 메서드가 종료되면 해당 스택 프레임이 제거됨    - 각 쓰레드 별로 하나의 실행 스택이 생성됨 = 쓰레드 수 만큼의 스택 영역이 생성됨- `힙 영역(heap area)`: 객체(인스턴스)와 배열이 생성되는 영역, 가비지 컬렉션(GC)이 이루어지는 주요 영역, 더이상 참조하지 않는 객체는 GC에 의해 제거됨  - **클래스를 로딩만해도 .class 타입의 객체가 저장이 된다.**  - 힙 영역 안에서만 인스턴스끼리 서로 참조해도 GC에서 제거됨## ⚡️ 메서드 코드는 메서드 영역에> **정리하면 인스턴스의 메서드를 호출하면 실제로는 메서드 영역에 있는 코드를 불러서 수행한다.**- 클래스가 100개의 인스턴스를 생성하면 힙 메모리에 100개의 인스턴스가 생기지만 메서드는 메서드 영역에 있는 공통된 코드를 공유함- 새로운 객체가 생성될 때 인스턴스 변수에는 메모리가 할당되지만 메서드에 대한 새로운 메모리 할당은 없음## ⚡️ 스택 영역**자바는 스택 영역을 사용해서 메서드 호출과 지역 변수(매개변수 포함)를 관리한다.** - 메서드를 계속 호출하면 스택 프레임이 계속 쌓인다.- 스택 프레임이 종료되면 지역 변수도 함께 제거된다.- 스택 프레임이 모두 제거되면 프로그램도 종료된다.## ⚡️ 힙 영역- `GC(가비지 컬렉션)`은 참조가 모두 사라진 인스턴스를 찾아서 메모리에서 제거한다.- 힙 영역 외부가 아닌, `힙 영역 안에서만 인스턴스끼리 서로 참조`하는 경우에도 **GC의 대상**이 된다.  - 이 경우에 프로그램에서 그 메모리에 접근할 방법이 없기 때문이다.<br/><br/><br/># 💡 멤버 변수(필드)의 종류- `인스턴스 변수`: **static 이 붙지않음**  - 인스턴스를 생성해야 사용할 수 있으며 인스턴스에 소속됨  - 인스턴스 변수를 만들 때 마다 새로 만들어짐- `클래스 변수`: **static 이 붙음**  - 클래스 변수, 정적 변수, static 변수  - 인스턴스와 무관하게 클래스에 바로 접근해서 사용가능, 클래스에 소속되어 있음  - 자바 프로그램이 시작할 때 딱 1개가 만들어짐, 인스턴스와는 다르게 보통 여러곳에서 공유하는 목적으로 사용함<br/>## ⚡️ 변수와 생명주기- `지역 변수(매개변수 포함)`: 스택영역안에 스택프레임안에 보관됨, 메서드가 종료되면 스택 프레임도 제거되는데 이때 해당 스택프레임에 포함된 지역변수도 함께 제거됨, 생존주기가 짧음- `인스턴스 변수`: 인스턴스에 있는 멤버변수, 힙 영역을 사용함, 힙영역은 GC가 발생하기 전까지 생존하기 때문에 지역변수보다 생존주기가 김- `클래스 변수`: 메서드 영역의 static 영역에 보관됨, 메서드 영역은 프로그램 전체에서 사용하는 공용 공간, 클래스 변수는 해당 클래스가 JVM에 로딩되는 순간 생성됨, JVM이 종료될 때 까지 생명주기가 이어짐, 생명주기가 제일 김<br/>## ⚡️ 정적 변수, 메서드 접근 법**인스턴스를 통한 접근 `data4.count`, `data4.staticCall()`**  - 정적 변수의 경우 인스턴스를 통한 접근은 추천하지 않는다. **왜냐하면 코드를 읽을 때 마치 인스턴스 변수에 접근하는 것 처럼 오해할 수 있기 때문이다.*****클래스를 통한 접근 `Data3.count`, `Data3.staticCall()` <- 이 방법을 사용하자!***  - 정적 변수는 클래스에서 공용으로 관리하기 때문에 클래스를 통해서 접근하는 것이 더 명확하다. 따라서 정적 변수에 접근할 때는 클래스를 통해서 접근하자.<br/>## ⚡️ 멤버 메서드의 종류- 인스턴스 메서드: static 이 붙지않음  - **인스턴스 생성 시점**에 인스턴스와 함께 `메서드 영역`에 로드됩니다.- 클래스 메서드: static 이 붙음  - **클래스 로딩 시점**에 `메서드 영역`에 로드됩니다.  - 클래스 메서드, 정적 메서드, static 메서드<br/>## ⚡️ 정적, 인스턴스 메서드 호출 시 JVM 의 처리 과정- **정적 메서드 호출 시**: JVM 은 메서드 영역에서 해당 메서드를 바로 찾아 실행합니다. 인스턴스 참조가 없기 때문에 this 키워드를 사용할 수 없습니다.- **인스턴스 메서드 호출 시**: JVM 은 해당 인스턴스의 참조를 기반으로 메서드 영역에서 메서드를 찾아 실행합니다. 이 때, 인스턴스 참조는 `this` 키워드로 전달됩니다.<br/>## ⚡️ 정적 메서드 활용- 객체 생성 없이 메서드의 호출만으로 필요한 기능을 수행할 때 사용- **유틸리티성 메서드에 자주 사용**  - 유틸리티성 클래스 생성 시에 인스턴스 생성을 하지 못하도록 `private 생성자`를 설정하자.<br/>