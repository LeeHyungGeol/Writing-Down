# 1. JVM 이해하기<br/>## 목차- 자바, JVM, JDK 그리고 JRE- JVM 의 구조- 클래스로더 시스템<br/><br/><br/># 💡 자바, JVM, JDK 그리고 JRE<img width="812" alt="스크린샷 2024-07-04 오후 6 10 36" src="https://github.com/LeeHyungGeol/Algorithm_BaekJoon/assets/56071088/0034a75e-d15b-4d78-8ba9-809b6f60432a">## ⚡️ JVM (Java Virtual Machine)**자바 바이트 코드 예시**<img width="793" alt="스크린샷 2024-07-04 오후 6 05 03" src="https://github.com/LeeHyungGeol/Algorithm_BaekJoon/assets/56071088/a3296e34-273f-4527-bb3e-dd8e80eaa63e">> **`자바 바이트 코드(.class 파일)`를 어떻게 실행할 수 있는지에 대한 스펙이다.**   구현체는 다양하다.   플랫폼에 종속적이다  (native code 로 바꿔서 실행해야 하는데, native code 라는 것이 OS 에 맞춰서 실행해야 하기 때문이다.)- 자바 가상머신(Java Virtual Machine)으로 `자바 바이트 코드(.class 파일)`를 인터프리터, JIT(Just In Time) 컴파일러를 사용해서 Native OS(ex: mac, windows) 에 맞춰서 머신이 이해할 수 있는 코드(머신 코드)로 변형한 뒤 실행하는 역할을 한다.- 바이트 코드를 실행하는 표준이자 구현체 이다.    - JVM 자체는 **표준(JVM 자체는 표준)** 이며, **구현체(특정 벤더가 구현한 JVM)** 이다- JVM 스펙    - https://docs.oracle.com/javase/specs/jvms/se11/html/- **특정 플랫폼(OS)(mac, windows...)에 종속적이다.**`JVM의 역할`- 클래스를 읽어 들인다.- 메모리에 로드한다.- 여러 구역으로 나뉘어진 메모리 공간을 관리한다.- 바이트 코드를 실행(인터프리터, JIT 컴파일러를 사용해서 OS 에 맞는 머신 코드로 변환 후 실행)`벤더`- 오라클, 아마존, Azul ...## ⚡️ JRE(Java Runtime Environment)> **자바 애플리케이션을 실행할 수 있도록 구성된 배포판**- JVM 홀로 제공 되지않으며 최소한의 배포단위가 JRE 이다.- JVM과 몇몇 라이브러리를 같이 배포한다.- Java 애플리케이션을 실행하도록 하는것이 목적이다.- Java 애플리케이션을 실행하기위한 최소한의 패키지이다.- **개발시 필요한 툴들은 제공하지 않는다.**  - `자바 컴파일러(javac)`는 들어있지 않음 (JDK 에 들어있다.)## ⚡️ JDK(Java Development Kit)- JRE + 개발에 필요한 툴- 자바 11부터는 JDK만 제공하고, JRE를 따로 제공하지 않는다.- Write One Run Anywhere- Java9 부터 모듈 시스템을 제공한다.- 모듈 시스템을 이용하여 JRE를 구성할수 있다.    - Jlink## ⚡️  자바- 프로그래밍 언어- JDK에 들어있는 자바 컴파일러를 사용하여 바이트코드로 컴파일 할 수 있다.- 자바를 JDK, JRE, JVM을 통틀어 말하는 케이스가 많다.- 자바 유료화 ? -> 오라클에서 만든 Oracle JDK11 부터 상용으로 사용시 유료이다.    - https://medium.com/@javachampions/java-is-still-free-c02aef8c9e04자바는 일단 어디선가 한번 컴파일 했으면, OS를 옮겨가도 다시 컴파일 할 필요는 없다.   컴파일 한 그 결과물(바이트코드와 자바 코드가)이 동일하게 유지된다.   **즉, 다시 코드를 짜거나 컴파일 할 필요 없다. 그냥 그대로 OS가 바껴도 쓸 수 있다.**### 🔋 타 프로그래밍 언어 지원- JVM 기반으로 작동하는 프로그래밍 언어- 클로저, 그루비, JRuby, Jython, Kotlin, Scala..jar = java + archive### 참조- JIT 컴파일러    - https://aboullaite.me/understanding-jit-compiler-just-in-time-compiler/- JDK, JRE 그리고 JVM    - https://howtodoinjava.com/java/basics/jdk-jre-jvm/    - https://en.wikipedia.org/wiki/List_of_JVM_languages<br/><br/><br/># 💡 JVM 의 구조<img width="801" alt="스크린샷 2024-07-07 오후 6 23 19" src="https://github.com/LeeHyungGeol/Algorithm_BaekJoon/assets/56071088/3f61a0e0-8901-4240-b10b-e02f89f14d30">## ⚡️ 클래스로더> .class 에서 바이트코드를 읽고 메모리에 저장- 로딩: 클래스 읽어오는 과정- 링크: 레퍼런스들을 연결한다- 초기화: static 값들 초기화 및 변수에 할당<br/>## ⚡️ 메모리크게 5가지 영역이 존재한다.### **🔋 메소드 영역**- 클래스 수준의 정보  - (클래스 정보: 클래스의 실행 코드(바이트 코드), 필드, 메서드, 생성자 코드등 모든 실행 코드가 존재한다.)- static 영역: static 변수들을 보관한다.- 런타임 상수 풀: 프로그램을 실행하는데 필요한 공통 리터럴 상수를 보관한다.- 클래스명(패키지명 포함), 부모클래스명(상속받은 클래스 존재시)- 메소드 영역에 존재하는 자원은 공유자원이다.- 다른영역에서 접근이 가능하다.### **🔋 힙 영역**- 인스턴스를 저장한다.- **클래스를 로딩만해도 .class 타입의 객체가 저장이 된다.**  - App 클래스가 로드되면 App.class 객체가 저장된다.- 명시적으로 생성한 객체도 저장된다.### **🔋 스택 영역** (Thread)- 스레드에서 공유하는 자원- 스레드마다 RuntimeStack 이 생성되고, 내부에 Stack Frame 을 쌓는다.- 각 Stack Frame 은 지역 변수, 중간 연산 결 과, 메서드 호출 정보 등을 포함한다.- StackFrame 은 Method Call이다.### **🔋 PC register** (Thread)- Program Counter의 약자- 스레드 마다 스레드 내 현재 실행할 Stack Frame을 가리키는 포인터가 생성된다.### **🔋 Native Method Stack** (Thread)- Native Method Stack 호출시마다 별도로 쌓이는 스택이다- NativeMethod는 Method에 Native 키워드가 붙어있고, **해당 구현을 자바가 아닌 C, C++ 로 구현된 메서드**를 의미한다.- `JNI` 를 통해 `네이티브 메소드 라이브러리`를 사용한다.### ⚡️ `JNI(Java Native Interface)`- 자바 애플리케이션에서 C, C++, 어셈블리로 작성된 함수를 사용할 수 있는 방법을 제공한다.- Native 키워드를 사용한 메소드를 호출한다.### ⚡️ `네이티브 메소드 라이브러리`- C, C++ 등으로 작성된 라이브러리<br/>## ⚡️ 실행엔진### 🔋 인터프리터: - 바이트 코드를 한줄씩 실행하면서 네이티브 코드로 컴파일해서 실행한다.### 🔋 JIT컴파일러: - 인터프리터의 효율을 높이기 위해, 인터프리터가 반복되는 바이트 코드를 발견하면 JIT컴파일러로 반복되는 바이트 코드를 모두 네이티브 코드로 바꿔버린다.   그 뒤 부터 인터프리터는 네이티브 코드를 실행한다.   이렇게 해서 실행속도를 향상 시킨다.### 🔋 GC가비지 컬렉터, 더이상 참조되지 않는 객체를 모아 정리한다.- 객체 생성이 많고, Response Time이 중요할 경우 STW(Stop The World) 를 줄이는 GC를 사용하는것이 좋다.- GC 를 둘로 나누면, `Throughput 위주의 GC` 와 `STW(Stop The World) 를 줄이는 GC` 가 있다.- STW(Stop The World) 는 GC를 할 때 발생하는 Pause 현상, 즉, 멈춤 현상을 의미한다.### 참조- https://javapapers.com/core-java/java-jvm-run-time-data-areas/#Program_Counter_PC_Register- https://medium.com/@bschlining/a-simple-java-native-interface-jni-example-in-java-and-scala-68fdafe76f5f- https://www.geeksforgeeks.org/jvm-works-jvm-architecture/- https://dzone.com/articles/jvm-architecture-explained- http://blog.jamesdbloom.com/JVMInternals.html<br/><br/><br/># 💡 클래스로더 시스템<img width="637" alt="스크린샷 2024-07-07 오후 6 58 38" src="https://github.com/LeeHyungGeol/Algorithm_BaekJoon/assets/56071088/38d40596-5f27-43cb-96e8-b212a7694c5e">## ⚡️ 클래스 로더> **클래스 로더의 처리 과정은 로딩, 링크, 초기화 3단계로 나뉜다.**- 로딩 -> 링크 -> 초기화 순으로 진행된다.<br/><br/>## ⚡️ 로딩> **클래스 로더가 `바이트 코드(.class 파일)` 을 읽고, 내용에 따라 적절한 바이너리 데이터를 생성하고, `메소드 영역`에 저장한다.**### 🔋 `메소드 영역에 저장되는 데이터`- FQCN(Fully Qualified Class Name)  - 풀패키지 경로- 클래스 인지 인터페이스 인지 Enum 인지 구분을 한다- 메소드와 변수- 로드가 끝나면 해당 클래스타입의 Class객체를 생성하여 `힙 영역`에 저장한다.<br/>**클래스로더는 3개의 계층구조로 이루어져 있으며 3가지 기본 클래스 로더가 제공된다.**- 부트스트랩 클래스 로더 (네이티브)- 플랫폼 클래스 로더- 애플리케이션 클래스 로더**클래스로더의 로드 과정**1. 부트스트랩 클래스 로더에게 요청한다.2. 플랫폼 클래스 로더에게 요청한다.3. 애플리케이션 클래스로더가 로드를 시도한다.4. 모두 읽지 못한다면 **`ClassNotFoundException`** 예외가 발생한다.### 🔋 `부트스트랩 클래스 로더`- JAVA_HOME\lib에 존재하는 코어 자바 API를 제공한다.- 최상위 우선순위를 가진다.### 🔋 `플랫폼 클래스 로더`- JAVA_HOME\lib\ext 폴더 혹은 java.ext.dirs 시스템 변수에 해당하는 위치에 존재하는 클래스를 로드한다.### 🔋 `애플리케이션 클래스로더`- 애플레케이션 클래스패스 에서 클래스를 로드한다.<br/><br/>## ⚡️ 링크### 🔋 Verify- .class 파일의 형식이 유효한지 검증한다.### 🔋 Prepare- 클래스 변수(static 변수)와 기본값에 필요한 메모리를 준비하는 과정### 🔋 Resolve (Optional)- 심볼릭 메모리 렌퍼런스를 메소드 영역에 존제하는 실제 레퍼런스로 교체한다.- 이때 발생할 수 있고, 실제로 사용할때 일어날 수도 있음`심볼릭 레퍼런스`- 실제 레퍼런스를 가리키고 있지 않은 상태- 논리적인 레퍼런스이다.<br/><br/>## ⚡️ 초기화- static 변수의 값을 초기화한다- static 블럭을 초기화한다.