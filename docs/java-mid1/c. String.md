# 3. String 클래스# 💡 String 클래스 - 기본- 자바에서 문자를 다루는 타입은 `char`, `String` 2가지다- `char`를 이용해 여러 문자를 나열하려면 `char[]`를 사용해야하는데 매우 불편하다```javaString str1 = "hello";```- `String`은 클래스다. `int`, `boolean`과 같은 기본형이 아니라 참조형인데도, new를 사용하지 않고 선언할 수 있다- 자바에서는 편의상 문자열을 쌍따옴표로 감싸면 아래와 같이 변경해준다. (실제로는 성능최적화를 위해 문자열 풀을 사용한다)```javaString str2 = new String("hello");```## ⚡️ String 클래스 - 구조- 클래스이므로 속성과 기능을 가진다- 속성(필드) : String의 실제 문자열 값이 보관된다. 문자 데이터 자체는 char[]에 보관된다- String 클래스는 개발자가 직접 다루기 불편한 char[]를 내부에 감춘다.- 자바9부터는 String에서 char[]가 아닌 `byte[]`를 사용한다```javapublic final class String    implements java.io.Serializable, Comparable<String>, CharSequence,               Constable, ConstantDesc {    /**     * The value is used for character storage.     *     * @implNote This field is trusted by the VM, and is a subject to     * constant folding if String instance is constant. Overwriting this     * field after construction will cause problems.     *     * Additionally, it is marked with {@link Stable} to trust the contents     * of the array. No other facility in JDK provides this functionality (yet).     * {@link Stable} is safe here, because value is never null.     */    @Stable    private final byte[] value;}```## ⚡️ byte를 사용하는 이유?- char는 2byte를 사용한다. 그런데 `영어, 숫자`는 보통 `1byte`로 표현한다.- `한글`과 같은 표현하기 어려운 문자들이 섞여있는 경우에는 하나당 `2byte`를 사용한다.- 메모리를 효율적으로 사용하기 위해, byte[]을 사용한다## ⚡️ String 클래스 - 참조형- String은 클래스다. 즉, 기본형이 아니라 참조형이다(주소값이라는 이야기)- 원칙적으로는 `+` 연산이 불가하지만, 자바에서는 concat()을 사용하지 않아도 `+` 연산이 가능하게 설계되어 있다```javaString a = "hi";String b = " bye";String res1 = a.concat(b);String res2 = a + b; // 원칙적으로 주소값끼리 + 연산은 불가능하지만 가능하게 설계```<br/><br/><br/># 💡 String 클래스 - 비교> `String 클래스`는 항상 `==`가 아닌 `equals()`를 사용해야한다. **문자열 비교**는 항상 `equals()` 를 사용하자!!! (new 로 생성한 인스턴스가 들어올지, 문자열 풀에 있는 인스턴스가 들어올지 아무도 모른다.)```javaString str1 = "hello";String str2 = "hello";```- str1 == str2가 true인 이유는 뭘까?- true인 이유는 자바의 `문자열 풀(String Pool)` 때문이다- 자바는 메모리 효율성과 성능 최적화를 위해 문자열 풀을 사용한다- 자바가 실행되는 시점에 클래스에 문자열 리터럴이 있으면 문자열 풀에 `String 인스턴스`를 미리 만든다- 이 때, 같은 문자열이 있으면 만들지 않는다  ![image](https://github.com/ngngs/TIL/assets/47618270/f166a471-9f22-457a-88a0-7811d0368a26)### 🔋 동일성(==), 동등성(equals)- 동일성 : 두 객체의 `참조`가 같은지- 동등성 : 두 객체가 `논리적으로` 같은지### 🔋 프로그래밍 풀(Pool)- 풀은 공용 자원이 모여있는 곳을 의미한다- 여러 곳에서 함께 사용할 수 있는 객체를 미리 만들어두고 재사용하여 성능과 메모리를 최적화한다- 문자열 풀은 힙 영역을 사용한다.(해시 알고리즘을 사용하기 때문에 검색하고 반환하는데 매우 빠르다)<br/><br/><br/># 💡 String 클래스 - 불변 객체- String 은 final로 선언되어있다- 그렇기 때문에, 앞서 배운 것(불변객체)에 이어 설명하면 concat은 새로운 객체(즉, 새로운 스트링)를 return한다!```javaprivate final byte[] value;```## ⚡️ String 이 불변으로 설계된 이유: 문자열 풀`String` 은 자바 내부에서 `문자열 풀`을 통해 **최적화**를 한다.만약 `String` 내부의 값을 변경할 수 있다면, **기존에 문자열 풀에서 같은 문자를 참조하는 변수의 모든 문자가 함께 변경되어 버리는 문제가 발생한다.**  String 이 불변 클래스로 설계되어 있기 때문에 이러한 side effect 가 발생하지 않는다. `String str3 = "hello"` `String str4 = "hello"`<br/><br/><br/># 💡 String 클래스 - 주요 메서드- 모든 걸 외울 필요는 없지만 명심할 건, String은 불변객체기 때문에 모든 메서드가 새로운 String을 반환한다- `CharSequence`는 String, Stringbuilder의 상위 타입이다<details><summary>String 클래스 주요 메서드</summary>## **⚡️ 문자열 정보 조회**- `length()` : 문자열의 길이를 반환한다.- `isEmpty()` : 문자열이 비어 있는지 확인한다. (길이가 0)- `isBlank()` : 문자열이 비어 있는지 확인한다. (길이가 0이거나 공백(Whitespace)만 있는 경우), 자바 11 - `charAt(int index)` : 지정된 인덱스에 있는 문자를 반환한다.## **⚡️ 문자열 비교**- `equals(Object anObject)` : 두 문자열이 동일한지 비교한다. - `equalsIgnoreCase(String anotherString)` : 두 문자열을 대소문자 구분 없이 비교한다. - `compareTo(String anotherString)` : 두 문자열을 사전 순으로 비교한다. - `compareToIgnoreCase(String str)` : 두 문자열을 대소문자 구분 없이 사전적으로 비교한다. - `startsWith(String prefix)` : 문자열이 특정 접두사로 시작하는지 확인한다. - `endsWith(String suffix)` : 문자열이 특정 접미사로 끝나는지 확인한다.## **⚡️ 문자열 검색**- `contains(CharSequence s)` : 문자열이 특정 문자열을 포함하고 있는지 확인한다.- `indexOf(String ch)` / `indexOf(String ch, int fromIndex)` : 문자열이 처음 등장하는 위치를 반환한다.- `lastIndexOf(String ch)` : 문자열이 마지막으로 등장하는 위치를 반환한다.## **⚡️ 문자열 조작 및 변환**- `substring(int beginIndex)` / `substring(int beginIndex, int endIndex)` : 문자열의 부분 문자열을 반환한다.- `concat(String str)` : 문자열의 끝에 다른 문자열을 붙인다.- `replace(CharSequence target, CharSequence replacement)` : 특정 문자열을 새 문자열로 대체 한다.- `replaceAll(String regex, String replacement)` : 문자열에서 정규 표현식과 일치하는 부분을 새 문자열로 대체한다.- `replaceFirst(String regex, String replacement)` : 문자열에서 정규 표현식과 일치하는 첫 번째 부분을 새 문자열로 대체한다.- `toLowerCase()` / `toUpperCase()` : 문자열을 소문자나 대문자로 변환한다. - `trim()` : 문자열 양쪽 끝의 공백을 제거한다. 단순 `Whitespace` 만 제거할 수 있다. - `strip()` : `Whitespace` 와 유니코드 공백을 포함해서 제거한다. 자바 11  - `stripLeading()`: 앞 공백 제거  - `stripTrailing()`: 뒤 공백 제거## **⚡️ 문자열 분할 및 조합**- `split(String regex)` : 문자열을 정규 표현식을 기준으로 분할한다.- `join(CharSequence delimiter, CharSequence... elements)` : 주어진 구분자로 여러 문자열을 결합한다.## **⚡️ 기타 유틸리티**- `valueOf(Object obj)` : 다양한 타입을 문자열로 변환한다.- `toCharArray():` 문자열을 문자 배열로 변환한다.- `format(String format, Object... args)` : 형식 문자열과 인자를 사용하여 새로운 문자열을 생성한다.- `matches(String regex)` : 문자열이 주어진 정규 표현식과 일치하는지 확인한다.</details><br/><br/><br/># 💡 Stringbuilder - 가변 String- `String`의 단점 : 새로운 String이 만들어지지만, 최종적으로는 만들어진 String만 사용한다(중간 String은 전부 GC대상)- 컴퓨터의 cpu, 메모리 자원을 많이 사용한다- 불변이 아닌 가변 String인 `StringBuilder`를 사용한다- StringBuilder의 상위 클래스인 AbstractStringBuilder를 보면 final이 빠져있다```javaabstract class AbstractStringBuilder implements Appendable, CharSequence {    /**     * The value is used for character storage.     */    byte[] value;}```## ⚡️ String 최적화- **`자바 컴파일러`는 다음과 같이 문자열 리터럴을 더하는 부분을 자동으로 합친다.****컴파일 전**```javaStirng hello = "Hello," + "World";```**컴파일 후**```javaString hello = "Hello,World";```**String 변수 최적화**문자열 변수의 경우 그 안에 어떤 값이 들어있는지 컴파일 시점에는 알 수 없기 때문에 단순하게 합칠 수 없다. 그래서 아래와 같이 최적화가 이루어진다.   `String result = str1 + str2;` `String result = new StringBuilder().append(str1).append(str2).toString();` 따라서, **런타임에 별도의 문자열 결합 연산을 수행하지 않아 성능이 향상된다.** - **최적화 방식은 자바 버전에 따라 다르다(자바9부터 `StringConcatFactory`를 사용한다)**> **자바가 최적화를 처리해주기 때문에 지금처럼 간단한 경우에는 `StringBuilder` 를 사용하지 않아도 된다. 대신에 문자열 더하기 연산(`+`)을 사용하면 충분하다.**### 🔋 String 최적화가 어려운 경우- 단, 문자열 변수의 경우 그 안에 어떤 값이 들어갔는지 알 수 없어 단순히 합치지 않는다.- 문자열을 루프안에서 문자열을 더하는 경우에는 최적화가 이루어지지 않는다.- 예를 들어, 다음의 경우 반복문의 루프 내부에서는 최적화가 되는 것 처럼 보이지만, 반복 횟수만큼 객체를 생성해야 한다.(M3 기준 time = 1562ms)- 이런 경우, 컴파일러는 얼마나 많은 반복이 일어날지, 각 반복에서 문자열이 어떻게 변할지 예측할 수 없다. 따라서, 이런 상황에서는 최적화가 어렵다.```javapackage lang.string.builder;public class LoopStringMain { public static void main(String[] args) {   long startTime = System.currentTimeMillis();   String result = "";   for (int i = 0; i < 100000; i++) {     result += "Hello Java ";   }   long endTime = System.currentTimeMillis();   System.out.println("result = " + result);   System.out.println("time = " + (endTime - startTime) + "ms"); }}```- `StringBuilder`를 이용하여 최적화를 직접 해주면 된다(time = 3ms)```javapackage lang.string.builder;public class LoopStringBuilderMain {    public static void main(String[] args) {        long startTime = System.currentTimeMillis();        StringBuilder sb = new StringBuilder();        for (int i = 0; i < 100000; i++) {            sb.append("Hello Java ");        }        String result = sb.toString();        long endTime = System.currentTimeMillis();        System.out.println("result = " + result);        System.out.println("time = " + (endTime - startTime) + "ms");    }}```## ⚡️ StringBuilder를 직접 사용하는 경우- **반복문에서 반복해서 문자를 연결**  - 10번, 100번 정도는 String 을 사용해도 되지만, 1000번, 10000번 이상이면 StringBuilder를 사용하는 것이 좋다- **조건문을 통해 동적으로 문자를 조합**- **복잡한 문자열의 특정 부분을 변경**- **매우 긴 대용량 문자열인 경우**## ⚡️ StringBuilder vs StringBuffer- StringBuilder와 StringBuffer는 똑같은 기능을 수행한다- StringBuilder(빠른 속도, 동기화 오버헤드 X) vs StringBuffer(멀티쓰레드 안전, 내부 동기화 O, 동기화 오버헤드로 인해 성능이 느리다.)- 굉장히 특수한 경우(멀티쓰레드를 써야하는)에만 StringBuffer를 쓴다고 생각하면 됨<br/><br/><br/># 💡 String - 메서드 체이닝- 메서드 체이닝 : 마치 체인 처럼 반환된 참조값을 사용해서 메서드 호출을 계속 이어가는 방법- 자기 자신을 참조하고 반환 하는 방식을 사용하는 이유는 `가독성`, `간결함`을 위해서!  ![image](https://github.com/ngngs/TIL/assets/47618270/5e2d0100-2e18-4b57-9198-c56334ca999a)```javaint result = adder.add(1).add(2).add(3).getValue();```## ⚡️ StringBuilder와 메서드 체인(Chain)- `StringBuilder` 는 메서드 체이닝 기법을 제공한다.- `StringBuilder` 의 `append()` 메서드를 보면 자기 자신의 참조값을 반환한다.- `StringBuilder` 에서 문자열을 변경하는 대부분의 메서드도 메서드 체이닝 기법을 제공하기 위해 자기 자신을 반환 한다.- 참고로 자바의 라이브러리와 오픈 소스들은 메서드 체이닝 방식을 종종 사용한다.```javapublic StringBuilder append(String str) {    super.append(str);    return this;}```**"만드는 사람이 수고로우면 쓰는 사람이 편하고, 만드는 사람이 편하면 쓰는 사람이 수고롭다"** 는 말이 있다.