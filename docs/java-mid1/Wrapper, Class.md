# 4. Wrapper, Class## ⚡️ 기본형의 한계- 자바는 객체 지향 언어- int, double 같은 기본형(Primitive Type)은 객체가 아니기 때문에 한계가 있다.- 객체가 아니기 때문에 메서드를 제공할 수 없고, `null` 값을 가질 수 없다.- 만약 객체라면, 객체 스스로 자신을 다른 값과 비교하는 등의 메서드를 만들 수 있다.## ⚡️ 직접 만든 Wrapper 클래스- int 를 클래스로 만들어보자- 특정 기본형을 감싸서(Wrap) 만드는 클래스를 `Wrapper` 클래스 라고 한다- compareTo() 메서드를 내부로 캡슐화```javapublic class MyInteger{    private final int value;    public MyInteger(int value) {        this.value = value;    }    public int getValue() {        return value;    }    public int compareTo(int target){        if (value < target){            return -1;        } else if (value > target){            return 1;        } else {            return 0;        }    }}```## ⚡️ 기본형과 null- 기본형은 항상 값을 갖지만, 때로는 데이터 `없음`을 표현해야 한다.- findValue() 는 배열에 찾는 값이 있으면 해당 값을 반환하고, 없으면 -1을 반환한다.- 결과로 int를 반환하는데 int와 같은 기본형은 항상 값이 있어야 한다.- 여기서도 값을 반환할 때 값을 찾지 못하면 숫자를 반환 시켜야하고 보통 -1 또는 0을 사용한다.```java public class MyIntegerNullMain0 {    public static void main(String[] args) {        int[] intArr = {-1, 0, 1, 2, 3};        System.out.println(findValue(intArr, -1));        System.out.println(findValue(intArr, 0));        System.out.println(findValue(intArr, 1));        System.out.println(findValue(intArr, 100)); // -1    }    private static int findValue(int[] intArr, int target) {        for (int value : intArr) {            if (value == target) {                return value;            }        }        return -1;    }}```- -1을 찾더라도 -1이 출력되고, 값이 없어도 -1이 출력되는 문제가 있다.- 이를 해결하기 위해, findValue() 를 수정해서 **값이 없을 경우** `null` 을 반환하도록 했다.- 객체의 경우 데이터가 없다는 `null` 이라는 **명확한 값이 존재**한다.- `null`을 반환할 때는 `NullPointerException` 을 조심해야한다.- 기본형이 값을 무조건 갖는 건 좋은 제약일 수 있지만, 필요에 따라 값이 없다는 걸 표현할 필요가 있다.```javaprivate static MyInteger findValue(MyInteger[] intArr, int target){    for(MyInteger myInteger : intArr){        if(myInteger.getValue() == target){            return myInteger;        }    }    return null;}```## ⚡️ 자바 Wrapper 클래스- 자바는 기본형에 대응하는 래퍼 클래스를 기본적으로 제공한다.- 래퍼 클래스의 특징 :   - `불변`(불변 객체(Immutable Object))  - `equals`로 비교해야 한다.    - Wrapper 클래스는 객체이기 때문에 `==` 비교를 하면 인스턴스의 참조값을 비교한다.  - Wrapper 클래스는 객체를 그대로 출력해도 내부에 있는 값을 문자로 출력하도록 `toString()` 을 재정의했다.```javaInteger newInteger = new Integer(10);Integer integerObj = Integer.valueOf(10); // -128 ~ 127은 자바가 미리 만들어놓은 걸 재사용하기 때문에 훨씬 효율적(마치 StringPool)System.out.println(newInteger); // newInteger도 객체로 toString()을 Override하고 있기 때문에 출력됨int intValue = integerObj.intValue(); // 원하는 값을 꺼낼 수 있음// equals를 사용해야 하는 이유System.out.println(newInteger == integerObj); // false(주소가 다르기 때문)System.out.println(newInteger.equals(integerObj)); // true(내부 값으로 비교함)```- `박싱(Boxing)`: 기본형을 래퍼 클래스로 변경하는 것, `new Integer(10)`, `Integer.valueOf(10)`- `언박싱(Unboxing)`: Wrapper 클래스에 들어있는 기본형 값을 꺼내는 것, `xxxValue()`- `Integer.valueOf()` 에는 성능 최적화 기능이 있다.   - 개발자들이 일반적으로 자주 사용하는 `-128 ~ 127` 범위의 `Integer` 클래스를 미리 생성해준다.   - 해당 범위의 값을 조회하면 미리 생성된 `Integer` 객체를 반 환한다. 해당 범위의 값이 없으면 `new Integer()` 를 호출한다.   - **마치 문자열 풀과 비슷하게 자주 사용하는 숫자를 미리 생성해두고 재사용한다.**   - **참고로 이런 최적화 방식은 미래에 더 나은 방식으로 변경될 수 있다.**## ⚡️ 오토 박싱(Auto-Boxing), 오토 언박싱(Auto-Unboxing)- 기본형과 래퍼 클래스간의 박싱/언박싱이 번거로워 오토 박싱/언박싱을 지원한다.- 컴파일러가 개발자 대신 valueOf(), xxxValue() 등 코드를 추가해주는 기능```javaint value = 11;Integer boxedValue = value; // 오토 박싱(Auto-boxing)int unboxedValue = boxedValue; // 오토 언박싱(Auto-Unboxing)```## ⚡️ Wrapper 클래스와 성능- 기본형을 제공하는 이유는 뭘까? -> 성능이 3배 ~ 5배 차이가 난다.- 기본형은 메모리에서 단순히 그 크기만큼의 공간을 차지한다. 예를 들어 `int`는 4바이트 메모리만 차지한다.- 래퍼 클래스의 인스턴스는 내부에 필드로 가지고 있는 기본형의 값 뿐만 아니라 자바에서 객체 자체를 다루는데 필요한 객체 메타데이터를 포함하므로 더 많은 메모리를 사용한다. 자바 버전과 시스템마다 다르지만 `대략 8~16 바이트의 메모리`를 **추가로 사용한다.**- **기본형이든 래퍼 클래스든 이것을 1회로 환산하면 둘다 매우 빠르게 연산이 수행된다.**   - 0.3초 나누기 10억, 1.5초 나누기 10억이다.   - **일반적인 애플리케이션을 만드는 관점에서 보면 `이런 부분을 최적화해도 사막의 모래알 하나 정도의 차이`가 날 뿐 이다.**- CPU 연산을 아주 많이 수행하는 특수한 경우나 수많은 횟수로 연속해서 연산을 수행해야하는 경우라면 `기본형`을 사용하자```javapublic class scratch{    public static void main(String[] args) {        int iterations = 1_000_000_000; // 반복횟수 10억        long startTime, endTime;        // 기본형 long        long sumPrimitive = 0;        startTime = System.currentTimeMillis();        for (int i = 0; i< iterations; i++){            sumPrimitive += i;        }        endTime = System.currentTimeMillis();        System.out.println(sumPrimitive);        System.out.println(endTime - startTime + "ms"); // 497ms        // 래퍼 클래스 Long        Long sumWrapper = 0L;        startTime = System.currentTimeMillis();        for (int i = 0; i< iterations; i++){            sumWrapper += i;        }        endTime = System.currentTimeMillis();        System.out.println(sumWrapper);        System.out.println(endTime - startTime + "ms"); // 486ms    }}``````sumPrimitive = 499999999500000000기본 자료형 long 실행 시간: 513mssumWrapper = 499999999500000000래퍼 클래스 Long 실행 시간: 1414ms```## ⚡️ 유지보수 VS 최적화- 유지보수가 좋은 코드를 우선으로- 연산을 몇 번 줄인다고 해도 큰 도움 안된다- 성능최적화는 단순함보다 복잡함을 요구한다- 최적화가 정말 최적화일까? 애플리케이션 성능 관점에서 불필요한 최적화일 수 있다- 자바로 짤 바에 어셈블리로 짤 거 아니면..- **웹 어플리케이션의 경우, 메모리 안에서 발생하는 연산보다 네트워크 호출 한 번이 많게는 수삽만배 더 오래 걸린다**- **네트워크 호출을 한 번이라도 더 줄이도록 해보자**- 권장 방법 : 개발 이후 성능테스트, 부하테스트를 하고 정말 문제가 되는 부분을 찾아서 최적화하자## ⚡️ DB 결과값을 Integer로 받기 vs int로 받기- query 결과값이 null 일 경우, Integer로 받아야 `NullPointerException` 가 발생하지 않는다.- int의 경우 무조건 `NullPointerException` 가 발생한다- 그러나 Integer의 경우 null값임에도 intValue()로 사용하려하면 `NullPointerException` 가 발생한다.<br/><br/><br/># 💡 Class 클래스- `Class` 클래스는 클래스의 정보를 다룬다.1. `타입 정보 얻기` : 클래스 이름, 슈퍼클래스, 인터페이스 등과 같은 정보 조회2. `리플렉션(Reflection API)` : 클래스에 정의된 메소드, 필드, 생성자를 조회하고 이들을 통해 객체 인스턴스를 생성하거나 메서드를 호출하는 등의 작업 3. `동적 로딩과 생성` : `Class.forName()` 메서드를 사용해서 **클래스를 동적으로 로드**하고, `newInstance()` 메서드를 통해 새로운 인스턴스를 생성 4. `애노테이션 처리` : 클래스에 적용된 애노테이션을 조회하고 처리```javapublic class ClassMetaMain {    public static void main(String[] args) {        //Class 조회        Class clazz = String.class; // 1.클래스에서 조회        //Class clazz = new String().getClass();// 2.인스턴스에서 조회        //Class clazz = Class.forName("java.lang.String"); // 3.문자열로 조회        // 모든 필드 출력        Field[] fields = clazz.getDeclaredFields();        for (Field field : fields) {            System.out.println("Field: " + field.getType() + " " + field.getName());        }        // 모든 메서드 출력        Method[] methods = clazz.getDeclaredMethods();        for (Method method : methods) {            System.out.println("Method: " + method);        }        // 상위 클래스 정보 출력        System.out.println("Superclass: " + clazz.getSuperclass().getName());        // 인터페이스 정보 출력        Class[] interfaces = clazz.getInterfaces();        for (Class i : interfaces) {            System.out.println("Interface: " + i.getName());        }    }}```## ⚡️ Reflection API> **`Class` 를 사용하면 메타 정보를 기반으로 클래스에 정의된 메소드, 필드, 생성자 등을 조회하고, 객체 인스턴스를 생성하거나 메소드를 호출하는 작업**을 `리플렉션`이라고 한다.- 애노테이션 정보를 읽어서 특별한 기능을 수행할 수 도 있다. 최신 프레임워크들은 이런 기능을 적극 활용한다.<br/><br/><br/># 💡 System 클래스```javapublic class SystemMain {    public static void main(String[] args) {        System.out.println("getenv= " + System.getenv()); // 환경 변수 읽기, 운영체제가 사용하는 것        System.out.println("properties = " + System.getProperties()); // 자바 시스템 속성, 자바가 사용하는 것        // 배열 고속 복사는 자바가 하는게 아닌 하드웨어에 넘겨서 빠르게 처리하는 방법        // 운영체제나 시스템 레벨에서 배열을 통쨰로 읽어들여서 복사하는 방법이다.        char[] originalArray = new char[]{'h', 'e', 'l', 'l', 'o'};         char[] copiedArray = new char[5];         System.arraycopy(originalArray, 0, copiedArray, 0, originalArray.length);        // 배열 출력        System.out.println("copiedArray = " + copiedArray);        System.out.println("Arrays.toString = " + Arrays.toString(copiedArray));    }}```- **환경 변수**: `System.getenv()` 메서드를 사용하여 OS에서 설정한 환경 변수의 값을 얻을 수 있다. - **시스템 속성**: `System.getProperties()` 를 사용해 현재 시스템 속성을 얻거나`System.getProperty(String key)` 로 특정 속성을 얻을 수 있다. 시스템 속성은 자바에서 사용하는 설정 값이다.- **배열 고속 복사**: `System.arraycopy` 는 시스템 레벨에서 최적화된 메모리 복사 연산을 사용한다. 직접 반복문 을 사용해서 배열을 복사할 때 보다 수 배 이상 빠른 성능을 제공한다.<br/><br/><br/># 💡 Random 클래스와 Seed랜덤의 경우 `Math.random()` 을 사용해도 되지만 `Random` 클래스를 사용하면 더욱 다양한 랜덤값을 구할 수 있다.- `Math.random()` 도 내부에서는 `Random` 클래스를 사용한다. - `Random` 클래스는 `java.util` 패키지 소속이다.```javapublic class RandomMain {    public static void main(String[] args) {        Random random = new Random();        //Random random = new Random(1); //seed가 같으면 Random의 결과가 같다.        int randomInt = random.nextInt();        System.out.println("randomInt: " + randomInt);        double randomDouble = random.nextDouble(); //0.0d ~ 1.0d        System.out.println("randomDouble: " + randomDouble);        boolean randomBoolean = random.nextBoolean();        System.out.println("randomBoolean: " + randomBoolean);        // 범위 조회        int randomRange1 = random.nextInt(10); //0 ~ 9까지 출력         System.out.println("0 ~ 9: " + randomRange1);         int randomRange2 = random.nextInt(10) + 1; //1 ~ 10까지 출력        System.out.println("1 ~ 10: " + randomRange2);    }}```- `random.nextInt()` : 랜덤 `int` 값을 반환한다.- `nextDouble()` : `0.0d` ~ `1.0d` 사이의 랜덤 `double` 값을 반환한다.- `nextBoolean()` : 랜덤 `boolean` 값을 반환한다.- `nextInt(int bound)` : `0` ~ `bound` 미만의 숫자를 랜덤으로 반환한다. 예를 들어서 3을 입력하면 `0, 1, 2` 를 반환한다.## ⚡️ Seed랜덤은 내부에서 씨드(Seed)값을 사용해서 랜덤 값을 구한다. 그런데 **이 Seed 값이 같으면 항상 같은 결과가 출력된다.**```java//Random random = new Random();Random random = new Random(1); //seed가 같으면 Random의 결과가 같다.```- `new Random()` : 생성자를 비워두면 내부에서 `System.nanoTime()` 에 여러가지 복잡한 알고리즘을 섞어서 Seed값을 생성한다. 따라서 반복 실행해도 결과가 항상 달라진다.- `new Random(int seed)` : 생성자에 Seed 값을 직접 전달할 수 있다. Seed 값이 같으면 여러번 반복 실행해도 실행 결과가 같다. **이렇게 Seed 값을 직접 사용하면 결과 값이 항상 같기 때문에 결과가 달라지는 랜덤 값을 구할 수 없다.**   - 하지만 결과가 고정되기 때문에 **`테스트 코드` 같은 곳에서 같은 결과를 검증할 수 있다.**   - 참고로 마인크래프트 같은 게임은 게임을 시작할 때 지형을 랜덤으로 생성하는데, 같은 Seed값을 설정하면 같은 지형을 생성할 수 있다.