# 열거형 - ENUM# 💡 문자열과 타입 안전성- 열거형(Enum Type)을 이해하려면, 왜 열거형이 등장했는지 알아야한다- 비즈니스 요구사항에 따라 고객을 3등급으로 나누고 상품 구매시 등급별로 할인을 적용한다고 해보자```java public class DiscountService {    public int discount(String grade, int price) {        int discountPercent = 0;        if (grade.equals("BASIC")) {            discountPercent = 10;        } else if (grade.equals("GOLD")) {            discountPercent = 20;        } else if (grade.equals("DIAMOND")) {            discountPercent = 30;        } else {            System.out.println(grade + ": 할인X");        }        return price * discountPercent / 100;    }}```## ⚡️ 위 코드의 문제점 - String 사용시 타입 안정성 부족 문제 발생1. `타입 안전성 부족` : 단순히 문자열을 입력하는 방식은 `오타`가 발생, 유효하지 않는 값이 입력될 수 있음(소문자 등)2. `값의 제한 부족` : "GOLD", "gold" 등 입력 될 수 있음> -> **컴파일 시 오류를 감지 불가**(`String`은 어떤 문자열이든 받기 때문에 문제를 해결할 수 없다)## ⚡️ 문자열 상수를 이용```java public class StringGrade {     public static final String BASIC = "BASIC";     public static final String GOLD = "GOLD";     public static final String DIAMOND = "DIAMOND";}public class DiscountService {    public int discount(String grade, int price) {        int discountPercent = 0;        if (grade.equals(StringGrade.BASIC)) {            discountPercent = 10;        } else if (grade.equals(StringGrade.GOLD)) {            discountPercent = 20;        } else if (grade.equals(StringGrade.DIAMOND)) {            discountPercent = 30;        } else {            System.out.println(grade + ": 할인X");        }        return price * discountPercent / 100;    }}```> 이렇게 `문자열 상수`를 사용해도 여전히 String 을 사용하고 있기 때문에 `타입 안전성 부족 문제`, `컴파일 시 오류 감지 불가 문제` 는 보장되지 않는다.<br/><br/><br/># 💡**타입 안전 열거형 패턴 - Type-Safe Enum Pattern**<img width="500" alt="스크린샷 2024-07-30 오전 3 19 29" src="https://github.com/user-attachments/assets/4572ac52-866a-47f6-9d4d-03bc295626d4">```javapublic class ClassGrade {     public static final ClassGrade BASIC = new ClassGrade();     public static final ClassGrade GOLD = new ClassGrade();     public static final ClassGrade DIAMOND = new ClassGrade();          private ClassGrade() {}}public class DiscountService {  public int discount(ClassGrade classGrade, int price) {    int discountPercent = 0;    if (classGrade == ClassGrade.BASIC) {      discountPercent = 10;    } else if (classGrade == ClassGrade.GOLD) {      discountPercent = 20;    } else if (classGrade == ClassGrade.DIAMOND) {      discountPercent = 30;    } else { System.out.println("할인X");    }    return price * discountPercent / 100;  }}``````javapublic class ClassRefMain {    public static void main(String[] args) {        System.out.println("class BASIC = " + ClassGrade.BASIC.getClass());        System.out.println("class GOLD = " + ClassGrade.GOLD.getClass());        System.out.println("class DIAMOND = " + ClassGrade.DIAMOND.getClass());        System.out.println("ref BASIC = " + ClassGrade.BASIC);        System.out.println("ref GOLD = " + ClassGrade.GOLD);        System.out.println("ref DIAMOND = " + ClassGrade.DIAMOND);    }}``````class BASIC = class enumeration.ex2.ClassGradeclass GOLD = class enumeration.ex2.ClassGradeclass DIAMOND = class enumeration.ex2.ClassGraderef BASIC = enumeration.ex2.ClassGrade@7344699fref GOLD = enumeration.ex2.ClassGrade@6b95977ref DIAMOND = enumeration.ex2.ClassGrade@7e9e5f8a```- 각각의 상수마다 별도의 인스턴스를 생성하고, 생성한 인스턴스를 대입한다. - 각각을 상수로 선언하기 위해 `static` , `final` 을 사용한다.  - `static` 을 사용해서 상수를 메서드 영역에 선언한다.   - `final` 을 사용해서 인스턴스(참조값)를 변경할 수 없게 한다.- 매개변수에 넘어오는 인수도 `ClassGrade` 가 가진 상수 중에 하나를 사용한다. 따라서 열거한 상수의 참조값으로 비교( `==` )하면 된다.- `private` 생성자를 사용해서 외부에서 `ClassGrade` 를 임의로 생성하지 못하게 막았다.- 각각의 상수는 모두 `ClassGrade` 타입을 기반으로 인스턴스를 만들었기 때문에 `getClass()` 의 결과는 모두 `ClassGrade` 이다. - 각각의 상수는 모두 서로 각각 다른 `ClassGrade` 인스턴스를 참조하기 때문에 참조값이 다르게 출력된다.> `제한된 인스턴스 생성`: **사전에 정의된 인스턴스들만 사용할 수 있도록 하여, 미리 정의된 값들만 사용하도록 보장한다.**> > `타입 안전성`: **정해진 값들만 사용하도록 강제함으로써, 잘못된 값이 입력되는 것을 방지한다.**<br/><br/><br/># 💡 열거형 - Enum Type- enum은 enumeration의 줄임말로, `열거`라는 뜻이다- 일련의 명명된 상수들의 집합을 정의한 것```javapublic enum Grade {  BASIC, GOLD, DIAMOND} ``````javapublic class Grade extends Enum {  public static final Grade BASIC = new Grade();  public static final Grade GOLD = new Grade();  public static final Grade DIAMOND = new Grade();  //private 생성자 추가  private Grade() {}}```- 열거형도 클래스이다.- 열거형은 자동으로 `java.lang.Enum` 을 상속 받는다. - 외부에서 임의로 생성할 수 없다.## ⚡️ 열거형의 장점- `타입 안전성 향상` : **열거형은 사전에 정의된 상수들로만 구성(유효하지 않은 값이 입력될 수 없고, 되더라도 컴파일 오류)**- `간결성 및 일관성`- `확장성` : **새로운 회원 추가하고 싶으면 ENUM 상수만 추가해주면 된다.**## ⚡️ Enum 주요 메서드- `values()` : 모든 ENUM 상수를 포함하는 배열을 반환- `valueOf(String name)` : 주어진 이름과 일치하는 ENUM 상수를 반환- `name()` : ENUM 상수의 이름을 문자열로 반환- `ordinal()` : ENUM 상수의 선언 순서(0부터)를 반환 * 가급적 사용하지 말자(중간에 상수를 선언하는 위치가 변경되면 전체 상수 위치가 변경되기 때문)- `toString()` : ENUM 상수의 이름을 문자열로 반환.## ⚡️ 정리- 열거형은 `java.lang.Enum` 를 자동(강제)으로 상속 받는다.- 열거형은 이미 `java.lang.Enum` 을 상속 받았기 때문에 **추가로 다른 클래스를 상속을 받을 수 없다.** - 열거형은 `인터페이스`를 구현할 수 있다.- 열거형에 `추상 메서드`를 선언하고, 구현할 수 있다.  - 이 경우 익명 클래스와 같은 방식을 사용한다.<br/><br/><br/># 💡 열거형의 활용```javapublic class ClassGrade {  public static final ClassGrade BASIC = new ClassGrade(10);  public static final ClassGrade GOLD = new ClassGrade(20);  public static final ClassGrade DIAMOND = new ClassGrade(30);  private final int discountPercent;    private ClassGrade(int discountPercent) {      this.discountPercent = discountPercent;  }  public int getDiscountPercent() {    return discountPercent;  }  //추가  public int discount(int price) {    return price * discountPercent / 100;  }}``````javapublic enum Grade {  BASIC(10), GOLD(20), DIAMOND(30);    private final int discountPercent;  Grade(int discountPercent) {    this.discountPercent = discountPercent;  }  public int getDiscountPercent() {    return discountPercent;  }  //추가  public int discount(int price) {    return price * discountPercent / 100;  }}```위의 `ClassGrade`, `Grade` 는 같은 기능을 하는 코드이다.- 객체지향 관점에서 이렇게 자신의 데이터를 외부에 노출하는 것 보다는,- **`Grade` 클래스가 자신의 할인율을 어떻게 계산하는지 스스로 관리하는 것이 `캡슐화 원칙`에 더 맞다.**