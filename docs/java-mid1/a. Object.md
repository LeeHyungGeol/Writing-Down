# 1. Object 클래스## ⚡️ java.lang 패키지 소개- `Object` : 모든 자바 객체 부모 클래스- `String`- `Integer`, `Long`, `Double` : 래퍼 타입- `Class` : 클래스 메타 정보- `System` : 시스템과 관련된 기본 기능## ⚡️ import 생략 가능- `java.lang` 패키지는 모든 자바 애플리케이션에 자동으로 임포트(`import`)된다```java    public static void main(String[] args) {        System.out.println("hello java"); // System은 임포트 안해도 작동한다    }```<br/><br/><br/># 💡 Object 클래스- 부모 클래스가 없으면 묵시적으로 `Object`클래스를 상속 받는다  ![image](https://github.com/ngngs/TIL/assets/47618270/cbede877-636b-409b-8b07-9c53b2d60dd1)## ⚡️ 자바에서 모든 클래스가 Object 클래스를 상속받게 만든 이유?> <u>`공통 기능 제공` : 모든 객체에게 필요한 **공통 기능**(equals(), toString()(객체 구성 확인) 등)을 제공</u>- 대표적으로, `toString()`, `equals()`, `getClass()` 등이 있다> <u>`다형성의 기본 구현` : 부모는 자식을 담는다. Object는 모든 클래스의 부모 클래스이므로 **모든 객체를 참조할 수 있다.**</u>- 다양한 타입의 객체를 통합적으로 처리할 수 있게 한다.<br/><br/><br/># 💡 Object 다형성- `Object`는 모든 타입의 부모. 부모는 자식을 담을 수 있다- 어떤 객체든지 인자로 전달할 수 있다## ⚡️ Object 다형성의 한계```javaaction(dog);  //main에서 dog 전달private static void action(Object obj){    obj.sound(); // 컴파일 오류 발생! Object는 sound()가 없다}```![image](https://github.com/ngngs/TIL/assets/47618270/cb08d5c1-322c-41ee-8d7e-a6cc2371538f)- Dog 인스턴스의 sound()를 호출하려면 `다운캐스팅`을 해야 한다```javaif (obj instance of Dog dog){    dog.sound();}```## ⚡️ Object 클래스의 활용: Object 배열```javaprivate static void size(Object[] objects) {    System.out.println("전달된 객체의 수는: " + objects.length);}```- `Object[] objects = {dog, car, object};` : Object는 자바에 존재하는 모든 객체를 담을 수 있는 배열을 만들 수 있다.<br/><br/><br/># 💡 Object.toString()- `Object.toString()` 메서드는 객체의 정보를 문자열 형태로 제공한다- 디버깅과 로깅에 사용한다- 이 메서드는 Object 클래스에 정의되므로 모든 클래스에서 상속받아 사용가능하다```javapublic static void main(String[] args){    Object object = new Object();    String string = object.toString();    //toString() 반환값 출력    System.out.println(string);    // java.lang.Object@b4c966a    //object 직접 출력    System.out.println(object);    // java.lang.Object@b4c966a}``````javapublic void println(Object x) {     String s = String.valueOf(x);     //...}``````javapublic static String valueOf(Object obj) {  return (obj == null) ? "null" : obj.toString();}```- `toString()`을 보면, 패키지를 포함한 객체의 이름과 객체의 참조값(해시코드)를 16진수로 제공한다- `System.out.println()`은 사실 내부적으로 `toString()`을 호출하기 때문- 결론 : 굳이 toString()을 사용하지 않고 object만 전달해도 출력이 된다!## ⚡️ toString()을 유용하게 사용하기- toString()은 클래스 정보와 참조값만 제공하기 때문에 객체의 정보를 더 알기 어렵다- 보통 오버라이딩을 해서 유용한 정보를 제공하게 한다.- getter and setter 처럼 toString()도 IDE(Intellij, Eclipse...) 가 만들어준다.```java@Overridepublic String toString() {  return "Dog{" +          "dogName='" + dogName + '\'' +          ", age=" + age +          '}';}```### 🔋 객체의 참조값 직접 출력- `toString()` 이나 `hashCode()` 를 재정의하면 객체의 참조값을 알 수 없는 상황이라면, 다음을 사용하면 된다```javaString refValue = Integer.toHexString(System.identityHashCode(dog1));System.out.println("refValue = " + refValue);```<br/># 💡 Object와 OCP## ⚡️ 구체적인 것에 의존- Object 는 구체적인 타입(Car, Dog)을 사용한다- 구체적인 클래스가 10개로 늘어나면 메서드도 10개로 늘어난다## ⚡️ 추상적인 것에 의존- ObjectPrinter 클래스는 Car, Dog와 같은 구체적인 클래스를 사용하지 않는다- 추상적인 `Object` 클래스를 사용하며, 이를 추상적인 것에 의존한다고 표현한다- 여기서, `추상`은 **조금 더 상위 개념**을 의미한다.- 모든 클래스의 부모 클래스인 Object 클래스는 다른 어떠한 클래스보다 상위 개념이자 추상적 개념이 되는 것이다.  ![image](https://github.com/ngngs/TIL/assets/47618270/2579e873-ba20-4487-918a-1cc813a2c504)> 무언가를 가지고 있다 아니다를 떠나서, 단순히 해당 코드를 사용하면 그게 바로 `의존하는` 것이다.<br/><br/>## ⚡️ ObjectPrinter.print() 와 Object 의 OCP```javapublic class ObjectPrinter {  public static void print(Object obj) {    String string = "객체 정보 출력: " + obj.toString();    System.out.println(string);  }}```> <u>`다형적 참조`: `ObjectPrinter.print()` 은 Object 타입을 매개변수로 활용하여 `다형적 참조` 를 사용한다.</u>> <u>`메서드 오버라이딩(@Override)`: 구체적인 다른 클래스를 구현하여, `toString()` 을 `@Override 메서드 오버라이딩` 하여, **추상적인 `Object` 타입에 의존하면서 런타임에 각 인스턴스의 `toString()` 을 호출할 수 있다.**</u>**OCP 원칙**- **Open**: 새로운 클래스를 추가하고, `toString()` 을 오버라이딩해서 기능을 확장할 수 있다. - **Closed**: 새로운 클래스를 추가해도 `Object` 와 `toString()` 을 사용하는 클라이언트 코드인`ObjectPrinter` 는 변경하지 않아도 된다.<br/>## ⚡️ 정적 의존관계 vs 동적 의존관계> `정적 의존관계`: **컴파일 시간에 결정되며, 주로 `클래스 간의 관계`를 의미한다.**   - 앞서 보여준 클래스 의존 관계 그림이 바로 정적 의존관계이다.   - 쉽게 이야기해서 프로그램을 실행하지 않고, 클래스 내에서 사용하는 타입들만 보면 쉽게 의존관계를 파악할 수 있다. > `동적 의존관계`: **프로그램을 실행하는 `런타임`에 확인할 수 있는 의존관계이다.**   - 앞서 `ObjectPrinter.print(Object obj)` 에 인자로 어떤 객체가 전달 될 지는 프로그램을 실행해봐야 알 수 있다.   - 어떤 경우에는 `Car` 인스턴스가 넘어오고, 어떤 경우에는 `Dog` 인스턴스가 넘어온다.   - 이렇게 런타임에 어떤 인스턴스를 사용하는지를 나타내는 것이 동적 의존관계이다.참고로 단순히 의존관계 또는 어디에 의존한다고 하면 **주로 정적 의존관계**를 뜻한다.   예) `ObjectPrinter` 는 `Object` 에 의존한다.### 🔋 System.out.println() - `System.out.println()` 메서드도 Object 매개변수를 사용하고 내부에서 toString()을 호출한다.- 따라서 `System.out.println()` 을 사용하면, 세상의 모든 객체의 정보를 편리하게 출력할 수 있다.- **자바 언어는 객체지향 언어 답게 언어 스스로도 객체지향의 특징을 매우 잘 활용한다.**<br/><br/><br/># 💡 Object.equals() ## ⚡️ equals() - 동일성과 동등성> `동일성(Identity)` : `==` 연산자를 사용해서 두 객체의 참조가 동일한 객체를 가리키고 있는지 확인(**참조값이 같은지 확인**)>> `동등성(Equality)` : `equals()` 메서드를 사용하여 두 객체가 논리적으로 동등한지 확인```java// 물리적으로 다른 메모리에 있는 다른 객체지만, 논리적으로 같은 회원User a = new User("id-100"); // 참조 x001User b = new User("id-100"); // 참조 x002```- 따라서 동일성은 다르지만, 동등성은 같다.## ⚡️ 오브젝트가 기본으로 제공하는 equals()- 기본적으로 equals()는 `==`으로 `동일성 비교`를 제공한다- equals() 메서드를 재정의해야한다```javapublic boolean equals(Object obj) {    return (this == obj);}```## ⚡️ equals() - 오버라이딩으로 재정의- IntelliJ를 포함한 대부분의 IDE는 정확한 `equals()` 코드를 자동으로 만들어준다.- **equals() 메서드는 모든 클래스가 필요한 것이 아닌 개발 중에 비교가 꼭 필요한 클래스에만 `재정의` 해주면 된다.**- String은 `==`이 아닌 `equals`를 사용해야한다.```java//변경 - 정확한 equals 구현, IDE 자동 생성 @Overridepublic boolean equals(Object object) {  if (this == object) {    return true;  }  if (object == null || getClass() != object.getClass()) {    return false;  }  UserV1 userV1 = (UserV1) object;  return Objects.equals(id, userV1.id);}```## ⚡️ Object의 나머지 메서드- `clone()`: 객체를 복사할 때 사용한다. 잘 사용하지 않으므로 다루지 않는다.- `hashCode()`:  `equals()` 와 `hashCode()` 는 종종 함께 사용된다. - `getClass()`- `notify()`, `notifyAll()`, `wait()`: 멀티쓰레드용 메서드이다.