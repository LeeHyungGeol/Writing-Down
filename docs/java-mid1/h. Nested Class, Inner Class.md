# Nested Class, Inner Class# 💡 중첩 클래스(Nested Class), 내부 클래스(Inner Class) 란?> `중첩 클래스(Nested Class)`: **클래스 안에 클래스를 중첩해서 정의한 것**## ⚡️ 총 4가지 중첩 클래스<img width="500" alt="스크린샷 2024-08-06 오후 4 14 43" src="https://github.com/user-attachments/assets/2ff288d3-b024-4d72-8074-aefa76104fea">- `정적 중첩 클래스`- 내부 클래스 종류  - `내부 클래스`   - `지역 클래스`  - `익명 클래스`- 중첩 클래스를 정의하는 위치는 변수의 선언 위치와 같다- 정적 중첩 클래스는 정적 변수(클래스 변수)와 같은 위치- 내부 클래스는 인스턴스 변수와 같은 위치- 지역 클래스는 지역 변수와 같은 위치```javaclass Outer {    // 정적 중첩 클래스    static class StaticNested { }    // 내부 클래스    class Inner {...}    public void process() {        // 지역 변수        int localVar = 0;        // 지역 클래스        class Local {...}        Local local = new Local();                // 익명 클래스        Anonymous anonymous = new Anonymous() {            @Override            public void method() {                System.out.println("익명 클래스");            }        };    }}```- `정적 중첩 클래스`는 정적 변수와 같이 앞에 `static이 붙어있다`- `내부 클래스`는 인스턴스 변수와 같이 앞에 `static이 붙지 않는다`- `지역 클래스`는 지역 변수와 같이 **코드 블럭 안**에서 클래스를 정의한다- `익명 클래스`는 **지역 클래스의 특별한 버전**이다### 🔋 중첩(Nested) vs 내부(Inner)> `중첩(Nested)` : 어떤 다른 것이 내부에 위치하거나 포함되는 구조적 관계, `나의 안에 있지만 내것이 아닌 것`  > `내부(Inner)` : 나의 내부에 있는 나를 구성하는 요소, `나의 안에 있는 나를 구성하는 요소`**중첩과 내부를 분류하는 핵심은 바깥 클래스 입장에서 안에 있는 클래스가 내 인스턴스에 소속이 되는가? 안되는가?**- `정적 중첩 클래스`는 바깥 클래스와 전혀 다른 클래스 -> 즉, **바깥 클래스의 인스턴스에 소속되지 않음**- `내부 클래스`는 바깥 클래스를 구성하는 요소 -> 따라서, **바깥 클래스 인스턴스에 소속**## ⚡️ 실무 용어**실무에서는 중첩, 내부라는 단어를 명확히 구분하지 않고, 중첩 클래스 또는 내부 클래스라고 이야기한다.**  엄밀하게 이야기하면 static 이 붙어있는 정적 중첩 클래스는 내부 클래스라고 하면 안된다.  하지만, 대부분의 개발자들이 둘을 구분해서 말하지 않기 때문에 상황과 문맥에 따라서 이해하면 된다.## ⚡️ 중첩 클래스는 언제 사용해야 하는가?- 내부 클래스를 포함한 모든 중첩 클래스는 특정 클래스가 `다른 하나의 클래스 안`에서만 사용되거나, `둘이 아주 긴밀하게 연결된 특별한 경우`- **외부 여러 클래스가 특정 중첩 클래스를 사용한다면 중첩 클래스로 만들면 안된다.**## ⚡️ 중첩 클래스를 사용하는 이유1.  `논리적 그룹화` : 특정 클래스가 다른 하나 클래스 안에서만 사용되는 경우, **해당 클래스 안에 포함하는 것이 논리적으로 그룹화 된다**     - 추가로, 패키지를 열었을 때 다른 곳에서 사용될 필요가 없는 중첩 클래스가 외부에 노출되지 않는 장점2. `캡슐화` : **중첩 클래스는 바깥 클래스의 `private` 멤버에 접근한다.** 이렇게 해서 둘은 긴밀하게 연결되고, **불필요한 `public` 메소드가 제거된다**<br/><br/><br/># 💡 정적 중첩 클래스(Static Nested Class)```javapublic class Outer {    private static int outClassValue = 3;    private int outInstanceValue = 2;    public void process() {        PrivateNested privateNested = new PrivateNested();        privateNested.print();    }    static class Nested {        private int nestedInstanceValue = 1;        public void print() {            System.out.println(nestedInstanceValue);            System.out.println(outClassValue);        }    }    private static class PrivateNested {        private int nestedInstanceValue = 1;        public void print() {            // 자신의 멤버에 접근            System.out.println(nestedInstanceValue);            // 바깥 클래스의 인스턴스 멤버에는 접근할 수 없다.            //System.out.println(outInstanceValue);            // 바깥 클래스의 클래스 멤버에는 접근할 수 있다. private도 접근 가능            System.out.println(NestedOuter.outClassValue);        }    }}public class Main {    public static void main(String[] args) {        Outer outer = new Outer();        Outer.Nested nested = new Outer.Nested();        nested.print();    }}```<img width="500" alt="스크린샷 2024-08-06 오후 5 13 21" src="https://github.com/user-attachments/assets/478d245e-1988-47bd-8833-9086fd0d2e32">- `정적` 중첩 클래스는 정적이다. 앞에 `static`이 붙는다!- 정적 중첩클래스는 **바깥 클래스**의 **인스턴스 멤버에는 접근할 수 없지만**, **클래스 멤버**에는 **접근할 수 있다**- 정적 중첩클래스는 다른 클래스를 그냥 중첩해둔 것 뿐이고, 둘이 아무런 관계가 없다.- 중첩 클래스도 바깥 클래스와 같은 클래스 안에 있다. 따라서 `중첩 클래스`는 **바깥 클래스의 `private` 접근 제어 자에 접근할 수 있다.**`PrivateNested` 의 접근 제어자를 `private` 로 설정해서 **외부에서 Nested 에 접근할 수 없게 했다.**- **`new Outer.Nested()` 처럼 접근할 수 없다.**<br/><br/><br/># 💡 내부 클래스(Inner Class)```java import InnerOuter.Inner;public class InnerOuter {    private static int outClassValue = 3;    private int outInstanceValue = 2;    class Inner {        private int innerInstanceValue = 1;        public void print() {            // 자신의 멤버에 접근             System.out.println(innerInstanceValue);            // 외부 클래스의 인스턴스 멤버에 접근 가능, private도 접근 가능             System.out.println(outInstanceValue);            // 외부 클래스의 클래스 멤버에는 접근 가능. private도 접근 가능             System.out.println(InnerOuter.outClassValue);        }    }}public class Main {    public static void main(String[] args) {        InnerOuter outer = new InnerOuter();        InnerOuter.Inner inner = outer.new Inner();        InnerOuter.Inner inner2 = new InnerOuter().new Inner();        inner2.print();    }}```<img width="500" alt="스크린샷 2024-08-06 오후 5 14 45" src="https://github.com/user-attachments/assets/f3a18b2c-6d44-442f-870c-9a997706f895">- `내부 클래스`는 앞에 `static`이 붙지 않는다. **인스턴스 멤버**가 된다.- 자신의 멤버에는 당연히 접근할 수 있다.- **바깥 클래스의 인스턴스 멤버에 접근할 수 있다.**- **바깥 클래스의 클래스 멤버에도 접근할 수 있다.**- 내부 클래스도 바깥 클래스와 같은 클래스 안에 있다. 내부 클래스는 바깥 클래스의 `private` 접근 제어 자에 접근할 수 있다.`new InnerOuter().new Inner();`- `내부 클래스`는 바깥 클래스의 인스턴스에 소속되어야 한다. 따라서 내부 클래스를 생성할 때, **바깥 클래스의 인스턴스 참조가 필요하다.**- 내부 클래스는 개념상 바깥 클래스의 인스턴스 내부에 생성된다. - **바깥 클래스의 인스턴스를 먼저 생성해야 내부 클래스의 인스턴스를 생성할 수 있다.**<br/><br/><br/># 💡 같은 이름의 바깥 변수 접근 - Shadowing```javapublic class ShadowingMain {    public int value = 1;    class Inner {        public int value = 2;        void go() {            int value = 3;            System.out.println("value = " + value);            System.out.println("this.value = " + this.value);            System.out.println("ShadowingMain.this.value = " + ShadowingMain.this.value);        }    }    public static void main(String[] args) {        ShadowingMain main = new ShadowingMain();        Inner inner = main.new Inner();        inner.go();    }}``````value = 3this.value = 2ShadowingMain.this.value = 1```변수의 이름이 같기 때문에 어떤 변수를 먼저 사용할지 우선순위가 필요하다.- 더 구체적인 것이 우선권을 가진다.- 사람이 직관적으 로 이해하기 쉬운 방향으로 우선순위를 설계한다.위의 예시의 go() 에서는 **지역 변수인 value** 가 가장 가까우므로 우선순위가 가장 높다.<br/><br/><br/># 💡 지역 클래스(Local Class)```javapublic class LocalOuterV1 {    private int outInstanceVar = 3;    public void process(int paramVar) {        int localVar = 1;        class LocalPrinter {            int value = 0;            public void printData() {                System.out.println("value=" + value);                System.out.println("localVar=" + localVar);                System.out.println("paramVar=" + paramVar);                System.out.println("outInstanceVar=" + outInstanceVar);            }        }        LocalPrinter printer = new LocalPrinter();        printer.printData();    }    public static void main(String[] args) {        LocalOuterV1 localOuter = new LocalOuterV1();        localOuter.process(2);    }}```- 지역 클래스는 내부 클래스의 한 종류이므로, 내부 클래스의 특징을 그대로 가진다.- 자신이 속한 코드 블럭의 지역 변수인 `localVar` 에 접근할 수 있다. - 자신이 속한 코드 블럭의 매개변수인 `paramVar` 에 접근할 수 있다.- **`지역 클래스`는 지역 변수 처럼 접근 제어자를 사용할 수 없다.**<br/><br/># 💡 지역 변수 캡쳐 (feat, 사실상 final(effectively final))<img width="500" alt="스크린샷 2024-08-06 오후 5 47 29" src="https://github.com/user-attachments/assets/c65f1952-ec47-4d44-a99e-98f36f7cd68c">> **지역 클래스는 지역 변수에 접근할 수 있다.**그러나, 지역 변수의 생명주기는 짧고, 지역 클래스를 통해 생성한 인스턴스의 생명 주기는 길다.  지역 클래스를 통해 생성한 인스턴스가 지역 변수에 접근해야 하는데, 둘의 생명 주기가 다르기 때문에 인스턴스는 살아 있지만, 지역 변수는 이미 제거된 상태일 수 있다.> **지역 클래스의 인스턴스를 생성하는 시점**에 필요한 지역 변수를 복사해서 **생성한 인스턴스에 함께 넣어둔다.** 이런 과정을 `변수 캡처(Capture)`라 한다.- 물론 모든 지역 변수를 캡처하는 것이 아니라 **접근이 필요한 `지역 변수만 캡처`한다.**```javapublic class LocalOuterV3 {    private int outInstanceVar = 3;    public Printer process(int paramVar) {        int localVar = 1; //지역 변수는 스택 프레임이 종료되는 순간 함께 제거된다.        class LocalPrinter implements Printer {            int value = 0;            @Override            public void print() {                System.out.println("value=" + value);                //인스턴스는 지역 변수보다 더 오래 살아남는다.                System.out.println("localVar=" + localVar);                System.out.println("paramVar=" + paramVar);                System.out.println("outInstanceVar=" + outInstanceVar);            }        }        Printer printer = new LocalPrinter();        //printer.print()를 여기서 실행하지 않고 Printer 인스턴스만 반환한다.        // 만약 localVar의 값을 변경한다면? 다시 캡처해야 하나?? //         localVar = 10; // 컴파일 오류//         paramVar = 20; // 컴파일 오류        return printer;    }    public static void main(String[] args) {        LocalOuterV3 localOuter = new LocalOuterV3();        Printer printer = localOuter.process(2);        //printer.print()를 나중에 실행한다. process()의 스택 프레임이 사라진 이후에 실행        printer.print();        System.out.println("필드 확인");        Field[] fields = printer.getClass().getDeclaredFields();        for (Field field : fields) {            System.out.println("field = " + field);        }    }}```**사용하는 지역 변수 복사**: **지역 클래스가 사용하는 지역 변수를 복사한다. (매개변수도 지역 변수의 한 종류이다)**- 여기서는 `paramVar` , `localVar` 지역 변수를 복사한다.- **인스턴스는 지역 변수의 생명주기와 무관하게 언제든지 `paramVar` , `localVar` 캡처 변수에 접근할 수 있다.**<br/><br/>## ⚡️ 사실상 final (effectively final)사실상 `final` 지역 변수는 지역 변수에 `final` 키워드를 사용하지는 않았지만, 값을 변경하지 않는 지역 변수를 뜻한다.  `final` 키워드를 넣지 않았을 뿐이지, 실제로는 `final` 키워드를 넣은 것 처럼 중간에 값을 변경하지 않은 지역 변수이다.> `지역 클래스가 접근하는 지역 변수`는 `final` 또는 사실상 `final` 이다!!!### 🔋 **캡처 변수의 값을 변경하지 못하는 이유 - 동기화 문제 발생** - 지역 변수의 값을 변경하면 인스턴스에 캡처한 변수의 값도 변경해야 한다.- 반대로 인스턴스에 있는 캡처 변수의 값을 변경하면 해당 지역 변수의 값도 다시 변경해야 한다.- 개발자 입장에서 보면 예상하지 못한 곳에서 값이 변경될 수 있다. 이는 디버깅을 어렵게 한다.- 지역 변수의 값과 인스턴스에 있는 캡처 변수의 값을 서로 동기화 해야 하는데, 멀티쓰레드 상황에서 이런 동기화 는 매우 어렵고, 성능에 나쁜 영향을 줄 수 있다.**자바는 캡처한 지역 변수의 값을 변하지 못하게 막아 서 이런 복잡한 문제들을 근본적으로 차단한다.**<br/><br/>## ⚡️ 정리> 지역 클래스는 `인스턴스를 생성할 때` 필요한 지역 변수를 `먼저 캡처해서 인스턴스에 보관한다.`> > 지역 클래스의 인스턴스를 통해 지역 변수에 접근하면, 실제로는 지역 변수에 접근하는 것이 아니라 **인스턴스에 있는 캡처한 `캡처 변수`에 접근한다.**> > `지역 클래스가 접근하는 지역 변수`는 `final` 또는 사실상 `final` 이다!!!<br/><br/><br/># 💡 익명클래스(Anonymous Class)> **익명 클래스는 이름이 없는 지역 클래스이다.****지역 클래스의 선언과 생성** ```java//선언class LocalPrinter implements Printer{//body}//생성Printer printer = new LocalPrinter();```- 익명 클래스를 사용하면 클래스의 이름을 생략하고, 클래스의 선언과 생성을 한번에 처리할 수 있다. **익명 클래스 - 지역 클래스의 선언과 생성을 한번에**```javaPrinter printer = new Printer() {    //body};``````java//익명 클래스 참조 바로 전달 public class Ex1RefMainV4 {    public static void hello(Process process) {        System.out.println("프로그램 시작");        //코드 조각 시작        process.run();        //코드 조각 종료        System.out.println("프로그램 종료");     }        public static void main(String[] args) {         hello(new Process() {             @Override             public void run() {                 int randomValue = new Random().nextInt(6) + 1;                 System.out.println("주사위 = " + randomValue);             }         });                  hello(new Process() {             @Override             public void run() {                 for (int i = 1; i <= 3; i++) {                     System.out.println("i = " + i);                 }             }         });    }}```## ⚡️ **익명 클래스 특징**- 익명 클래스는 이름 없는 지역 클래스를 선언하면서 동시에 생성한다.- **익명 클래스는 부모 클래스를 상속 받거나, 또는 인터페이스를 구현해야 한다.** 익명 클래스를 사용할 때는 상위 클래스나 인터페이스가 필요하다. - 익명 클래스는 말 그대로 이름이 없다. 이름을 가지지 않으므로, 생성자를 가질 수 없다. (기본 생성자만 사용됨) - 익명 클래스는 `AnonymousOuter$1` 과 같이 자바 내부에서 바깥 클래스 이름 + `$` + 숫자로 정의된다. 익명 클래스가 여러개면 `$1` , `$2` , `$3` 으로 숫자가 증가하면서 구분된다.> - 익명 클래스는 이름이 없는 지역 클래스이다.> - 특정 부모 클래스(인터페이스)를 상속 받고 바로 생성하는 경우 사용한다.> - 지역 클래스가 일회성으로 사용되는 경우나 간단한 구현을 제공할 때 사용해보자!!!<br/><br/><br/># 💡 람다(Lambda)```java//람다 사용public class Ex1RefMainV5 {    public static void hello(Process process) {        System.out.println("프로그램 시작");        //코드 조각 시작        process.run();        //코드 조각 종료        System.out.println("프로그램 종료");    }    public static void main(String[] args) {        hello(() -> {            int randomValue = new Random().nextInt(6) + 1;            System.out.println("주사위 = " + randomValue);        });        hello(() -> {            for (int i = 1; i <= 3; i++) {                System.out.println("i = " + i);            }        });    }}```- 자바8 이전까지 메서드에 인수로 전달하는 방법은 2가지였다- `int`, `double` 같은 기본형 타입- `Process` `Member`와 같은 참조형 타입(인스턴스)> 자바8 부터는 **메서드(더 정확히는 함수)를 인수로 전달**할 수 있게 되었다. 이것이 `Lambda`<br/><br/><br/>## ⚡️ 중첩, 내부 클래스의 선언 - static> **내부클래스의 경우 가급적 static 으로 선언하여 사용하는것이 좋습니다.**자바에서는 생성한 인스턴스가 필요없어질 경우 이를 주기적으로 삭제하게 되는데 이를 G.C(Garbage Collection)이라고 합니다.   내부클래스 사용은 쓸모없는 인스턴스를 G.C 대상에서 제외할 위험이 있습니다.이 외에도 메모리 크기를 더 차지하는 등의 문제가 있습니다.