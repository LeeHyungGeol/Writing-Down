# ì½”ë“œ ë‹¤ë“¬ê¸°

# ğŸ’¡ ì£¼ì„ì˜ ì–‘ë©´ì„±

## âš¡ï¸ ì£¼ì„ì€ ì£„ì•…ì´ë‹¤! vs ì£¼ì„ ì¢€ ë‚¨ê¸°ì!

> ì£¼ì„ì´ ë§ë‹¤ëŠ” ê²ƒì€ ê·¸ë§Œí¼ ë¹„ì¦ˆë‹ˆìŠ¤ ìš”êµ¬ì‚¬í•­ì„ ì½”ë“œì— ì˜ í‘œí˜„í•˜ì§€ ëª»í–ˆë‹¤.

> ì½”ë“œë¥¼ ì„¤ëª…í•˜ëŠ” ì£¼ì„ì„ ì“°ë©´, ì½”ë“œê°€ ì•„ë‹Œ ì£¼ì„ ì„¤ëª…ì— ì˜ì¡´í•˜ê²Œ ëœë‹¤.
- ì£¼ì„ì— ì˜ì¡´í•˜ì—¬ ì½”ë“œë¥¼ ì‘ì„±í•˜ë©´, ì ì ˆí•˜ì§€ ì•Šì€ ì¶”ìƒí™” ë ˆë²¨ì„ ê°–ê²Œ ë˜ì–´ ë‚®ì€ í’ˆì§ˆì˜ ì½”ë“œê°€ ë§Œë“¤ì–´ì§„ë‹¤.

## âš¡ï¸ ê·¸ëŸ¼ ì£¼ì„ì€ ì–¸ì œ ì“°ë‚˜?

## âš¡ï¸ ì¢‹ì€ ì£¼ì„

> í›„ëŒ€ì— ì „í•´ì•¼ í•  `ì˜ì‚¬ ê²°ì •ì˜ íˆìŠ¤í† ë¦¬` ì™œ ì´ëŸ° ì •ì±…ì„ ê°–ê²Œ ë˜ì—ˆê³ , ì™œ ì´ëŸ° íˆìŠ¤í† ë¦¬ë¥¼ ê°–ê²Œ ë˜ì—ˆëŠ”ì§€ë¥¼ ì½”ë“œë¡œ ì„¤ëª…í•  ìˆ˜ ì—†ì„ ë–„
> 
> **ì£¼ì„**ì„ ì‚¬ìš©í•œë‹¤.

```java
/**
 * ì´ ê°ì²´ê°€ ê°€ì§„ ì •ì±…ì€,
 * A ì •ì±…ê³¼ B ì •ì±…ì¤‘, AB í…ŒìŠ¤íŠ¸ì™€ ê¸°ìˆ  íšŒì˜ë¥¼ í†µí•´ ê²°ì •ëœ ì‚¬í•­ì„ ê¸°ë°˜ìœ¼ë¡œ ì„ íƒë˜ì–´ ì‘ì„±ëœ ê²ƒì´ë‹¤.
 * ê´€ë ¨ ë¬¸ì„œ: https://docs.google.com/document/d/1
 */
public class ImportantPolicy { }
```

- ì£¼ì„ì„ ì‘ì„±í•  ë•Œ, ìì£¼ ë³€í•˜ëŠ” ì •ë³´ëŠ” ìµœëŒ€í•œ ì§€ì–‘í•´ì„œ ì‘ì„±í•œë‹¤.
- ì£¼ì„ë„ ì½”ë“œì²˜ëŸ¼ ê°™ì´ ê´€ë¦¬í•´ì¤˜ì•¼ í•œë‹¤. ì§€ì†ì ì¸ ì—…ë°ì´íŠ¸ê°€ í•„ìš”í•˜ë‹¤.
- ì£¼ì„ì´ ì•„ì˜ˆ ì—†ëŠ” ê²ƒ ë³´ë‹¤, ë¶€ì •í™•í•œ ì •ë³´ë¥¼ ê°–ê³  ìˆëŠ” ì£¼ì„ì´ ë” ìµœì•…ì´ë‹¤.

> ğŸ’¡ **ë¨¼ì €, ìš°ë¦¬ê°€ ê°€ì§„ ëª¨ë“  í‘œí˜„ ë°©ë²•ì„ í†µí•´ ì½”ë“œë¥¼ í†µí•´ ì˜ë„ë“¤ì„ ì˜ ì‘ì„±í•˜ê³ , ê·¸ëŸ¼ì—ë„ ë¶ˆêµ¬íˆê³  ì½”ë“œì— ë…¹ì—¬ë‚´ì§€ ëª»í•˜ëŠ” ì •ë³´ê°€ ìˆë‹¤ë©´ ì£¼ì„ì„ ì‚¬ìš©í•˜ì!** 

ì•„ë˜ì˜ ì£¼ì„ì€ ê¼­ í•„ìš”í•œ ì£¼ì„ì¼ê¹Œ?

**AS-IS**

í•´ë‹¹ ì£¼ì„ì€ ê²Œì„ì˜ ìƒíƒœê°’ì„ int ë¡œ í‘œì‹œí•˜ê³  ìˆë‹¤. í•˜ì§€ë§Œ, ì´ê²ƒì„ Enum ìœ¼ë¡œ í‘œí˜„í•˜ë©´ ì£¼ì„ì„ ì‚¬ìš©í•˜ì§€ ì•Šê³ ë„ ì˜ë„ë¥¼ ë” ëª…í™•í•˜ê²Œ í‘œí˜„í•  ìˆ˜ ìˆë‹¤.

```java
private int gameStatus = 0; // 0: ê²Œì„ ì¤‘, 1: ìŠ¹ë¦¬, -1: íŒ¨ë°°
```

**TO-BE**

```java
public enum GameStatus {
	IN_PROGRESS("ì§„í–‰ ì¤‘"),
	WIN("ìŠ¹ë¦¬"),
	LOSE("íŒ¨ë°°")
	;

	private final String description;

	GameStatus(String description) {
		this.description = description;
	}
}
```

#### GameStatus ë¥¼ ë§Œë“¤ë©´ì„œ Minesweeper ì˜ ì—­í• ê³¼ GameBoard ì˜ ì—­í• ì„ ì¢€ ë” í™•ì‹¤í•˜ê²Œ ë¶„ë¦¬ì‹œì¼°ë‹¤.

- `GameBoard` ëŠ” ì‹¤ì œ ê²Œì„ ì§„í–‰ì— ëŒ€í•œ ê²ƒë“¤ì„ ëª¨ë‘ ë‹´ë‹¹í•œë‹¤.
  - ì‹¤ì œì ì¸ ì§€ë¢° ì°¾ê¸°ì˜ ë„ë©”ì¸ ë¡œì§ì„ ëª¨ë‘ ê´€ë¦¬í•œë‹¤.
- `MineSweeper` ëŠ” ì™¸ë¶€ ì„¸ê³„ì™€ì˜ ì ‘ì , ì»¨íŠ¸ë¡¤ëŸ¬ì˜ ì—­í• ì„ í•˜ëŠ” ê²ƒì´ë‹¤.
  - ê²Œì„ì„ ì‹¤í–‰í•˜ê³  ì—¬ëŸ¬ê°€ì§€ ì…/ì¶œë ¥ë“¤ì„ ì¤‘ê°„ì—ì„œ ë‹´ë‹¹í•˜ì—¬ ì „ë‹¬í•´ì¤€ë‹¤.

### MVC êµ¬ì¡°ì²˜ëŸ¼ ëŒì•„ê°€ëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆë‹¤.

---

# ğŸ’¡ ë³€ìˆ˜ì™€ ë©”ì„œë“œì˜ ë‚˜ì—´ ìˆœì„œ

## âš¡ï¸ ë³€ìˆ˜ì™€ ë©”ì„œë“œëŠ” ì–´ë–¤ ìˆœì„œëŒ€ë¡œ ë‚˜ì—´í•˜ëŠ” ê²ƒì´ ê°€ì¥ ì¢‹ì„ê¹Œ?

> **`ë³€ìˆ˜`ëŠ” ì‚¬ìš©í•˜ëŠ” ìˆœì„œëŒ€ë¡œ ë‚˜ì—´í•œë‹¤.**
- **ì¸ì§€ì  ê²½ì œì„±(ë‡Œ ë©”ëª¨ë¦¬)**
- ë³€ìˆ˜ê°€ ì‚¬ìš©í•˜ê¸° ê°€ê¹Œìš´ ìª½ì— ë°°ì¹˜í•´ì•¼ ëœë‹¤.

<img width="700" alt="" src="https://github.com/user-attachments/assets/5d1f1675-7be9-469d-b3aa-03ed05faa597">

#### âš›ï¸ ì •ë‹µì€ ì—†ì§€ë§Œ ê°ì²´ 2 ë°©ì‹ì„ ì„ í˜¸í•œë‹¤!

> ê°ì²´ ê°„ì˜ í˜‘ë ¥ ê´€ì ì—ì„œ ë°”ë¼ë³¼ ë•Œ, ê³µê°œ ë©”ì„œë“œ(public)ë¥¼ ë¨¼ì € ìœ„ì— ë°°ì¹˜í•˜ê³ , ê·¸ ë‹¤ìŒì— ë¹„ê³µê°œ ë©”ì„œë“œ(private)ë¥¼ ë‚˜ì—´í•œë‹¤.
- ë¬¼ë¡ , ì´ê²ƒì´ ì •ë‹µì€ ì•„ë‹ˆë‹¤.

> ê³µê°œ ë©”ì„œë“œ ë¼ë¦¬ë„ ê¸°ì¤€ì„ ê°€ì¹˜ê³  ë°°ì¹˜í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤!
- ë©”ì„œë“œê°€ ìˆ˜ì‹­ê°œì¸ ê°ì²´ì˜ ê²½ìš°, ë©”ì„œë“œë¥¼ ê¸°ì¤€ì„ ê°€ì§€ê³  ê·¸ë£¹í™”í•˜ì—¬ ë°°ì¹˜í•œë‹¤. ë˜‘ê°™ì€ ê¸°ëŠ¥ì„ ê°€ì§„ ë©”ì„œë“œì˜ ì¤‘ë³µ ìƒì„± ë°©ì§€ ë° ì¼ê´€ì„± ìˆëŠ” ë¡œì§ì„ ìœ ì§€í•  ìˆ˜ ìˆë‹¤.
- ***ìƒíƒœ ë³€ê²½ >> íŒë³„ >= ì¡°íšŒ ë©”ì„œë“œ***
  - ê°ì²´ì˜ ìƒíƒœë¥¼ ë³€ê²½í•˜ëŠ” ì‘ì—…ì€ ë§¤ìš° ì¤‘ìš”í•œ ì‘ì—…ì´ê¸° ë•Œë¬¸ì— ìƒë‹¨ì— ë°°ì¹˜í•  ìˆ˜ ìˆë„ë¡ í•œë‹¤.

> ë¹„ê³µê°œ(private) ë©”ì„œë“œëŠ”, ê³µê°œ(public) ë©”ì„œë“œì—ì„œ ì–¸ê¸‰ëœ ìˆœì„œëŒ€ë¡œ ë°°ì¹˜í•œë‹¤.
- ê³µê°œ ë©”ì„œë“œì™€ ë§ˆì°¬ê°€ì§€ë¡œ ìƒíƒœ ë³€ê²½ >> íŒë³„ >= ì¡°íšŒ ë©”ì„œë“œ ìˆœì„œë¡œ ë°°ì¹˜í•˜ë˜, ë©”ì„œë“œ ì•ˆì—ì„œ í•˜ìœ„ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ëŠ” ê²½ìš° í•´ë‹¹ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ëŠ” ë§¤ì„œë“œ ì•„ë˜ì— ë°°ì¹˜í•œë‹¤.
- `ê³µí†µìœ¼ë¡œ ì‚¬ìš©í•˜ëŠ” ë©”ì„œë“œ`ë¼ë©´, **(ê°€ì¥ í•˜ë‹¨ê³¼ ê°™ì€) ì ë‹¹í•œ ê³³ì— ë°°ì¹˜í•œë‹¤.**

### ğŸ”‹ ì¤‘ìš”í•œ ê²ƒì€, ë‚˜ì—´ ìˆœì„œë¡œë„ ì˜ë„ì™€ ì •ë³´ë¥¼ ì „ë‹¬í•  ìˆ˜ ìˆë‹¤ëŠ” ê²ƒ!

**AS-IS**

```java
public class Minesweeper implements GameInitializable, GameRunnable {
	private final GameBoard gameBoard;
	private final InputHandler inputHandler;
	private final OutputHandler outputHandler;

	public Minesweeper(GameConfig gameConfig) {
		gameBoard = new GameBoard(gameConfig.getGameLevel());
		this.inputHandler = gameConfig.getInputHandler();
		this.outputHandler = gameConfig.getOutputHandler();
	}

	@Override
	public void initialize() {
		gameBoard.initializeGame();
	}

	@Override
	public void run() {
		outputHandler.showGameStartComments();

		while (gameBoard.inInProgress()) {
			try {
				outputHandler.showBoard(gameBoard);

				CellPosition cellPosition = getCellInputFromUser();
				UserAction userActionInput = getUserActionInputFromUser();
				actOnCell(cellPosition, userActionInput);
			} catch (GameException e) {
				outputHandler.showExceptionMessage(e);
			} catch (Exception e) {
				outputHandler.showSimpleMessage("í”„ë¡œê·¸ë¨ì— ë¬¸ì œê°€ ìƒê²¼ìŠµë‹ˆë‹¤.");
			}
		}
		outputHandler.showBoard(gameBoard);

		if (gameBoard.isWinStatus()) {
			outputHandler.showGameWinningComment();
		}
		if (gameBoard.isLoseStatus()) {
			outputHandler.showGameLosingComment();
		}
	}

	private void actOnCell(CellPosition cellPosition, UserAction userActionInput) {
		if (doesUserChooseToPlantFlag(userActionInput)) {
			gameBoard.flagAt(cellPosition);
			return;
		}
		if (doesUserChooseToOpenCell(userActionInput)) {
			gameBoard.openAt(cellPosition);
			return;
		}
		throw new GameException("ì˜ëª»ëœ ë²ˆí˜¸ë¥¼ ì„ íƒí•˜ì…¨ìŠµë‹ˆë‹¤.");
	}

	private boolean doesUserChooseToOpenCell(UserAction userAction) {
		return userAction == UserAction.OPEN;
	}

	private boolean doesUserChooseToPlantFlag(UserAction userAction) {
		return userAction == UserAction.FLAG;
	}

	private UserAction getUserActionInputFromUser() {
		outputHandler.showCommentForUserAction();
		return inputHandler.getUserActionFromUser();
	}

	private CellPosition getCellInputFromUser() {
		outputHandler.showCommentForSelectingCell();
		CellPosition cellPosition = inputHandler.getCellPositionFromUser();
		if (gameBoard.isInvalidCellPosition(cellPosition)) {
			throw new GameException("ì˜ëª»ëœ ì¢Œí‘œë¥¼ ì„ íƒí•˜ì…¨ìŠµë‹ˆë‹¤.");
		}

		return cellPosition;
	}
}
```

**TO-BE**

```java
public class Minesweeper implements GameInitializable, GameRunnable {
	private final GameBoard gameBoard;
	private final InputHandler inputHandler;
	private final OutputHandler outputHandler;

	public Minesweeper(GameConfig gameConfig) {
		gameBoard = new GameBoard(gameConfig.getGameLevel());
		this.inputHandler = gameConfig.getInputHandler();
		this.outputHandler = gameConfig.getOutputHandler();
	}

	@Override
	public void initialize() {
		gameBoard.initializeGame();
	}

	@Override
	public void run() {
		outputHandler.showGameStartComments();

		while (gameBoard.inInProgress()) {
			try {
				outputHandler.showBoard(gameBoard);

				CellPosition cellPosition = getCellInputFromUser();
				UserAction userActionInput = getUserActionInputFromUser();
				actOnCell(cellPosition, userActionInput);
			} catch (GameException e) {
				outputHandler.showExceptionMessage(e);
			} catch (Exception e) {
				outputHandler.showSimpleMessage("í”„ë¡œê·¸ë¨ì— ë¬¸ì œê°€ ìƒê²¼ìŠµë‹ˆë‹¤.");
			}
		}
		outputHandler.showBoard(gameBoard);

		if (gameBoard.isWinStatus()) {
			outputHandler.showGameWinningComment();
		}
		if (gameBoard.isLoseStatus()) {
			outputHandler.showGameLosingComment();
		}
	}

	private CellPosition getCellInputFromUser() {
		outputHandler.showCommentForSelectingCell();
		CellPosition cellPosition = inputHandler.getCellPositionFromUser();
		if (gameBoard.isInvalidCellPosition(cellPosition)) {
			throw new GameException("ì˜ëª»ëœ ì¢Œí‘œë¥¼ ì„ íƒí•˜ì…¨ìŠµë‹ˆë‹¤.");
		}

		return cellPosition;
	}

	private UserAction getUserActionInputFromUser() {
		outputHandler.showCommentForUserAction();
		return inputHandler.getUserActionFromUser();
	}

	private void actOnCell(CellPosition cellPosition, UserAction userActionInput) {
		if (doesUserChooseToPlantFlag(userActionInput)) {
			gameBoard.flagAt(cellPosition);
			return;
		}
		if (doesUserChooseToOpenCell(userActionInput)) {
			gameBoard.openAt(cellPosition);
			return;
		}
		throw new GameException("ì˜ëª»ëœ ë²ˆí˜¸ë¥¼ ì„ íƒí•˜ì…¨ìŠµë‹ˆë‹¤.");
	}

	private boolean doesUserChooseToPlantFlag(UserAction userAction) {
		return userAction == UserAction.FLAG;
	}

	private boolean doesUserChooseToOpenCell(UserAction userAction) {
		return userAction == UserAction.OPEN;
	}
}
```

**AS-IS**

```java
public class GameBoard {

	private final Cell[][] board;
	private final int landMineCount;
	private GameStatus gameStatus;

	public GameBoard(GameLevel gameLevel) {
		int rowSize = gameLevel.getRowSize();
		int colSize = gameLevel.getColSize();
		board = new Cell[rowSize][colSize];

		landMineCount = gameLevel.getLandMineCount();
		initializeGameStatus();
	}

	public void initializeGame() {
		initializeGameStatus();
		CellPositions cellPositions = CellPositions.from(board);

		initializeEmptyCells(cellPositions);

		List<CellPosition> landMinePositions = cellPositions.extractRandomPositions(landMineCount);
		initializeLandMineCells(landMinePositions);

		List<CellPosition> numberPositionCandidates = cellPositions.subtract(landMinePositions);
		initializeNumberCells(numberPositionCandidates);
	}

	public void flagAt(CellPosition cellPosition) {
		Cell cell = findCell(cellPosition);
		cell.flag();

		checkIfGameIsOver();
	}

	private void checkIfGameIsOver() {
		if (isAllCellChecked()) {
			changeGameStatusToWin();
		}
	}

	private void changeGameStatusToWin() {
		gameStatus = GameStatus.WIN;
	}

	public void openAt(CellPosition cellPosition) {
		if (isLandMineCellAt(cellPosition)) {
			openOneCellAt(cellPosition);
			changeGameStatusToLose();
			return;
		}

		openSurroundedCells(cellPosition);
		checkIfGameIsOver();
	}

	public void openOneCellAt(CellPosition cellPosition) {
		Cell cell = findCell(cellPosition);
		cell.open();
	}

	public void openSurroundedCells(CellPosition cellPosition) {
		if (isOpenedCell(cellPosition)) {
			return;
		}
		if (isLandMineCellAt(cellPosition)) {
			return;
		}

		openOneCellAt(cellPosition);

		if (doesCellHaveLandMineCount(cellPosition)) {
			return;
		}

		List<CellPosition> surroundedPositions = calculateSurroundedPositions(cellPosition, getRowSize(), getColSize());
		surroundedPositions.forEach(this::openSurroundedCells);
	}

	private boolean doesCellHaveLandMineCount(CellPosition cellPosition) {
		Cell cell = findCell(cellPosition);
		return cell.hasLandMineCount();
	}

	private boolean isOpenedCell(CellPosition cellPosition) {
		Cell cell = findCell(cellPosition);
		return cell.isOpened();
	}

	public boolean isLandMineCellAt(CellPosition cellPosition) {
		Cell cell = findCell(cellPosition);
		return cell.isLandMine();
	}

	public boolean isAllCellChecked() {
		Cells cells = Cells.from(board);
		return cells.isAllChecked();
	}

	public boolean isInvalidCellPosition(CellPosition cellPosition) {
		int rowSize = getRowSize();
		int colSize = getColSize();

		return cellPosition.isRowIndexMoreThanOrEqual(rowSize)
			|| cellPosition.isColIndexMoreThanOrEqual(colSize);
	}

	public boolean inInProgress() {
		return gameStatus == GameStatus.IN_PROGRESS;
	}

	private void initializeGameStatus() {
		gameStatus = GameStatus.IN_PROGRESS;
	}

	private void changeGameStatusToLose() {
		gameStatus = GameStatus.LOSE;
	}

	private void initializeEmptyCells(CellPositions cellPositions) {
		List<CellPosition> allPositions = cellPositions.getPositions();
		for (CellPosition position : allPositions) {
			updateCellAt(position, new EmptyCell());
		}
	}

	private void initializeLandMineCells(List<CellPosition> landMinePositions) {
		for (CellPosition position : landMinePositions) {
			updateCellAt(position, new LandMineCell());
		}
	}

	private void initializeNumberCells(List<CellPosition> numberPositionCandidates) {
		for (CellPosition candidatePosition : numberPositionCandidates) {
			int count = countNearbyLandMines(candidatePosition);
			if (count != 0) {
				updateCellAt(candidatePosition, new NumberCell(count));
			}
		}
	}

	private void updateCellAt(CellPosition position, Cell cell) {
		board[position.getRowIndex()][position.getColIndex()] = cell;
	}

	public CellSnapshot getSnapshot(CellPosition cellPosition) {
		Cell cell = findCell(cellPosition);
		return cell.getSnapshot();
	}

	private Cell findCell(CellPosition cellPosition) {
		return board[cellPosition.getRowIndex()][cellPosition.getColIndex()];
	}

	public int getRowSize() {
		return board.length;
	}

	public int getColSize() {
		return board[0].length;
	}

	private int countNearbyLandMines(CellPosition cellPosition) {
		int rowSize = getRowSize();
		int colSize = getColSize();

		long count = calculateSurroundedPositions(cellPosition, rowSize, colSize).stream()
			.filter(this::isLandMineCellAt)
			.count();

		return (int) count;
	}

	private List<CellPosition> calculateSurroundedPositions(CellPosition cellPosition, int rowSize, int colSize) {
		return RelativePosition.SURROUNDED_POSITIONS.stream()
			.filter(cellPosition::canCalculatePositionBy)
			.map(cellPosition::calculatePositionBy)
			.filter(position -> position.isRowIndexLessThan(rowSize))
			.filter(position -> position.isColIndexLessThan(colSize))
			.toList();
	}

	public boolean isWinStatus() {
		return gameStatus == GameStatus.WIN;
	}

	public boolean isLoseStatus() {
		return gameStatus == GameStatus.LOSE;
	}
}
```

**TO-BE**

```java
public class GameBoard {

	private final Cell[][] board;
	private final int landMineCount;
	private GameStatus gameStatus;

	public GameBoard(GameLevel gameLevel) {
		int rowSize = gameLevel.getRowSize();
		int colSize = gameLevel.getColSize();
		board = new Cell[rowSize][colSize];

		landMineCount = gameLevel.getLandMineCount();
		initializeGameStatus();
	}

	// public
	// ìƒíƒœ ë³€ê²½
	public void initializeGame() {
		initializeGameStatus();
		CellPositions cellPositions = CellPositions.from(board);

		initializeEmptyCells(cellPositions);

		List<CellPosition> landMinePositions = cellPositions.extractRandomPositions(landMineCount);
		initializeLandMineCells(landMinePositions);

		List<CellPosition> numberPositionCandidates = cellPositions.subtract(landMinePositions);
		initializeNumberCells(numberPositionCandidates);
	}

	public void openAt(CellPosition cellPosition) {
		if (isLandMineCellAt(cellPosition)) {
			openOneCellAt(cellPosition);
			changeGameStatusToLose();
			return;
		}

		openSurroundedCells(cellPosition);
		checkIfGameIsOver();
	}

	public void flagAt(CellPosition cellPosition) {
		Cell cell = findCell(cellPosition);
		cell.flag();

		checkIfGameIsOver();
	}

	// íŒë³„
	public boolean isInvalidCellPosition(CellPosition cellPosition) {
		int rowSize = getRowSize();
		int colSize = getColSize();

		return cellPosition.isRowIndexMoreThanOrEqual(rowSize)
			|| cellPosition.isColIndexMoreThanOrEqual(colSize);
	}

	public boolean inInProgress() {
		return gameStatus == GameStatus.IN_PROGRESS;
	}


	// ì¡°íšŒ
	public CellSnapshot getSnapshot(CellPosition cellPosition) {
		Cell cell = findCell(cellPosition);
		return cell.getSnapshot();
	}

	public int getRowSize() {
		return board.length;
	}

	public int getColSize() {
		return board[0].length;
	}

	public boolean isWinStatus() {
		return gameStatus == GameStatus.WIN;
	}

	public boolean isLoseStatus() {
		return gameStatus == GameStatus.LOSE;
	}


	// private

	private void initializeGameStatus() {
		gameStatus = GameStatus.IN_PROGRESS;
	}

	private void initializeEmptyCells(CellPositions cellPositions) {
		List<CellPosition> allPositions = cellPositions.getPositions();
		for (CellPosition position : allPositions) {
			updateCellAt(position, new EmptyCell());
		}
	}

	private void initializeLandMineCells(List<CellPosition> landMinePositions) {
		for (CellPosition position : landMinePositions) {
			updateCellAt(position, new LandMineCell());
		}
	}

	private void initializeNumberCells(List<CellPosition> numberPositionCandidates) {
		for (CellPosition candidatePosition : numberPositionCandidates) {
			int count = countNearbyLandMines(candidatePosition);
			if (count != 0) {
				updateCellAt(candidatePosition, new NumberCell(count));
			}
		}
	}

	private int countNearbyLandMines(CellPosition cellPosition) {
		int rowSize = getRowSize();
		int colSize = getColSize();

		long count = calculateSurroundedPositions(cellPosition, rowSize, colSize).stream()
			.filter(this::isLandMineCellAt)
			.count();

		return (int) count;
	}

	private List<CellPosition> calculateSurroundedPositions(CellPosition cellPosition, int rowSize, int colSize) {
		return RelativePosition.SURROUNDED_POSITIONS.stream()
			.filter(cellPosition::canCalculatePositionBy)
			.map(cellPosition::calculatePositionBy)
			.filter(position -> position.isRowIndexLessThan(rowSize))
			.filter(position -> position.isColIndexLessThan(colSize))
			.toList();
	}

	private void updateCellAt(CellPosition position, Cell cell) {
		board[position.getRowIndex()][position.getColIndex()] = cell;
	}

	private void openSurroundedCells(CellPosition cellPosition) {
		if (isOpenedCell(cellPosition)) {
			return;
		}
		if (isLandMineCellAt(cellPosition)) {
			return;
		}

		openOneCellAt(cellPosition);

		if (doesCellHaveLandMineCount(cellPosition)) {
			return;
		}

		List<CellPosition> surroundedPositions = calculateSurroundedPositions(cellPosition, getRowSize(), getColSize());
		surroundedPositions.forEach(this::openSurroundedCells);
	}

	private void openOneCellAt(CellPosition cellPosition) {
		Cell cell = findCell(cellPosition);
		cell.open();
	}

	private boolean isOpenedCell(CellPosition cellPosition) {
		Cell cell = findCell(cellPosition);
		return cell.isOpened();
	}

	private boolean isLandMineCellAt(CellPosition cellPosition) {
		Cell cell = findCell(cellPosition);
		return cell.isLandMine();
	}

	private boolean doesCellHaveLandMineCount(CellPosition cellPosition) {
		Cell cell = findCell(cellPosition);
		return cell.hasLandMineCount();
	}

	private void checkIfGameIsOver() {
		if (isAllCellChecked()) {
			changeGameStatusToWin();
		}
	}

	private boolean isAllCellChecked() {
		Cells cells = Cells.from(board);
		return cells.isAllChecked();
	}

	private void changeGameStatusToWin() {
		gameStatus = GameStatus.WIN;
	}

	private void changeGameStatusToLose() {
		gameStatus = GameStatus.LOSE;
	}

	private Cell findCell(CellPosition cellPosition) {
		return board[cellPosition.getRowIndex()][cellPosition.getColIndex()];
	}
}
```

---

# ğŸ’¡ íŒ¨í‚¤ì§€ ë‚˜ëˆ„ê¸°

## âš¡ï¸ íŒ¨í‚¤ì§€ëŠ” `ë¬¸ë§¥`ìœ¼ë¡œì¨ì˜ ì •ë³´ë¥¼ ì œê³µí•  ìˆ˜ ìˆë‹¤!
- íŒ¨í‚¤ì§€ë¥¼ ìª¼ê°œì§€ ì•Šìœ¼ë©´ ê´€ë¦¬ê°€ ì–´ë ¤ì›Œì§„ë‹¤.
- íŒ¨í‚¤ì§€ë¥¼ ë„ˆë¬´ ì˜ê²Œ ìª¼ê°œë„ ê´€ë¦¬ê°€ ì–´ë ¤ì›Œì§„ë‹¤.

### ğŸ”‹ ëŒ€ê·œëª¨ íŒ¨í‚¤ì§€ ë³€ê²½ì€ íŒ€ì›ê³¼ì˜ í•©ì˜ë¥¼ ì´ë£¬ ì‹œì ì— í•˜ì.
- í˜„ì¬ ê¸°ì¤€ìœ¼ë¡œ ë³¸ì¸ë§Œ ë³€ê²½í•˜ê³  ìˆëŠ” ë¶€ë¶„ì´ë¼ë©´ ê´œì°®ìœ¼ë‚˜, ì—¬ëŸ¬ ì‚¬ëŒì´ í•¨ê»˜ ì‘ì—…í•˜ê³  ì‚¬ìš©í•˜ëŠ” í´ë˜ìŠ¤ë“¤ì˜ ê²½ìš°ì— í•©ì˜í•˜ì§€ ì•Šìœ¼ë©´ ì¶”í›„ì— conflict ê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤.
- ì²˜ìŒ ë§Œë“¤ ë•Œ ì˜ ê³ ë¯¼í•´ì„œ íŒ¨í‚¤ì§€ë¥¼ ë‚˜ëˆ ë†“ì.

**AS-IS**

<img width="450" alt="Image" src="https://github.com/user-attachments/assets/2a1de192-1836-4c9f-9778-e3a401e4e05f" />

**TO-BE**

<img width="400" alt="Image" src="https://github.com/user-attachments/assets/ed75ce2b-befa-4361-80ff-4bdfd1f38fd4" />

---

# ğŸ’¡ IDE ë„ì›€ ë°›ê¸°

## âš¡ï¸ ê²°êµ­ ì½ê¸° ì¢‹ì€ ì½”ë“œë€ ê°€ë…ì„±ì´ ì¢‹ì€ ì½”ë“œë‹¤! > IDE ì˜ ë„ì›€ì„ ë°›ì•„ë³´ì!

> `ì½”ë“œ í¬ë§· ì •ë ¬`: Mac > IntelliJ > `Option + Command + L`

> `ì½”ë“œ í’ˆì§ˆ`: `SonarCube`
- `lint`: ì ì¬ì ì¸ ë¬¸ì œê°€ ë  ìˆ˜ ì‡ëŠ” ì˜¤ë¥˜, ë²„ê·¸, ìŠ¤íƒ€ì¼ ë“±ì„ ë¯¸ë¦¬ ì•Œë ¤ì£¼ëŠ” ì½”ë“œ í’ˆì§ˆ ì²´í¬ ë„êµ¬(ex: ESLint, SonarLint, ktlint)

> `í¬ë§· ê·œì¹™`: `.editorconfig`

---

# ğŸ’¡ Minesweeperì— ì¶”ê°€í•´ë³¼ ë§Œí•œ ê¸°ëŠ¥!
- ë‚¨ì€ ì§€ë¢° ìˆ˜, ê¹ƒë°œ ìˆ˜ í‘œì‹œí•˜ê¸°
- ê¹ƒë°œ ì œê±° ê¸°ëŠ¥
- ê²Œì„ íŒ¨ë°° ì‹œ Board ì— ì¡´ì¬í•˜ëŠ” ëª¨ë“  ì§€ë¢° ë³´ì—¬ì£¼ê¸°
- ...