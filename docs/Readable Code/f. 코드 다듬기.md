# ÏΩîÎìú Îã§Îì¨Í∏∞

# üí° Ï£ºÏÑùÏùò ÏñëÎ©¥ÏÑ±

## ‚ö°Ô∏è Ï£ºÏÑùÏùÄ Ï£ÑÏïÖÏù¥Îã§! vs Ï£ºÏÑù Ï¢Ä ÎÇ®Í∏∞Ïûê!

> Ï£ºÏÑùÏù¥ ÎßéÎã§Îäî Í≤ÉÏùÄ Í∑∏ÎßåÌÅº ÎπÑÏ¶àÎãàÏä§ ÏöîÍµ¨ÏÇ¨Ìï≠ÏùÑ ÏΩîÎìúÏóê Ïûò ÌëúÌòÑÌïòÏßÄ Î™ªÌñàÎã§.

> ÏΩîÎìúÎ•º ÏÑ§Î™ÖÌïòÎäî Ï£ºÏÑùÏùÑ Ïì∞Î©¥, ÏΩîÎìúÍ∞Ä ÏïÑÎãå Ï£ºÏÑù ÏÑ§Î™ÖÏóê ÏùòÏ°¥ÌïòÍ≤å ÎêúÎã§.
- Ï£ºÏÑùÏóê ÏùòÏ°¥ÌïòÏó¨ ÏΩîÎìúÎ•º ÏûëÏÑ±ÌïòÎ©¥, Ï†ÅÏ†àÌïòÏßÄ ÏïäÏùÄ Ï∂îÏÉÅÌôî Î†àÎ≤®ÏùÑ Í∞ñÍ≤å ÎêòÏñ¥ ÎÇÆÏùÄ ÌíàÏßàÏùò ÏΩîÎìúÍ∞Ä ÎßåÎì§Ïñ¥ÏßÑÎã§.

## ‚ö°Ô∏è Í∑∏Îüº Ï£ºÏÑùÏùÄ Ïñ∏Ï†ú Ïì∞ÎÇò?

## ‚ö°Ô∏è Ï¢ãÏùÄ Ï£ºÏÑù

> ÌõÑÎåÄÏóê Ï†ÑÌï¥Ïïº Ìï† `ÏùòÏÇ¨ Í≤∞Ï†ïÏùò ÌûàÏä§ÌÜ†Î¶¨` Ïôú Ïù¥Îü∞ Ï†ïÏ±ÖÏùÑ Í∞ñÍ≤å ÎêòÏóàÍ≥†, Ïôú Ïù¥Îü∞ ÌûàÏä§ÌÜ†Î¶¨Î•º Í∞ñÍ≤å ÎêòÏóàÎäîÏßÄÎ•º ÏΩîÎìúÎ°ú ÏÑ§Î™ÖÌï† Ïàò ÏóÜÏùÑ ÎñÑ
> 
> **Ï£ºÏÑù**ÏùÑ ÏÇ¨Ïö©ÌïúÎã§.

```java
/**
 * Ïù¥ Í∞ùÏ≤¥Í∞Ä Í∞ÄÏßÑ Ï†ïÏ±ÖÏùÄ,
 * A Ï†ïÏ±ÖÍ≥º B Ï†ïÏ±ÖÏ§ë, AB ÌÖåÏä§Ìä∏ÏôÄ Í∏∞Ïà† ÌöåÏùòÎ•º ÌÜµÌï¥ Í≤∞Ï†ïÎêú ÏÇ¨Ìï≠ÏùÑ Í∏∞Î∞òÏúºÎ°ú ÏÑ†ÌÉùÎêòÏñ¥ ÏûëÏÑ±Îêú Í≤ÉÏù¥Îã§.
 * Í¥ÄÎ†® Î¨∏ÏÑú: https://docs.google.com/document/d/1
 */
public class ImportantPolicy { }
```

- Ï£ºÏÑùÏùÑ ÏûëÏÑ±Ìï† Îïå, ÏûêÏ£º Î≥ÄÌïòÎäî Ï†ïÎ≥¥Îäî ÏµúÎåÄÌïú ÏßÄÏñëÌï¥ÏÑú ÏûëÏÑ±ÌïúÎã§.
- Ï£ºÏÑùÎèÑ ÏΩîÎìúÏ≤òÎüº Í∞ôÏù¥ Í¥ÄÎ¶¨Ìï¥Ï§òÏïº ÌïúÎã§. ÏßÄÏÜçÏ†ÅÏù∏ ÏóÖÎç∞Ïù¥Ìä∏Í∞Ä ÌïÑÏöîÌïòÎã§.
- Ï£ºÏÑùÏù¥ ÏïÑÏòà ÏóÜÎäî Í≤É Î≥¥Îã§, Î∂ÄÏ†ïÌôïÌïú Ï†ïÎ≥¥Î•º Í∞ñÍ≥† ÏûàÎäî Ï£ºÏÑùÏù¥ Îçî ÏµúÏïÖÏù¥Îã§.

> üí° **Î®ºÏ†Ä, Ïö∞Î¶¨Í∞Ä Í∞ÄÏßÑ Î™®Îì† ÌëúÌòÑ Î∞©Î≤ïÏùÑ ÌÜµÌï¥ ÏΩîÎìúÎ•º ÌÜµÌï¥ ÏùòÎèÑÎì§ÏùÑ Ïûò ÏûëÏÑ±ÌïòÍ≥†, Í∑∏ÎüºÏóêÎèÑ Î∂àÍµ¨ÌûàÍ≥† ÏΩîÎìúÏóê ÎÖπÏó¨ÎÇ¥ÏßÄ Î™ªÌïòÎäî Ï†ïÎ≥¥Í∞Ä ÏûàÎã§Î©¥ Ï£ºÏÑùÏùÑ ÏÇ¨Ïö©ÌïòÏûê!** 

ÏïÑÎûòÏùò Ï£ºÏÑùÏùÄ Íº≠ ÌïÑÏöîÌïú Ï£ºÏÑùÏùºÍπå?

**AS-IS**

Ìï¥Îãπ Ï£ºÏÑùÏùÄ Í≤åÏûÑÏùò ÏÉÅÌÉúÍ∞íÏùÑ int Î°ú ÌëúÏãúÌïòÍ≥† ÏûàÎã§. ÌïòÏßÄÎßå, Ïù¥Í≤ÉÏùÑ Enum ÏúºÎ°ú ÌëúÌòÑÌïòÎ©¥ Ï£ºÏÑùÏùÑ ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÍ≥†ÎèÑ ÏùòÎèÑÎ•º Îçî Î™ÖÌôïÌïòÍ≤å ÌëúÌòÑÌï† Ïàò ÏûàÎã§.

```java
private int gameStatus = 0; // 0: Í≤åÏûÑ Ï§ë, 1: ÏäπÎ¶¨, -1: Ìå®Î∞∞
```

**TO-BE**

```java
public enum GameStatus {
	IN_PROGRESS("ÏßÑÌñâ Ï§ë"),
	WIN("ÏäπÎ¶¨"),
	LOSE("Ìå®Î∞∞")
	;

	private final String description;

	GameStatus(String description) {
		this.description = description;
	}
}
```

#### GameStatus Î•º ÎßåÎì§Î©¥ÏÑú Minesweeper Ïùò Ïó≠Ìï†Í≥º GameBoard Ïùò Ïó≠Ìï†ÏùÑ Ï¢Ä Îçî ÌôïÏã§ÌïòÍ≤å Î∂ÑÎ¶¨ÏãúÏº∞Îã§.

- `GameBoard` Îäî Ïã§Ï†ú Í≤åÏûÑ ÏßÑÌñâÏóê ÎåÄÌïú Í≤ÉÎì§ÏùÑ Î™®Îëê Îã¥ÎãπÌïúÎã§.
  - Ïã§Ï†úÏ†ÅÏù∏ ÏßÄÎ¢∞ Ï∞æÍ∏∞Ïùò ÎèÑÎ©îÏù∏ Î°úÏßÅÏùÑ Î™®Îëê Í¥ÄÎ¶¨ÌïúÎã§.
- `MineSweeper` Îäî Ïô∏Î∂Ä ÏÑ∏Í≥ÑÏôÄÏùò Ï†ëÏ†ê, Ïª®Ìä∏Î°§Îü¨Ïùò Ïó≠Ìï†ÏùÑ ÌïòÎäî Í≤ÉÏù¥Îã§.
  - Í≤åÏûÑÏùÑ Ïã§ÌñâÌïòÍ≥† Ïó¨Îü¨Í∞ÄÏßÄ ÏûÖ/Ï∂úÎ†•Îì§ÏùÑ Ï§ëÍ∞ÑÏóêÏÑú Îã¥ÎãπÌïòÏó¨ Ï†ÑÎã¨Ìï¥Ï§ÄÎã§.

### MVC Íµ¨Ï°∞Ï≤òÎüº ÎèåÏïÑÍ∞ÄÎäî Í≤ÉÏùÑ Î≥º Ïàò ÏûàÎã§.

---

# üí° Î≥ÄÏàòÏôÄ Î©îÏÑúÎìúÏùò ÎÇòÏó¥ ÏàúÏÑú

## ‚ö°Ô∏è Î≥ÄÏàòÏôÄ Î©îÏÑúÎìúÎäî Ïñ¥Îñ§ ÏàúÏÑúÎåÄÎ°ú ÎÇòÏó¥ÌïòÎäî Í≤ÉÏù¥ Í∞ÄÏû• Ï¢ãÏùÑÍπå?

> **`Î≥ÄÏàò`Îäî ÏÇ¨Ïö©ÌïòÎäî ÏàúÏÑúÎåÄÎ°ú ÎÇòÏó¥ÌïúÎã§.**
- **Ïù∏ÏßÄÏ†Å Í≤ΩÏ†úÏÑ±(Îáå Î©îÎ™®Î¶¨)**
- Î≥ÄÏàòÍ∞Ä ÏÇ¨Ïö©ÌïòÍ∏∞ Í∞ÄÍπåÏö¥ Ï™ΩÏóê Î∞∞ÏπòÌï¥Ïïº ÎêúÎã§.

> Í∞ùÏ≤¥ Í∞ÑÏùò ÌòëÎ†• Í¥ÄÏ†êÏóêÏÑú Î∞îÎùºÎ≥º Îïå, Í≥µÍ∞ú Î©îÏÑúÎìú(public)Î•º Î®ºÏ†Ä ÏúÑÏóê Î∞∞ÏπòÌïòÍ≥†, Í∑∏ Îã§ÏùåÏóê ÎπÑÍ≥µÍ∞ú Î©îÏÑúÎìú(private)Î•º ÎÇòÏó¥ÌïúÎã§.
- Î¨ºÎ°†, Ïù¥Í≤ÉÏù¥ Ï†ïÎãµÏùÄ ÏïÑÎãàÎã§.

> Í≥µÍ∞ú Î©îÏÑúÎìú ÎÅºÎ¶¨ÎèÑ Í∏∞Ï§ÄÏùÑ Í∞ÄÏπòÍ≥† Î∞∞ÏπòÌïòÎäî Í≤ÉÏù¥ Ï¢ãÎã§!
- Î©îÏÑúÎìúÍ∞Ä ÏàòÏã≠Í∞úÏù∏ Í∞ùÏ≤¥Ïùò Í≤ΩÏö∞, Î©îÏÑúÎìúÎ•º Í∏∞Ï§ÄÏùÑ Í∞ÄÏßÄÍ≥† Í∑∏Î£πÌôîÌïòÏó¨ Î∞∞ÏπòÌïúÎã§. ÎòëÍ∞ôÏùÄ Í∏∞Îä•ÏùÑ Í∞ÄÏßÑ Î©îÏÑúÎìúÏùò Ï§ëÎ≥µ ÏÉùÏÑ± Î∞©ÏßÄ Î∞è ÏùºÍ¥ÄÏÑ± ÏûàÎäî Î°úÏßÅÏùÑ Ïú†ÏßÄÌï† Ïàò ÏûàÎã§.
- ***ÏÉÅÌÉú Î≥ÄÍ≤Ω >> ÌåêÎ≥Ñ >= Ï°∞Ìöå Î©îÏÑúÎìú***
  - Í∞ùÏ≤¥Ïùò ÏÉÅÌÉúÎ•º Î≥ÄÍ≤ΩÌïòÎäî ÏûëÏóÖÏùÄ Îß§Ïö∞ Ï§ëÏöîÌïú ÏûëÏóÖÏù¥Í∏∞ ÎïåÎ¨∏Ïóê ÏÉÅÎã®Ïóê Î∞∞ÏπòÌï† Ïàò ÏûàÎèÑÎ°ù ÌïúÎã§.

> ÎπÑÍ≥µÍ∞ú(private) Î©îÏÑúÎìúÎäî, Í≥µÍ∞ú(public) Î©îÏÑúÎìúÏóêÏÑú Ïñ∏Í∏âÎêú ÏàúÏÑúÎåÄÎ°ú Î∞∞ÏπòÌïúÎã§.
- `Í≥µÌÜµÏúºÎ°ú ÏÇ¨Ïö©ÌïòÎäî Î©îÏÑúÎìú`ÎùºÎ©¥, **(Í∞ÄÏû• ÌïòÎã®Í≥º Í∞ôÏùÄ) Ï†ÅÎãπÌïú Í≥≥Ïóê Î∞∞ÏπòÌïúÎã§.**

### üîã Ï§ëÏöîÌïú Í≤ÉÏùÄ, ÎÇòÏó¥ ÏàúÏÑúÎ°úÎèÑ ÏùòÎèÑÏôÄ Ï†ïÎ≥¥Î•º Ï†ÑÎã¨Ìï† Ïàò ÏûàÎã§Îäî Í≤É!

**AS-IS**

```java
public class Minesweeper implements GameInitializable, GameRunnable {
	private final GameBoard gameBoard;
	private final InputHandler inputHandler;
	private final OutputHandler outputHandler;

	public Minesweeper(GameConfig gameConfig) {
		gameBoard = new GameBoard(gameConfig.getGameLevel());
		this.inputHandler = gameConfig.getInputHandler();
		this.outputHandler = gameConfig.getOutputHandler();
	}

	@Override
	public void initialize() {
		gameBoard.initializeGame();
	}

	@Override
	public void run() {
		outputHandler.showGameStartComments();

		while (gameBoard.inInProgress()) {
			try {
				outputHandler.showBoard(gameBoard);

				CellPosition cellPosition = getCellInputFromUser();
				UserAction userActionInput = getUserActionInputFromUser();
				actOnCell(cellPosition, userActionInput);
			} catch (GameException e) {
				outputHandler.showExceptionMessage(e);
			} catch (Exception e) {
				outputHandler.showSimpleMessage("ÌîÑÎ°úÍ∑∏Îû®Ïóê Î¨∏Ï†úÍ∞Ä ÏÉùÍ≤ºÏäµÎãàÎã§.");
			}
		}
		outputHandler.showBoard(gameBoard);

		if (gameBoard.isWinStatus()) {
			outputHandler.showGameWinningComment();
		}
		if (gameBoard.isLoseStatus()) {
			outputHandler.showGameLosingComment();
		}
	}

	private void actOnCell(CellPosition cellPosition, UserAction userActionInput) {
		if (doesUserChooseToPlantFlag(userActionInput)) {
			gameBoard.flagAt(cellPosition);
			return;
		}
		if (doesUserChooseToOpenCell(userActionInput)) {
			gameBoard.openAt(cellPosition);
			return;
		}
		throw new GameException("ÏûòÎ™ªÎêú Î≤àÌò∏Î•º ÏÑ†ÌÉùÌïòÏÖ®ÏäµÎãàÎã§.");
	}

	private boolean doesUserChooseToOpenCell(UserAction userAction) {
		return userAction == UserAction.OPEN;
	}

	private boolean doesUserChooseToPlantFlag(UserAction userAction) {
		return userAction == UserAction.FLAG;
	}

	private UserAction getUserActionInputFromUser() {
		outputHandler.showCommentForUserAction();
		return inputHandler.getUserActionFromUser();
	}

	private CellPosition getCellInputFromUser() {
		outputHandler.showCommentForSelectingCell();
		CellPosition cellPosition = inputHandler.getCellPositionFromUser();
		if (gameBoard.isInvalidCellPosition(cellPosition)) {
			throw new GameException("ÏûòÎ™ªÎêú Ï¢åÌëúÎ•º ÏÑ†ÌÉùÌïòÏÖ®ÏäµÎãàÎã§.");
		}

		return cellPosition;
	}
}
```

**TO-BE**

```java
public class Minesweeper implements GameInitializable, GameRunnable {
	private final GameBoard gameBoard;
	private final InputHandler inputHandler;
	private final OutputHandler outputHandler;

	public Minesweeper(GameConfig gameConfig) {
		gameBoard = new GameBoard(gameConfig.getGameLevel());
		this.inputHandler = gameConfig.getInputHandler();
		this.outputHandler = gameConfig.getOutputHandler();
	}

	@Override
	public void initialize() {
		gameBoard.initializeGame();
	}

	@Override
	public void run() {
		outputHandler.showGameStartComments();

		while (gameBoard.inInProgress()) {
			try {
				outputHandler.showBoard(gameBoard);

				CellPosition cellPosition = getCellInputFromUser();
				UserAction userActionInput = getUserActionInputFromUser();
				actOnCell(cellPosition, userActionInput);
			} catch (GameException e) {
				outputHandler.showExceptionMessage(e);
			} catch (Exception e) {
				outputHandler.showSimpleMessage("ÌîÑÎ°úÍ∑∏Îû®Ïóê Î¨∏Ï†úÍ∞Ä ÏÉùÍ≤ºÏäµÎãàÎã§.");
			}
		}
		outputHandler.showBoard(gameBoard);

		if (gameBoard.isWinStatus()) {
			outputHandler.showGameWinningComment();
		}
		if (gameBoard.isLoseStatus()) {
			outputHandler.showGameLosingComment();
		}
	}

	private CellPosition getCellInputFromUser() {
		outputHandler.showCommentForSelectingCell();
		CellPosition cellPosition = inputHandler.getCellPositionFromUser();
		if (gameBoard.isInvalidCellPosition(cellPosition)) {
			throw new GameException("ÏûòÎ™ªÎêú Ï¢åÌëúÎ•º ÏÑ†ÌÉùÌïòÏÖ®ÏäµÎãàÎã§.");
		}

		return cellPosition;
	}

	private UserAction getUserActionInputFromUser() {
		outputHandler.showCommentForUserAction();
		return inputHandler.getUserActionFromUser();
	}

	private void actOnCell(CellPosition cellPosition, UserAction userActionInput) {
		if (doesUserChooseToPlantFlag(userActionInput)) {
			gameBoard.flagAt(cellPosition);
			return;
		}
		if (doesUserChooseToOpenCell(userActionInput)) {
			gameBoard.openAt(cellPosition);
			return;
		}
		throw new GameException("ÏûòÎ™ªÎêú Î≤àÌò∏Î•º ÏÑ†ÌÉùÌïòÏÖ®ÏäµÎãàÎã§.");
	}

	private boolean doesUserChooseToPlantFlag(UserAction userAction) {
		return userAction == UserAction.FLAG;
	}

	private boolean doesUserChooseToOpenCell(UserAction userAction) {
		return userAction == UserAction.OPEN;
	}
}
```

**AS-IS**

```java
public class GameBoard {

	private final Cell[][] board;
	private final int landMineCount;
	private GameStatus gameStatus;

	public GameBoard(GameLevel gameLevel) {
		int rowSize = gameLevel.getRowSize();
		int colSize = gameLevel.getColSize();
		board = new Cell[rowSize][colSize];

		landMineCount = gameLevel.getLandMineCount();
		initializeGameStatus();
	}

	public void initializeGame() {
		initializeGameStatus();
		CellPositions cellPositions = CellPositions.from(board);

		initializeEmptyCells(cellPositions);

		List<CellPosition> landMinePositions = cellPositions.extractRandomPositions(landMineCount);
		initializeLandMineCells(landMinePositions);

		List<CellPosition> numberPositionCandidates = cellPositions.subtract(landMinePositions);
		initializeNumberCells(numberPositionCandidates);
	}

	public void flagAt(CellPosition cellPosition) {
		Cell cell = findCell(cellPosition);
		cell.flag();

		checkIfGameIsOver();
	}

	private void checkIfGameIsOver() {
		if (isAllCellChecked()) {
			changeGameStatusToWin();
		}
	}

	private void changeGameStatusToWin() {
		gameStatus = GameStatus.WIN;
	}

	public void openAt(CellPosition cellPosition) {
		if (isLandMineCellAt(cellPosition)) {
			openOneCellAt(cellPosition);
			changeGameStatusToLose();
			return;
		}

		openSurroundedCells(cellPosition);
		checkIfGameIsOver();
	}

	public void openOneCellAt(CellPosition cellPosition) {
		Cell cell = findCell(cellPosition);
		cell.open();
	}

	public void openSurroundedCells(CellPosition cellPosition) {
		if (isOpenedCell(cellPosition)) {
			return;
		}
		if (isLandMineCellAt(cellPosition)) {
			return;
		}

		openOneCellAt(cellPosition);

		if (doesCellHaveLandMineCount(cellPosition)) {
			return;
		}

		List<CellPosition> surroundedPositions = calculateSurroundedPositions(cellPosition, getRowSize(), getColSize());
		surroundedPositions.forEach(this::openSurroundedCells);
	}

	private boolean doesCellHaveLandMineCount(CellPosition cellPosition) {
		Cell cell = findCell(cellPosition);
		return cell.hasLandMineCount();
	}

	private boolean isOpenedCell(CellPosition cellPosition) {
		Cell cell = findCell(cellPosition);
		return cell.isOpened();
	}

	public boolean isLandMineCellAt(CellPosition cellPosition) {
		Cell cell = findCell(cellPosition);
		return cell.isLandMine();
	}

	public boolean isAllCellChecked() {
		Cells cells = Cells.from(board);
		return cells.isAllChecked();
	}

	public boolean isInvalidCellPosition(CellPosition cellPosition) {
		int rowSize = getRowSize();
		int colSize = getColSize();

		return cellPosition.isRowIndexMoreThanOrEqual(rowSize)
			|| cellPosition.isColIndexMoreThanOrEqual(colSize);
	}

	public boolean inInProgress() {
		return gameStatus == GameStatus.IN_PROGRESS;
	}

	private void initializeGameStatus() {
		gameStatus = GameStatus.IN_PROGRESS;
	}

	private void changeGameStatusToLose() {
		gameStatus = GameStatus.LOSE;
	}

	private void initializeEmptyCells(CellPositions cellPositions) {
		List<CellPosition> allPositions = cellPositions.getPositions();
		for (CellPosition position : allPositions) {
			updateCellAt(position, new EmptyCell());
		}
	}

	private void initializeLandMineCells(List<CellPosition> landMinePositions) {
		for (CellPosition position : landMinePositions) {
			updateCellAt(position, new LandMineCell());
		}
	}

	private void initializeNumberCells(List<CellPosition> numberPositionCandidates) {
		for (CellPosition candidatePosition : numberPositionCandidates) {
			int count = countNearbyLandMines(candidatePosition);
			if (count != 0) {
				updateCellAt(candidatePosition, new NumberCell(count));
			}
		}
	}

	private void updateCellAt(CellPosition position, Cell cell) {
		board[position.getRowIndex()][position.getColIndex()] = cell;
	}

	public CellSnapshot getSnapshot(CellPosition cellPosition) {
		Cell cell = findCell(cellPosition);
		return cell.getSnapshot();
	}

	private Cell findCell(CellPosition cellPosition) {
		return board[cellPosition.getRowIndex()][cellPosition.getColIndex()];
	}

	public int getRowSize() {
		return board.length;
	}

	public int getColSize() {
		return board[0].length;
	}

	private int countNearbyLandMines(CellPosition cellPosition) {
		int rowSize = getRowSize();
		int colSize = getColSize();

		long count = calculateSurroundedPositions(cellPosition, rowSize, colSize).stream()
			.filter(this::isLandMineCellAt)
			.count();

		return (int) count;
	}

	private List<CellPosition> calculateSurroundedPositions(CellPosition cellPosition, int rowSize, int colSize) {
		return RelativePosition.SURROUNDED_POSITIONS.stream()
			.filter(cellPosition::canCalculatePositionBy)
			.map(cellPosition::calculatePositionBy)
			.filter(position -> position.isRowIndexLessThan(rowSize))
			.filter(position -> position.isColIndexLessThan(colSize))
			.toList();
	}

	public boolean isWinStatus() {
		return gameStatus == GameStatus.WIN;
	}

	public boolean isLoseStatus() {
		return gameStatus == GameStatus.LOSE;
	}
}
```

**TO-BE**

```java
public class GameBoard {

	private final Cell[][] board;
	private final int landMineCount;
	private GameStatus gameStatus;

	public GameBoard(GameLevel gameLevel) {
		int rowSize = gameLevel.getRowSize();
		int colSize = gameLevel.getColSize();
		board = new Cell[rowSize][colSize];

		landMineCount = gameLevel.getLandMineCount();
		initializeGameStatus();
	}

	// public
	// ÏÉÅÌÉú Î≥ÄÍ≤Ω
	public void initializeGame() {
		initializeGameStatus();
		CellPositions cellPositions = CellPositions.from(board);

		initializeEmptyCells(cellPositions);

		List<CellPosition> landMinePositions = cellPositions.extractRandomPositions(landMineCount);
		initializeLandMineCells(landMinePositions);

		List<CellPosition> numberPositionCandidates = cellPositions.subtract(landMinePositions);
		initializeNumberCells(numberPositionCandidates);
	}

	public void openAt(CellPosition cellPosition) {
		if (isLandMineCellAt(cellPosition)) {
			openOneCellAt(cellPosition);
			changeGameStatusToLose();
			return;
		}

		openSurroundedCells(cellPosition);
		checkIfGameIsOver();
	}

	public void flagAt(CellPosition cellPosition) {
		Cell cell = findCell(cellPosition);
		cell.flag();

		checkIfGameIsOver();
	}

	// ÌåêÎ≥Ñ
	public boolean isInvalidCellPosition(CellPosition cellPosition) {
		int rowSize = getRowSize();
		int colSize = getColSize();

		return cellPosition.isRowIndexMoreThanOrEqual(rowSize)
			|| cellPosition.isColIndexMoreThanOrEqual(colSize);
	}

	public boolean inInProgress() {
		return gameStatus == GameStatus.IN_PROGRESS;
	}


	// Ï°∞Ìöå
	public CellSnapshot getSnapshot(CellPosition cellPosition) {
		Cell cell = findCell(cellPosition);
		return cell.getSnapshot();
	}

	public int getRowSize() {
		return board.length;
	}

	public int getColSize() {
		return board[0].length;
	}

	public boolean isWinStatus() {
		return gameStatus == GameStatus.WIN;
	}

	public boolean isLoseStatus() {
		return gameStatus == GameStatus.LOSE;
	}


	// private

	private void initializeGameStatus() {
		gameStatus = GameStatus.IN_PROGRESS;
	}

	private void initializeEmptyCells(CellPositions cellPositions) {
		List<CellPosition> allPositions = cellPositions.getPositions();
		for (CellPosition position : allPositions) {
			updateCellAt(position, new EmptyCell());
		}
	}

	private void initializeLandMineCells(List<CellPosition> landMinePositions) {
		for (CellPosition position : landMinePositions) {
			updateCellAt(position, new LandMineCell());
		}
	}

	private void initializeNumberCells(List<CellPosition> numberPositionCandidates) {
		for (CellPosition candidatePosition : numberPositionCandidates) {
			int count = countNearbyLandMines(candidatePosition);
			if (count != 0) {
				updateCellAt(candidatePosition, new NumberCell(count));
			}
		}
	}

	private int countNearbyLandMines(CellPosition cellPosition) {
		int rowSize = getRowSize();
		int colSize = getColSize();

		long count = calculateSurroundedPositions(cellPosition, rowSize, colSize).stream()
			.filter(this::isLandMineCellAt)
			.count();

		return (int) count;
	}

	private List<CellPosition> calculateSurroundedPositions(CellPosition cellPosition, int rowSize, int colSize) {
		return RelativePosition.SURROUNDED_POSITIONS.stream()
			.filter(cellPosition::canCalculatePositionBy)
			.map(cellPosition::calculatePositionBy)
			.filter(position -> position.isRowIndexLessThan(rowSize))
			.filter(position -> position.isColIndexLessThan(colSize))
			.toList();
	}

	private void updateCellAt(CellPosition position, Cell cell) {
		board[position.getRowIndex()][position.getColIndex()] = cell;
	}

	private void openSurroundedCells(CellPosition cellPosition) {
		if (isOpenedCell(cellPosition)) {
			return;
		}
		if (isLandMineCellAt(cellPosition)) {
			return;
		}

		openOneCellAt(cellPosition);

		if (doesCellHaveLandMineCount(cellPosition)) {
			return;
		}

		List<CellPosition> surroundedPositions = calculateSurroundedPositions(cellPosition, getRowSize(), getColSize());
		surroundedPositions.forEach(this::openSurroundedCells);
	}

	private void openOneCellAt(CellPosition cellPosition) {
		Cell cell = findCell(cellPosition);
		cell.open();
	}

	private boolean isOpenedCell(CellPosition cellPosition) {
		Cell cell = findCell(cellPosition);
		return cell.isOpened();
	}

	private boolean isLandMineCellAt(CellPosition cellPosition) {
		Cell cell = findCell(cellPosition);
		return cell.isLandMine();
	}

	private boolean doesCellHaveLandMineCount(CellPosition cellPosition) {
		Cell cell = findCell(cellPosition);
		return cell.hasLandMineCount();
	}

	private void checkIfGameIsOver() {
		if (isAllCellChecked()) {
			changeGameStatusToWin();
		}
	}

	private boolean isAllCellChecked() {
		Cells cells = Cells.from(board);
		return cells.isAllChecked();
	}

	private void changeGameStatusToWin() {
		gameStatus = GameStatus.WIN;
	}

	private void changeGameStatusToLose() {
		gameStatus = GameStatus.LOSE;
	}

	private Cell findCell(CellPosition cellPosition) {
		return board[cellPosition.getRowIndex()][cellPosition.getColIndex()];
	}
}
```

---



