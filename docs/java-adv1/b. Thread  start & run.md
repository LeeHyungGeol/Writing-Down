# 스레드 생성과 실행# 💡 스레드 생성 - extends Thread```javapublic class HelloThread extends Thread {    @Override    public void run() {        System.out.println(Thread.currentThread().getName() + ": run()");    }}public class HelloThreadMain {    public static void main(String[] args) {        System.out.println(Thread.currentThread().getName() + ": main() start");        HelloThread helloThread = new HelloThread();        System.out.println(Thread.currentThread().getName() + ": start() 호출 전");        System.out.println("helloThread = " + helloThread);        helloThread.start();//        helloThread.run(); // 오버라이딩한 run() 메서드를 직접 실행        System.out.println(Thread.currentThread().getName() + ": start() 호출 후");        System.out.println(Thread.currentThread().getName() + ": main() end");    }}``````main: main() startmain: start() 호출 전helloThread = Thread[#20,Thread-0,5,main]main: start() 호출 후main: main() endThread-0: run()```<img width="500" alt="스크린샷 2024-08-21 오후 9 05 47" src="https://github.com/user-attachments/assets/066f039f-ed6e-447a-8991-556dadef5b9c"><img width="500" alt="스크린샷 2024-08-21 오후 9 06 04" src="https://github.com/user-attachments/assets/7d9ba46e-9d2c-41a2-a9ca-9bbade515a75">- 프로세스가 작동하려면 적어도 최소한 하나의 스레드가 있어야 한다.(그래야 코드를 실행할 수 있다.) **자바는 실행 시점에 `main` 이라는 이름의 스레드를 만들고 프로그램의 시작점인 `main()` 메서드를 실행한다.**- HelloThread 스레드 객체를 생성해서 start() 메서드를 호출하면, 자바는 스레드를 위한 **`별도의 스택 공간`을 할당한다.**- **메서드를 실행하면 스택 위에 스택 프레임이 쌓인다**<img width="500" alt="스크린샷 2024-08-21 오후 8 38 26" src="https://github.com/user-attachments/assets/222652d9-d8ad-4664-a0c0-24267ab183a9">- 스레드의 생성 방법 중 하나로 `Thread` 클래스를 상속받아 `run()` 메소드를 오버라이딩하는 방법이 있다.> **핵심은 `main` 스레드가 `run()` 메서드를 실행하는게 아니라 `Thread-0` 스레드가 `run()` 메서드를 실행한다는 점이다.**- `main` 스레드는 단지 `start()` 메서드를 통해 `Thread-0` 스레드에게 실행을 지시할 뿐이다. - `main` 스레드가 `run()` 을 호출하는 것이 아니다! - `main` 스레드는 다른 스레드에게 일을 시작하라고 지시만 하고, 바로 `start()` 메서드를 빠져나온다.> **스레드간 실행 순서를 보장하지 않는다!**- CPU 코어가 2개여서 물리적으로 정말 동시에 스레드를 실행할 수도 있고,- 하나의 CPU 코어에 시간을 나누어 실행될 수도 있다. - 한 스레드가 얼마나 오랜기간 실행되는지도 보장하지 않는다. - 한 스레드가 먼저 다 수행된 다음에 다른 스레드가 수행될 수도 있고, 둘이 완전히 번갈아 가면서 수행되는 경우도 있다.<img width="500" alt="스크린샷 2024-08-21 오후 9 15 32" src="https://github.com/user-attachments/assets/12684d6e-f649-4d98-b590-a9f3d46cab5d"><img width="500" alt="스크린샷 2024-08-21 오후 9 15 43" src="https://github.com/user-attachments/assets/617e0be2-cd7d-400a-87e0-6f02f47b9b98">- `main` 스레드가 `run()` 메서드를 호출 할 것을 확인할 수 있다.- `main` 스레드는 `HelloThread` 인스턴스에 있는 `run()` 이라는 메서드를 호출한다.- `main` 스레드가 `run()` 메서드를 실행했기 때문에 `main` 스레드가 사용하는 스택위에 `run()` 스택 프레임이 올라간다.<br/><br/><br/># 💡 데몬 스레드(Daemon Thread)**사용자 스레드(non-daemon 스레드)**- 프로그램의 주요 작업을 수행한다.- 작업이 완료될 때까지 실행된다.- 모든 user 스레드가 종료되면 JVM도 종료된다.**<u>데몬 스레드</u>**- 백그라운드에서 보조적인 작업을 수행한다.- 모든 user 스레드가 종료되면 데몬 스레드는 자동으로 종료된다.`JVM`은 데몬 스레드의 실행 완료를 기다리지 않고 종료된다. **데몬 스레드가 아닌 모든 스레드가 종료되면, 자바 프로그램도 종료된다.**```javapublic class DaemonThreadMain {    public static void main(String[] args) {        System.out.println(Thread.currentThread().getName() + ": main() start");        DaemonThread daemonThread = new DaemonThread();        daemonThread.setDaemon(true);        daemonThread.start();        System.out.println(Thread.currentThread().getName() + ": main() end");    }    static class DaemonThread extends Thread {        @Override        public void run() {            System.out.println(Thread.currentThread().getName() + ": run() start");            try {                Thread.sleep(10000); // 10초간 실행            } catch (InterruptedException e) {                throw new RuntimeException(e);            }            System.out.println(Thread.currentThread().getName() + ": run() end");        }    }}```- 데몬 스레드 여부는 `start()` 실행 전에 결정해야 한다. 이후에는 변경되지 않는다.  - `run()` 메서드 안에서 `Thread.sleep()` 를 호출할 때 체크 예외인 `InterruptedException` 을 밖으로 던질 수 없고 반드시 잡아야 한다.<br/><br/><br/># 💡 Thread 상속 vs Runnable 구현스레드 사용할 때는 `Thread` 를 상속 받는 방법보다 **`Runnable` 인터페이스를 구현하는 방식을 사용하자.**<details><summary>Thread 클래스 상속 방식 vs Runnable 인터페이스를 구현 방식</summary>**Thread 클래스 상속 방식** - **장점**  - 간단한 구현: `Thread` 클래스를 상속받아 `run()` 메서드만 재정의하면 된다. - **단점**  - 상속의 제한: 자바는 단일 상속만을 허용하므로 이미 다른 클래스를 상속받고 있는 경우 `Thread` 클래스를 상속 받을 수 없다.  - 유연성 부족: 인터페이스를 사용하는 방법에 비해 유연성이 떨어진다.**Runnable 인터페이스를 구현 방식** - **장점**  - 상속의 자유로움: `Runnable` 인터페이스 방식은 다른 클래스를 상속받아도 문제없이 구현할 수 있다.   - 코드의 분리: 스레드와 실행할 작업을 분리하여 코드의 가독성을 높일 수 있다.   - 여러 스레드가 동일한 `Runnable` 객체를 공유할 수 있어 자원 관리를 효율적으로 할 수 있다.- **단점**  - 코드가 약간 복잡해질 수 있다. `Runnable` 객체를 생성하고 이를 `Thread` 에 전달하는 과정이 추가된다.</details><u>**Runnable 인터페이스를 구현하는 방식을 사용하자!!!**</u>- **스레드와 실행할 작업을 명확히 분리**하고, `Thread` 클래스를 직접 상속하는 방식보다 **더 유연하고 유지보수 하기 쉬운 코드**를 만들 수 있다.# 💡 여러 스레드 만들기```javapublic class ManyThreadMainV1 {    public static void main(String[] args) {        log("main start");        HelloRunnable helloRunnable = new HelloRunnable();        Thread thread1 = new Thread(helloRunnable);        thread1.start();        Thread thread2 = new Thread(helloRunnable);        thread2.start();        Thread thread3 = new Thread(helloRunnable);        thread3.start();        log("main end");    }}```<img width="500" alt="스크린샷 2024-09-04 오후 4 18 42" src="https://github.com/user-attachments/assets/75af400b-b45b-451b-abea-9bd96d21b027">- 실행 결과는 다를 수 있다. **스레드의 실행 순서는 보장되지 않는다!!!**- 스레드 3개를 생성할 때 모두 같은 `HelloRunnable` 인스턴스( `x001` )를 스레드의 실행 작업으로 전달했다.- `Thread-0` , `Thread-1` , `Thread-2` 는 모두 `HelloRunnable` 인스턴스에 있는 `run()` 메서드를 실행한다.