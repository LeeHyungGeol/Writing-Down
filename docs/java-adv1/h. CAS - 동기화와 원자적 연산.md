# CAS - 동기화와 원자적 연산<br/><br/><br/># 💡원자적 연산> **원자적 연산**(`atomic operation`): **해당 연산이 더 이상 나눌 수 없는 단위로 수행된다**는 것을 의미`i = 1;`- 위의 연산은 둘로 쪼갤 수 없는 `원자적 연산`이다.- **단 하나의 순서로 실행되기 때문이다.**`i = i + 1;`- 위의 연산은 **`원자적 연산`이 아니다.**1. 오른쪽에 있는 `i` 의 값을 읽는다. `i` 의 값은 1 이다.2. 읽은 1에 1을 더해서 2를 만든다.3. 더한 2을 왼쪽의 `i` 변수에 대입한다.`i++;`- **원자적 연산이 아니다.**- `i = i + 1` 을 축약한 것> **원자적 연산은 멀티스레드 상황에서 아무런 문제가 발생하지 않는다.      > 하지만 원자적 연산이 아닌 경우에는 `synchronized` 블럭이나 `Lock` 등을 사용해서 안전한 임계 영역을 만들어야 한다.**<br/><br/><br/># 💡 원자적 연산 예시 코드 - int, volatile, synchronized, AtomicInteger> **원자적이지 않은 연산을 멀티스레드 환경에서 실행하면 문제가 발생할 수 있다!!!**```javapublic interface IncrementInteger {     void increment();     int get();}```- `IncrementInteger` 는 숫자 값을 하나씩 증가시키는 기능을 제공<br/><br/>## ⚡️ <u>**기본적인 int**</u>```javapublic class BasicInteger implements IncrementInteger{    private int value;    @Override    public void increment() {        value++;    }    @Override    public int get() {        return value;    }}```- `value` 값은 `인스턴스의 필드`이기 때문에, 여러 스레드가 공유할 수 있다. - 이렇게 `공유 가능한 자원`에 `++` 와 같은 `원자적이지 않은 연산`을 사용하면 **멀티스레드 상황에 문제가 될 수 있다.**```javapackage thread.cas.increment;import static util.ThreadUtils.sleep;import java.util.ArrayList;import java.util.List;public class IncrementThreadMain {    public static final int THREAD_COUNT = 1000;    public static void main(String[] args) throws InterruptedException {        test(new BasicInteger());//        test(new VolatileInteger());//        test(new SyncInteger());//        test(new MyAtomicInteger());//        test(new ReentrantLockInteger());    }    private static void test(IncrementInteger incrementInteger) throws InterruptedException {        Runnable runnable = new Runnable() {            @Override            public void run() {                sleep(50); //너무 빨리 실행되기 때문에, 다른 스레드와 동시 실행을 위해 잠깐 쉬었다가 실행                incrementInteger.increment();            }        };        List<Thread> threads = new ArrayList<>();        for (int i = 0; i < THREAD_COUNT; i++) {            Thread thread = new Thread(runnable);            threads.add(thread);            thread.start();        }        for (Thread thread : threads) {            thread.join();        }        int result = incrementInteger.get();        System.out.println(incrementInteger.getClass().getSimpleName() + " result:" + result);    }}```<br/><br/>## ⚡️ <u>**volatile**</u>```javapackage thread.cas.increment;public class VolatileInteger implements IncrementInteger{    private volatile int value;    @Override    public void increment() {        value++;    }    @Override    public int get() {        return value;    }}```- `volatile` 은 여러 CPU 사이에 발생하는 캐시 메모리와 메인 메모리가 동기화 되지 않는 문제를 해결할 뿐이다.- 캐시 메모리가 영향을 줄 수는 있지만, 캐시 메모리를 사용하지 않고, 메인 메모리를 직접 사용해도 여전히 발생하는 문제이다. - **이 문제는 연산 자체가 나누어져 있기 때문에 발생한다.**<br/><br/>## ⚡️ <u>**synchronized**</u>```javapublic class SyncInteger implements IncrementInteger{    private int value;    @Override    public synchronized void increment() {        value++;    }    @Override    public synchronized int get() {        return value;    }}```- `synchronized` 를 적용해서 `안전한 임계 영역(critical section)`을 만든다.- `value++;` 연산을 한 번에 하나의 스레드만 실행하도록 보장한다.<br/><br/>## ⚡️ <u>**AtomicInteger - 원자적 연산**</u>```javapublic class MyAtomicInteger implements IncrementInteger{    private AtomicInteger value = new AtomicInteger(0);    @Override    public void increment() {        value.incrementAndGet();    }    @Override    public int get() {        return value.get();    }}```- **`AtomicInteger` 는 멀티스레드 상황에 안전하고 또 다양한 값 증가, 감소 연산을 제공한다.** - 특정 값을 증가하거나 감소해야 하는데 여러 스레드가 해당 값을 공유해야 한다면, `AtomicInteger` 를 사용하면 된다.<br/><br/>## ⚡️ 성능 테스트```> Task :IncrementPerformanceMain.main()BasicInteger: ms=5VolatileInteger: ms=179SyncInteger: ms=357MyAtomicInteger: ms=190ReentrantLockInteger: ms=499```### 🔋 **BasicInteger** - **가장 빠르다.**- ***`CPU 캐시`를 적극 사용한다. CPU 캐시의 위력을 알 수 있다.***- 안전한 임계 영역도 없고, `volatile` 도 사용하지 않기 때문에 멀티스레드 상황에는 사용할 수 없다. - 단일 스레드가 사용하는 경우에 효율적이다.### 🔋 **VolatileInteger**- **`volatile` 을 사용해서 CPU 캐시를 사용하지 않고 `메인 메모리를 사용`한다.**- 안전한 임계 영역이 없기 때문에 **멀티스레드 상황에는 사용할 수 없다.**- 단일 스레드가 사용하기에는 `BasicInteger` 보다 느리다. 그리고 멀티스레드 상황에도 안전하지 않다.### 🔋 **SyncInteger**- `synchronized` 를 사용한 `안전한 임계 영역`이 있기 때문에 **멀티스레드 상황에도 안전하게 사용할 수 있다.** - `MyAtomicInteger` 보다 성능이 느리다.### 🔋 **MyAtomicInteger**- 자바가 제공하는 `AtomicInteger` 를 사용한다. 멀티스레드 상황에 안전하게 사용할 수 있다. - **성능도 `synchronized` , `Lock(ReentrantLock)` 을 사용하는 경우보다 `1.5 ~ 2배 정도 빠르다.`**> ***`AtomicInteger` 가 제공하는 `incrementAndGet()` 메서드는 `락(lock)을 사용하지 않고`, 원자적 연산을 만들어낸다.***<br/><br/><br/># 💡 CAS 연산 - Compare And Swap`락(lock)`은- 특정 자원을 보호하기 위해 스레드가 해당 자원에 대한 접근하는 것을 제한한다.- 락이 걸려 있는 동안 **다른 스레드들**은 `해당 자원에 접근할 수 없고`, `락이 해제될 때까지 대기`해야 한다.1. 락이 있는지 확인한다.2. 락을 획득하고 임계 영역에 들어간다.3. 작업을 수행한다.4. 락을 반납한다.> `락(lock)`은 **10000번의 연산이 있다면 모두 위와 같은 과정을 반복해야 하기 때문에, 락을 사용하는 방식은 직관적이지만 상대적으로 무거운 방식이다.**---<u>**`CAS(Compare-And-Swap, Compare-And-Set)` 연산**</u>은- **락을 걸지 않고 원자적인 연산**을 수행할 수 있는 방법      - 락 프리(lock-free) 기법- CAS 연산은 락을 완전히 대체하는 것은 아니고, **작은 단위의 일부 영역에 적용**할 수 있다. - **기본은 락을 사용하고, 특별한 경우에 CAS를 적용할 수 있다고 생각하면 된다.**`AtomicInteger atomicInteger = new AtomicInteger(0);`     `atomicInteger.compareAndSet(0, 1);`- 만약 `atomicInteger` 의 값이 현재 0이라면 `atomicInteger` 의 값은 1로 변경된다. 이 경우 `true` 를 반환 한다.- 만약 `atomicInteger` 의 값이 현재 0이 아니라면 `atomicInteger` 의 값은 변경되지 않는다. 이 경우 `false` 를 반환한다.-  **이 메서드는 원자적으로 실행**된다는 점이다. - 이 메서드가 제공하는 기능이 바로 `CAS(compareAndSet) 연산`이다.<br/>## ⚡️ CAS 실행 순서 분석<img width="500" alt="스크린샷 2024-09-12 오후 11 37 34" src="https://github.com/user-attachments/assets/20e3c268-8cd5-491b-93f9-458cf994e8fc">**이 명령어는 2개로 나누어진 명령어이다. 따라서 원자적이지 않은 연산처럼 보인다.**    1. 먼저 메인 메모리에 있는 값을 확인한다.2. 해당 값이 기대하는 값(0)이라면 원하는 값(1)으로 변경한다.> <u>**CPU 하드웨어의 지원**</u>: CPU 하드웨어 차원에서 **특별하게 하나의 원자적인 연산으로 묶어서 제공**하는 기능이다.- ***`CPU`는 두 과정을 하나의 원자적인 명령으로 만들기 위해 1번과 2번 사이에 다른 스레드가 `x001` 의 값을 변경하지 못하게 막는다.***- 1번과 2번 사이의 시간은 CPU 입장에서 보면 **아주 잠깐 찰나의 순간**이다. **그래서 성능에 큰 영향을 끼치지 않는다.**