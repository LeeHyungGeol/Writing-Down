# CAS - 동기화와 원자적 연산<br/>## 목차- **원자적 연산**- **원자적 연산 예시 코드 - int, volatile, synchronized, AtomicInteger**- **CAS 연산 - Compare And Swap**- **CAS 락 구현**- **CAS 정리**- **실무 관점**<br/><br/><br/># 💡 원자적 연산> **원자적 연산**(`atomic operation`): **해당 연산이 더 이상 나눌 수 없는 단위로 수행된다**는 것을 의미`i = 1;`- 위의 연산은 둘로 쪼갤 수 없는 `원자적 연산`이다.- **단 하나의 순서로 실행되기 때문이다.**`i = i + 1;`- 위의 연산은 **`원자적 연산`이 아니다.**1. 오른쪽에 있는 `i` 의 값을 읽는다. `i` 의 값은 1 이다.2. 읽은 1에 1을 더해서 2를 만든다.3. 더한 2을 왼쪽의 `i` 변수에 대입한다.`i++;`- **원자적 연산이 아니다.**- `i = i + 1` 을 축약한 것> **원자적 연산은 멀티스레드 상황에서 아무런 문제가 발생하지 않는다.      > 하지만 원자적 연산이 아닌 경우에는 `synchronized` 블럭이나 `Lock` 등을 사용해서 안전한 임계 영역을 만들어야 한다.**<br/><br/><br/># 💡 원자적 연산 예시 코드 - int, volatile, synchronized, AtomicInteger> **원자적이지 않은 연산을 멀티스레드 환경에서 실행하면 문제가 발생할 수 있다!!!**```javapublic interface IncrementInteger {     void increment();     int get();}```- `IncrementInteger` 는 숫자 값을 하나씩 증가시키는 기능을 제공<br/><br/>## ⚡️ <u>**기본적인 int**</u>```javapublic class BasicInteger implements IncrementInteger{    private int value;    @Override    public void increment() {        value++;    }    @Override    public int get() {        return value;    }}```- `value` 값은 `인스턴스의 필드`이기 때문에, 여러 스레드가 공유할 수 있다. - 이렇게 `공유 가능한 자원`에 `++` 와 같은 `원자적이지 않은 연산`을 사용하면 **멀티스레드 상황에 문제가 될 수 있다.**```javapackage thread.cas.increment;import static util.ThreadUtils.sleep;import java.util.ArrayList;import java.util.List;public class IncrementThreadMain {    public static final int THREAD_COUNT = 1000;    public static void main(String[] args) throws InterruptedException {        test(new BasicInteger());//        test(new VolatileInteger());//        test(new SyncInteger());//        test(new MyAtomicInteger());//        test(new ReentrantLockInteger());    }    private static void test(IncrementInteger incrementInteger) throws InterruptedException {        Runnable runnable = new Runnable() {            @Override            public void run() {                sleep(50); //너무 빨리 실행되기 때문에, 다른 스레드와 동시 실행을 위해 잠깐 쉬었다가 실행                incrementInteger.increment();            }        };        List<Thread> threads = new ArrayList<>();        for (int i = 0; i < THREAD_COUNT; i++) {            Thread thread = new Thread(runnable);            threads.add(thread);            thread.start();        }        for (Thread thread : threads) {            thread.join();        }        int result = incrementInteger.get();        System.out.println(incrementInteger.getClass().getSimpleName() + " result:" + result);    }}```<br/><br/>## ⚡️ <u>**volatile**</u>```javapackage thread.cas.increment;public class VolatileInteger implements IncrementInteger{    private volatile int value;    @Override    public void increment() {        value++;    }    @Override    public int get() {        return value;    }}```- `volatile` 은 여러 CPU 사이에 발생하는 캐시 메모리와 메인 메모리가 동기화 되지 않는 문제를 해결할 뿐이다.- 캐시 메모리가 영향을 줄 수는 있지만, 캐시 메모리를 사용하지 않고, 메인 메모리를 직접 사용해도 여전히 발생하는 문제이다. - **이 문제는 연산 자체가 나누어져 있기 때문에 발생한다.**<br/><br/>## ⚡️ <u>**synchronized**</u>```javapublic class SyncInteger implements IncrementInteger{    private int value;    @Override    public synchronized void increment() {        value++;    }    @Override    public synchronized int get() {        return value;    }}```- `synchronized` 를 적용해서 `안전한 임계 영역(critical section)`을 만든다.- `value++;` 연산을 한 번에 하나의 스레드만 실행하도록 보장한다.<br/><br/>## ⚡️ <u>**AtomicInteger - 원자적 연산**</u>```javapublic class MyAtomicInteger implements IncrementInteger{    private AtomicInteger value = new AtomicInteger(0);    @Override    public void increment() {        value.incrementAndGet();    }    @Override    public int get() {        return value.get();    }}```- **`AtomicInteger` 는 멀티스레드 상황에 안전하고 또 다양한 값 증가, 감소 연산을 제공한다.** - 특정 값을 증가하거나 감소해야 하는데 여러 스레드가 해당 값을 공유해야 한다면, `AtomicInteger` 를 사용하면 된다.<br/><br/>## ⚡️ 성능 테스트```> Task :IncrementPerformanceMain.main()BasicInteger: ms=5VolatileInteger: ms=179SyncInteger: ms=357MyAtomicInteger: ms=190ReentrantLockInteger: ms=499```### 🔋 **BasicInteger** - **가장 빠르다.**- ***`CPU 캐시`를 적극 사용한다. CPU 캐시의 위력을 알 수 있다.***- 안전한 임계 영역도 없고, `volatile` 도 사용하지 않기 때문에 멀티스레드 상황에는 사용할 수 없다. - 단일 스레드가 사용하는 경우에 효율적이다.### 🔋 **VolatileInteger**- **`volatile` 을 사용해서 CPU 캐시를 사용하지 않고 `메인 메모리를 사용`한다.**- 안전한 임계 영역이 없기 때문에 **멀티스레드 상황에는 사용할 수 없다.**- 단일 스레드가 사용하기에는 `BasicInteger` 보다 느리다. 그리고 멀티스레드 상황에도 안전하지 않다.### 🔋 **SyncInteger**- `synchronized` 를 사용한 `안전한 임계 영역`이 있기 때문에 **멀티스레드 상황에도 안전하게 사용할 수 있다.** - `MyAtomicInteger` 보다 성능이 느리다.### 🔋 **MyAtomicInteger**- 자바가 제공하는 `AtomicInteger` 를 사용한다. 멀티스레드 상황에 안전하게 사용할 수 있다. - **성능도 `synchronized` , `Lock(ReentrantLock)` 을 사용하는 경우보다 `1.5 ~ 2배 정도 빠르다.`**> ***`AtomicInteger` 가 제공하는 `incrementAndGet()` 메서드는 `락(lock)을 사용하지 않고`, 원자적 연산을 만들어낸다.***<br/><br/><br/># 💡 CAS 연산 - Compare And Swap`락(lock)`은- 특정 자원을 보호하기 위해 스레드가 해당 자원에 대한 접근하는 것을 제한한다.- 락이 걸려 있는 동안 **다른 스레드들**은 `해당 자원에 접근할 수 없고`, `락이 해제될 때까지 대기`해야 한다.1. 락이 있는지 확인한다.2. 락을 획득하고 임계 영역에 들어간다.3. 작업을 수행한다.4. 락을 반납한다.> `락(lock)`은 **10000번의 연산이 있다면 모두 위와 같은 과정을 반복해야 하기 때문에, 락을 사용하는 방식은 직관적이지만 상대적으로 무거운 방식이다.**---<u>**`CAS(Compare-And-Swap, Compare-And-Set)` 연산**</u>은- **락을 걸지 않고 원자적인 연산**을 수행할 수 있는 방법      - `락 프리(lock-free)` 기법- CAS 연산은 락을 완전히 대체하는 것은 아니고, **작은 단위의 일부 영역에 적용**할 수 있다. > CAS 는 lock 을 완전히 대체하는 것은 아니다. **기본적으로는 lock 을 사용하는데**, 근데 굉장히 작은 일부 특수한 영역에 CAS 연산을 사용할 수 있다.`AtomicInteger atomicInteger = new AtomicInteger(0);`     `atomicInteger.compareAndSet(0, 1);`- 만약 `atomicInteger` 의 값이 현재 0이라면 `atomicInteger` 의 값은 1로 변경된다. 이 경우 `true` 를 반환 한다.- 만약 `atomicInteger` 의 값이 현재 0이 아니라면 `atomicInteger` 의 값은 변경되지 않는다. 이 경우 `false` 를 반환한다.-  **이 메서드는 원자적으로 실행**된다는 점이다. - 이 메서드가 제공하는 기능이 바로 `CAS(compareAndSet) 연산`이다.<br/>## ⚡️ CAS 실행 순서 분석<img width="500" alt="스크린샷 2024-09-12 오후 11 37 34" src="https://github.com/user-attachments/assets/20e3c268-8cd5-491b-93f9-458cf994e8fc">**이 명령어는 2개로 나누어진 명령어이다. 따라서 원자적이지 않은 연산처럼 보인다.**    1. 먼저 메인 메모리에 있는 값을 확인한다.2. 해당 값이 기대하는 값(0)이라면 원하는 값(1)으로 변경한다.> <u>**CPU 하드웨어의 지원**</u>: CPU 하드웨어 차원에서 **특별하게 하나의 원자적인 연산으로 묶어서 제공**하는 기능이다.- ***`CPU`는 두 과정을 하나의 원자적인 명령으로 만들기 위해 1번과 2번 사이에 다른 스레드가 `x001` 의 값을 변경하지 못하게 막는다.***- 1번과 2번 사이의 시간은 CPU 입장에서 보면 **아주 잠깐 찰나의 순간**이다. **그래서 성능에 큰 영향을 끼치지 않는다.****`CPU`는 1초에 수억번 연산을 하기 때문에, CPU 입장에서는 찰나의 순간이다.**<br/><br/>## ⚡️ CAS 연산(incrementAndGet) 구현```javapublic class CasMainV3 {    private static final int THREAD_COUNT = 100;    public static void main(String[] args) throws InterruptedException {        AtomicInteger atomicInteger = new AtomicInteger();        System.out.println("start value = " + atomicInteger.get());        Runnable runnable = new Runnable() {            @Override            public void run() {                incrementAndGet(atomicInteger);            }        };        List<Thread> threads = new ArrayList<>();        for (int i = 0; i < THREAD_COUNT; i++) {            Thread thread = new Thread(runnable);            threads.add(thread);            thread.start();        }        for (Thread thread : threads) {            thread.join();        }        int result = atomicInteger.get();        System.out.println(atomicInteger.getClass().getSimpleName() + " resultValue: " + result);    }    private static int incrementAndGet(AtomicInteger atomicInteger) {        int getValue;        boolean result;        do {            getValue = atomicInteger.get();            sleep(100); // 스레드 동시 실행을 위한 대기            log("getValue: " + getValue);            result = atomicInteger.compareAndSet(getValue, getValue + 1);            log("result: " + result);        } while (!result);        return getValue + 1;//        return atomicInteger.get();    }}``````> Task :CasMainV3.main()start value = 014:44:22.765 [ Thread-0] getValue: 014:44:22.765 [ Thread-1] getValue: 014:44:22.767 [ Thread-0] result: true14:44:22.767 [ Thread-1] result: false14:44:22.870 [ Thread-1] getValue: 114:44:22.870 [ Thread-1] result: trueAtomicInteger resultValue: 2```---### 🔋 Thread-0 실행```14:44:22.765 [ Thread-0] getValue: 014:44:22.767 [ Thread-0] result: true```- `atomicInteger.get();` 를 통해 현재 값인 0을 가져온다. -> getValue 는 0이다.- `compareAndSet(getValue, getValue + 1);` 를 통해 0에서 1로 변경한다.- **CAS 연산이 성공했으므로 `value` 값은 0에서 1로 증가하고 `true` 를 반환한다.**- `do~while` 문을 빠져나간다.---### 🔋 Thread-1 실행```//[Thread-1] do~while 첫 번째 시도14:44:22.765 [ Thread-1] getValue: 014:44:22.767 [ Thread-1] result: false//[Thread-1] do~while 두 번째 시도14:44:22.870 [ Thread-1] getValue: 114:44:22.870 [ Thread-1] result: true```- `atomicInteger.get();` 를 통해 현재 값인 0을 가져온다. -> getValue 는 0이다.- 그런데 `compareAndSet(0,1)` 연산은 실패한다. - **CAS 연산에서 현재 `value` 값으로 0을 기대했지만 `Thread-1` 이 중간에 먼저 실행되면서 `value` 의 값을 `0 -> 1`로 변경해버렸다.** - **CAS 연산이 실패했으므로 `value` 값은 변경하지 않고, `false` 를 반환한다.**- **2번째 시도에서는 값을 1에서 2로 증가하고 true 를 반환한다.**- `do~while` 문을 빠져나간다.---## ⚡️ CAS 연산(incrementAndGet) 정리> `CAS`를 사용하면 락을 사용하지 않지만, 대신에 다른 스레드가 값을 먼저 증가해서 ***문제가 발생하는 경우 루프를 돌며 재시도를 하는 방식***을 사용한다.- 두 스레드가 동시에 실행되면서 문제가 발생하는 상황을 스레드가 충돌했다고 표현- 충돌이 발생할 때마다 반복해서 다시 시도 -> 락 없이 데이터를 안전하게 변경- **충돌이 드물게 발생하는 환경에서는 락을 사용하지 않으므로 높은 성능을 발휘**- 스레드가 락을 획득하기 위해 대기하지 않기 때문에 **대기 시간과 오버헤드가 줄어드는 장점**<u>**그러나**</u> ***`충돌이 빈번하게 발생하는 환경`에서는 성능에 문제가 될 수 있다.***    여러 스레드가 자주 동시에 동일한 변수의 값을 변경하려고 시도할 때, `CAS`는 **자주 실패하고 재시도해야 하므로 성능 저하가 발생할 수 있다.**     이런 상황에서는 반복 문을 계속 돌기 때문에 ***CPU 자원을 많이 소모하게 된다.***---### 🔋 **CAS(Compare-And-Swap)와 락(Lock) 방식의 비교**<u>**`락(Lock)` 방식**</u>- **비관적(pessimistic) 접근법**- **데이터에 접근하기 전에 항상 락을 획득** - 다른 스레드의 접근을 막음- `"다른 스레드가 방해할 것이다"`라고 가정<u>**`CAS(Compare-And-Swap)` 방식**</u> - **낙관적(optimistic) 접근법** - **락을 사용하지 않고 데이터에 바로 접근** - 충돌이 발생하면 그때 재시도- `"대부분의 경우 충돌이 없을 것이다"`라고 가정> **사실 간단한 CPU 연산은 너무 빨리 처리되기 때문에 충돌이 자주 발생하지 않는다.**    > 충돌이 발생하기도 전에 이미 연산을 완료하는 경우가 더 많다.     > ***간단한 `CPU 연산`에는 락 보다는 `CAS`를 사용하는 것이 효과적이다.***> CAS 의 핵심은 내가 읽은 값을 변경하지 않았을 경우에만 값을 바꾸는 것이다.    > 내가 읽은 값을 내가 바꿀 때 까지 유지되도록 하는 것이 CAS 연산의 핵심인 것이다.      > 락을 안걸고 그걸 확인이 가능한 것이다.<br/><br/><br/># 💡 CAS 락 구현> **`CAS`는 락을 구현하는데 사용할 수도 있다.**---## ⚡️ CAS 락 구현 - Bad(잘못된 구현)```javapublic class SpinLockBad {    private volatile boolean lock = false;    public void lock() {        log("락 획득 시도");        while (true) {            if (!lock) { // 1. 락 사용 여부 확인                sleep(100); // 문제 상황 확인용, 스레드 대기                lock = true; // 2. 락의 값 변경                break; // while 탈출            } else {                // 락을 획득할 때 까지 스핀 대기(바쁜 대기) 한다.                log("락 획득 실패 - 스핀 대기");            }        }        log("락 획득 완료");    }    public void unlock() {        lock = false;        log("락 반납 완료");    }}``````javapublic class SpinLockMain {    public static void main(String[] args) {        SpinLockBad spinLock = new SpinLockBad();        Runnable task = new Runnable() {            @Override            public void run() {                spinLock.lock();                try {                    // critical section                    log("비즈니스 로직 실행");//                    sleep(1); // 오래 걸리는 로직에서 스핀 락 사용X                } finally {                    spinLock.unlock();                }            }        };        Thread t1 = new Thread(task, "Thread-1");        Thread t2 = new Thread(task, "Thread-2");        t1.start();        t2.start();    }}``````> Task :SpinLockMain.main()15:25:29.489 [ Thread-1] 락 획득 시도15:25:29.489 [ Thread-2] 락 획득 시도15:25:29.592 [ Thread-2] 락 획득 완료15:25:29.592 [ Thread-1] 락 획득 완료15:25:29.592 [ Thread-2] 비즈니스 로직 실행15:25:29.592 [ Thread-1] 비즈니스 로직 실행15:25:29.592 [ Thread-2] 락 반납 완료15:25:29.593 [ Thread-1] 락 반납 완료```- 실행 결과를 보면 **기대와는 다르게** `Thread-1` , `Thread-2` **둘다 동시에 락을 획득하고 비즈니스 로직을 동시에 수행해버린다.** - ***스레드 둘이 동시에 수행되기 때문에 문제가 발생했다.***바로 다음 <u>**두 부분이 원자적이지 않다는 문제**</u>가 있다.- **1. 락 사용 여부 확인** - **2. 락의 값 변경*****`CAS 연산`을 사용하여 `두 연산을 하나로 묶어서 하나의 원자적인 연산`으로 처리하여 해결할 수 있다!!!***- 락의 사용 여부를 확인하고, 그 값이 기대하는 값과 같다면 변경하는 것- 물론, `synchronized`, `Lock` 을 이용하여 두 코드를 동기화해서 안전한 임계 영역으로 만들어서 해결할 수도 있다.---<br/><br/>## ⚡️ CAS 락 구현 - SpinLock```javapublic class SpinLock {    private final AtomicBoolean lock = new AtomicBoolean(); // 기본값이 false    public void lock() {        log("락 획득 시도");        while (!lock.compareAndSet(false, true)) {            // 락을 획득할 때 까지 스핀 대기(바쁜 대기) 한다.            log("락 획득 실패 - 스핀 대기");        }        log("락 획득 완료");    }    public void unlock() {        lock.set(false);        log("락 반납 완료");    }}``````> Task :SpinLockMain.main()15:36:00.837 [ Thread-2] 락 획득 시도15:36:00.837 [ Thread-1] 락 획득 시도15:36:00.838 [ Thread-2] 락 획득 완료15:36:00.838 [ Thread-1] 락 획득 실패 - 스핀 대기15:36:00.839 [ Thread-2] 비즈니스 로직 실행15:36:00.839 [ Thread-1] 락 획득 실패 - 스핀 대기15:36:00.839 [ Thread-2] 락 반납 완료15:36:00.839 [ Thread-1] 락 획득 완료15:36:00.839 [ Thread-1] 비즈니스 로직 실행15:36:00.839 [ Thread-1] 락 반납 완료```중간에 다른 스레드가 `lock` 의 값을 `true` 로 변경하면 안된다.   **그러면 여러 스레드가 임계 영역을 통과하는 동시성 문제가 발생한다.**<u>***`CAS 연산`은 이 `두 연산`을 `하나의 원자적인 연산`으로 만들어준다.***</u> `lock.compareAndSet(false, true)`- **1. 락 사용 여부 확인**: `lock` 의 값이 `false` 이면 - **2. 락의 값 변경**: `lock` 의 값을 `true` 로 변경해라.---**`CAS 연산` 덕분에 원자적이지 않은 `두 연산`을 다음과 같이 `하나의 원자적인 연산`으로 바꿀 수 있었다.**> ***1. 락을 사용하지 않는다면 락의 값을 변경***- **CAS를 활용한 락 방식은 사실 락이 없다. 단순히 while문을 반복할 뿐이다. 따라서 대기하는 스레드도 `RUNNABLE` 상태를 유지하면서 가볍고 빠르게 작동할 수 있다.**- 반면에, 동기화 락을 사용하는 경우는 스레드가 락을 획득하지 못하면, `BLOCKED`, `WAITING` 상태로 변하여 대기하고 다시 스레드를 깨워야 하는 과정이 필요하기 때문에, 상대적으로 무겁고 성능이 느릴 수 있다.<br/><br/><br/># 💡 CAS 정리## ⚡️ CAS 단점이 방식은 락을 기다리는 스레드가 `BLOCKED` , `WAITING` 상태로 빠지지는 않지만, **`RUNNABLE` 상태로 락을 획득할 때 까지 while문을 반복하는 문제가 있다.**     ***따라서 락을 기다리는 스레드가 `CPU를 계속 사용하면서 대기`하는 것이다!***그래서 동기화 락을 사용하는 방식보다 스레드를 `RUNNABLE` 로 살려둔 상태에서 계속 락 획득을 반복 체크하는 것이 더 효율적인 경우에 이런 방식을 사용해야 한다.> ***연산이 길지 않고 매우매우매우! 짧게 끝날 때 사용해야 한다.***      > 예를 들어 `숫자 값의 증가`, `자료 구조의 데이터 추가`와 같이 **CPU 사이클이 금방 끝나는 연산**에 사용하면 효과적이다.<u>**반면에**</u>      **데이터베이스의 결과를 대기한다거나, 다른 서버의 요청을 기다린다거나 하는 것 처럼 오래 기다리는 작업에 사용하면**      **CPU를 계속 사용하며 기다리는 `최악의 결과`가 나올 수도 있다.**<br/><br/>## ⚡️ 스핀 락(Spin Lock)> 스레드가 락을 획득 할 때 까지 대기하는 것을 `스핀 대기(spin-wait)` 또는 `CPU 자원`을 계속 사용하면서 바쁘게 대기한다고 해서 `바쁜 대기(busy-wait)`- **이런 스핀 락 방식은 아주 짧은 CPU 연산을 수행할 때 사용해야 효율적이다.** - **잘못 사용하면 오히려 CPU 자원을 더 많 이 사용할 수 있다.**<br/><br/>## ⚡️ 락 VS CAS 사용 방식### 🔋 **CAS의 장점**1. **낙관적 동기화**: 락을 걸지 않고도 값을 안전하게 업데이트할 수 있다.    - **`CAS`는 충돌이 자주 발생하지 않을 것이라고 가정한다.** 이는 충돌이 적은 환경에서 높은 성능을 발휘한다.2. **락 프리(Lock-Free)**: CAS는 락을 사용하지 않기 때문에, 락을 획득하기 위해 대기하는 시간이 없다.    - 따라서 스레드가 블로킹되지 않으며, 병렬 처리가 더 효율적일 수 있다.### 🔋 **CAS의 단점**1. **충돌이 빈번한 경우**: **여러 스레드가 동시에 동일한 변수에 접근하여 업데이트를 시도할 때 충돌이 발생할 수 있다.**     - 충돌이 발생하면 CAS는 루프를 돌며 재시도해야 하며, ***이에 따라 CPU 자원을 계속 소모할 수 있다.***     - **반복적인 재시도로 인해 오버헤드가 발생할 수 있다.**2. **스핀락과 유사한 오버헤드**: **CAS는 충돌 시 반복적인 재시도**를 하므로, 이 과정이 계속 반복되면 스핀락과 유사한 성능 저하가 발생할 수 있다.    - **특히 충돌 빈도가 높을수록 이런 현상이 두드러진다.**---### 🔋 **동기화 락의 장점**1. **충돌 관리**: 락을 사용하면 하나의 스레드만 리소스에 접근할 수 있으므로 충돌이 발생하지 않는다. 여러 스레드가 경쟁할 경우에도 안정적으로 동작한다.2. **안정성**: 복잡한 상황에서도 락은 일관성 있는 동작을 보장한다.3. **스레드 대기**: ***락을 대기하는 스레드는 `CPU`를 거의 사용하지 않는다.***### 🔋 **동기화 락의 단점**1. **락 획득 대기 시간**: 스레드가 락을 획득하기 위해 대기해야 하므로, ***대기 시간이 길어질 수 있다.***2. **컨텍스트 스위칭 오버헤드**: 락을 사용하면, 락 획득을 대기하는 시점과 또 락을 획득하는 시점에 스레드의 상태가 변경된다.    - ***이때 컨텍스트 스위칭이 발생할 수 있으며, 이로 인해 오버헤드가 증가할 수 있다.***그러나 `CAS` 의 경우 스레드가 계속 `RUNNABLE` 상태로 while 문을 반복해서 도는 것이기 때문에, `RUNNABLE` 상태로 유지가 되는 것은 **`컨텍스트 스위칭 비용`이 발생하지 않는다.**<br/><br/><br/># 💡 실무 관점> `실무 관점`에서 보면 **대부분의 애플리케이션들은 공유 자원을 사용할 때**, ***충돌할 가능성 보다 충돌하지 않을 가능성이 훨씬 높다.***여러 스레드에서 발생하는 주문 수를 실시간으로 증가하면서 카운트 한다고 가정해보자. 그리고 특정 피크시간에 주문이 100만건 들어오는 서비스라고 가정해보자.      특정 피크 시간에 **주문이 1시간에 100만건 정도**이면, **우리나라의 탑급 서비스** 정도의 수준이다.- `1,000,000 / 60분 = 1분에 16,666건, 1초에 277건`> CPU 는 1초에 수십억 건의 연산이 일어난다.백만 건 중에 충돌이 나는 경우는 아주 넉넉하게 해도 몇십건 이하일 것이다.   **따라서 단순한 주문 수 증가와 같은 경우는 락보다는 `CAS` 처럼 낙관적인 방식이 더 나은 성능을 보인다.**> 여기서 `중요한 핵심`은 주문 수 증가와 같은 `단순한 연산`이라는 점이다.> 반면에 데이터베이스를 기다린다거나, 다른 서버의 요청을 기다리는 것 처럼 수 밀리초 이상의 시간이 걸리는 작업이라면 CAS를 사용하는 것 보다 ***`동기화 락`을 사용하거나 스레드가 대기하는 방식이 더 효과적이다.***