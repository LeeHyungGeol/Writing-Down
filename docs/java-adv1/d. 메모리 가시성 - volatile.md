# 메모리 가시성<br/>## ⚡️ 목차- volatile, 메모리 가시성- 자바 메모리 모델(Java Memory Model)<br/><br/><br/># 💡 volatile, 메모리 가시성**<u>실제 메모리의 접근 방식</u>**- `CPU`는 처리 성능을 개선하기 위해 중간에 `캐시 메모리`라는 것을 사용한다.```javapublic class VolatileFlagMain {    public static void main(String[] args) {        MyTask task = new MyTask();        Thread thread = new Thread(task, "work");        log("runFlag = " + task.runFlag);        thread.start();        sleep(1000);        log("runFlag 를 false 로 변경");        task.runFlag = false;        log("runFlag = " + task.runFlag);        log("main 종료");    }    static class MyTask implements Runnable {        boolean runFlag = true;//        volatile boolean runFlag = true;        @Override        public void run() {            log("task 시작");            while (runFlag) {                // runFlag 가 false 로 변하면 탈출            }            log("task 종료");        }    }}```<img width="500" alt="스크린샷 2024-09-05 오후 7 48 14" src="https://github.com/user-attachments/assets/8deb91fc-54ae-4028-8c57-83eec20261f9">- `메인 메모리`는 CPU 입장에서 보면 거리도 멀고, 속도도 상대적으로 느리다. 대신에 상대적으로 가격이 저렴해서 큰 용량을 쉽게 구성할 수 있다.- CPU 연산은 매우 빠르기 때문에 CPU 연산의 빠른 성능을 따라가려면, CPU 가까이에 매우 빠른 메모리가 필요 한데, 이것이 바로 `캐시 메모리`이다. 캐시 메모리는 CPU와 가까이 붙어있고, 속도도 매우 빠른 메모리이다. 하지 만 상대적으로 가격이 비싸기 때문에 큰 용량을 구성하기는 어렵다.- 현대의 CPU 대부분은 코어 단위로 캐시 메모리를 각각 보유하고 있다. 참고로 여러 코어가 공유하는 캐시 메모리도 있다.---<img width="500" alt="스크린샷 2024-09-05 오후 8 32 44" src="https://github.com/user-attachments/assets/50eaf2a2-eb33-4724-9b9b-c9fe1e92b85d">1. `main` 스레드는 `runFlag` 를 `false` 로 설정한다.2. 이때 `캐시 메모리`의 `runFlag` 가 `false` 로 설정된다.**여기서 핵심은 캐시 메모리의 runFlag 값만 변한다는 것이다! `메인 메모리`에 이 값이 즉시 반영되지 않는다.**- `work` 스레드가 사용하는 CPU 코어2의 캐시 메모리의 `runFlag` 값은 여전히 `true` 이다.<img width="500" alt="스크린샷 2024-09-05 오후 8 42 16" src="https://github.com/user-attachments/assets/bf947f6c-09cd-4a54-afa1-863a5c156527"><img width="500" alt="스크린샷 2024-09-05 오후 8 53 42" src="https://github.com/user-attachments/assets/3aa9d2c3-3ab4-4a28-ba00-1964aa19b14f"><u>캐시 메모리에 있는 `runFlag` 의 값이 언제 메인 메모리에 반영될까?</u>   - **이 부분에 대한 정답은 `"알 수 없다"`이다.** CPU 설계 방식과 종류의 따라 다르다. 극단적으로 보면 평생 반영되지 않을 수도 있다!<u>메인 메모리에 변경된 `runFlag` 값이 언제 CPU 코어2의 캐시 메모리에 반영될까?</u>- **이 부분에 대한 정답도 `"알 수 없다"`이다.** CPU 설계 방식과 종류의 따라 다르다. 극단적으로 보면 평생 반영되지 않을 수도 있다!**이 부분은 CPU 설계 방식과 실행 환경에 따라 다를 수 있다. 즉시 반영될 수도 있고, 몇 밀리초 후에 될 수도 있고, 몇 초 후에 될 수도 있고, 평생 반영되지 않을 수도 있다.**  ***주로 `컨텍스트 스위칭`이 될 때, 캐시 메모리도 함께 갱신되는데, 이 부분도 환경에 따라 달라질 수 있다.***   - 예를 들어 `Thread.sleep()` 이나 콘솔에 내용을 출력할 때 스레드가 잠시 쉬는데, 이럴 때 컨텍스트 스위칭이 되면서 주로 갱신된다. 하지만 이것이 갱신을 보장하는 것은 아니다.참고로 여러 코어가 쓰는 중간에 또 다른 캐시 메모리도 존재한다.<br/>### 🔋 **<u>메모리 가시성 문제</u>**> **멀티스레드 환경에서 한 스레드가 변경한 값이 다른 스레드에서 언제 보이는지에 대한 문제를 `메모리 가시성 (memory visibility)`이라 한다. 이름 그대로 메모리에 변경한 값이 보이는가, 보이지 않는가의 문제이다.**---```javapublic class VolatileFlagMain {    public static void main(String[] args) {        MyTask task = new MyTask();        Thread thread = new Thread(task, "work");        log("runFlag = " + task.runFlag);        thread.start();        sleep(1000);        log("runFlag 를 false 로 변경");        task.runFlag = false;        log("runFlag = " + task.runFlag);        log("main 종료");    }    static class MyTask implements Runnable {//        boolean runFlag = true;        volatile boolean runFlag = true;        @Override        public void run() {            log("task 시작");            while (runFlag) {                // runFlag 가 false 로 변하면 탈출            }            log("task 종료");        }    }}```캐시 메모리를 사용하면 CPU 처리 성능을 개선할 수 있다. 하지만 때로는 이런 성능 향상보다는, 여러 스레드에서 같은 시점에 정확히 같은 데이터를 보는 것이 더 중요할 수 있다.  해결방안은 아주 단순하다 성능을 약간 포기하는 대신에, 값을 읽을 때, 값을 쓸 때 모두 메인 메모리에 직접 접근하면 된다. 이것이 바로 `volatile` 키워드이다.<img width="500" alt="스크린샷 2024-09-05 오후 9 44 00" src="https://github.com/user-attachments/assets/688fc284-fec0-45da-bdb9-a588d25a0253">***여러 스레드에서 같은 값을 읽고 써야 한다면 `volatile` 키워드를 사용하면 된다. 단 캐시 메모리를 사용할 때 보다 `성능이 느려지는 단점`이 있기 때문에 꼭! 필요한 곳에만 사용하는 것이 좋다.***<br/><br/><br/># 💡 자바 메모리 모델(Java Memory Model)## ⚡️ **Java Memory Model**> **`Java Memory Model(JMM)`은 자바 프로그램이 어떻게 메모리에 접근하고 수정할 수 있는지를 규정하며, 특히 멀티 스레드 프로그래밍에서 `스레드 간의 상호작용`을 정의한다.**   > **JMM에 여러가지 내용이 있지만, 핵심은 `여러 스레드들의 작업 순서를 보장`하는 `happens-before 관계`에 대한 정의다.**## ⚡️ **Happens-before 관계**> `happens-before` 관계는 자바 메모리 모델에서 `스레드 간의 작업 순서`를 정의하는 개념이다.**스레드를 새로 실행할 때, 새로 실행한 스레드는 기존 어떤 작업들에 대한 메모리 데이터를 확인할 수 있어야 한다.**- happens-before 관계는 이름 그대로, 한 동작이 다른 동작보다 먼저 발생함을 보장한다. - happens-before 관계는 스레드 간의 메모리 가시성을 보장하는 규칙이다. - happens-before 관계가 성립하면, 한 스레드의 작업을 다른 스레드에서 볼 수 있게 된다. - **즉, 한 스레드에서 수행한 작업을 다른 스레드가 참조할 때 최신 상태가 보장되는 것이다.**이 규칙을 따르면 프로그래머가 멀티스레드 프로그램을 작성할 때 예상치 못한 동작을 피할 수 있다.> 쉽게 한 줄로, `volatile` 또는 `스레드 동기화 기법(synchronized, ReentrantLock)`을 사용하면 **`메모리 가시성의 문제`가 발생하지 않는다.**