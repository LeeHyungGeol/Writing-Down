# 동기화 - synchronized<br/>## ⚡️ 목치- **동시성 문제**- **임계 영역, 공유 자원**- **synchronized 메서드**- **synchronized 코드 블럭**- **지역 변수의 공유**- **synchronized 정리**<br/><br/><br/># 💡 동시성 문제먼저 예제를 들어서 동시성 문제를 알아보자.```javapublic interface BankAccount {     boolean withdraw(int amount);     int getBalance();}``````javapublic class WithdrawTask implements Runnable {    private BankAccount account;    private int amount;        public WithdrawTask(BankAccount account, int amount) {        this.account = account;        this.amount = amount;    }        @Override    public void run() {        account.withdraw(amount);    }}``````javapublic class BankAccountV1 implements BankAccount {//    private int balance;    volatile private int balance;    public BankAccountV1(int initialBalance) {        this.balance = initialBalance;    }    @Override    public boolean withdraw(int amount) {        log("거래 시작: " + getClass().getSimpleName());        log("[검증 시작] 출금액: " + amount + ", 잔액: " + balance);        if (balance < amount) {            log("[검증 실패] 출금액: " + amount + ", 잔액: " + balance);            return false;        }        log("[검증 완료] 출금액: " + amount + ", 잔액: " + balance);        sleep(1000); // 출금에 걸리는 시간으로 가정        balance = balance - amount;        log("[출금 완료] 출금액: " + amount + ", 변경 잔액: " + balance);        log("거래 종료");        return true;    }    @Override    public int getBalance() {        return balance;    }}``````javapublic class BankMain {    public static void main(String[] args) throws InterruptedException {        BankAccount account = new BankAccountV1(1000);        Thread t1 = new Thread(new WithdrawTask(account, 800), "t1");        Thread t2 = new Thread(new WithdrawTask(account, 800), "t2");        t1.start();        t2.start();        sleep(500);        log("t1 state: " + t1.getState());        log("t2 state: " + t2.getState());        t1.join();        t2.join();        log("최종 잔액: " + account.getBalance());    }}``````22:46:31.386 [       t2] 거래 시작: BankAccountV122:46:31.386 [       t1] 거래 시작: BankAccountV122:46:31.391 [       t2] [검증 시작] 출금액: 800, 잔액: 100022:46:31.391 [       t1] [검증 시작] 출금액: 800, 잔액: 100022:46:31.391 [       t2] [검증 완료] 출금액: 800, 잔액: 100022:46:31.392 [       t1] [검증 완료] 출금액: 800, 잔액: 100022:46:31.870 [     main] t1 state: TIMED_WAITING22:46:31.871 [     main] t2 state: TIMED_WAITING22:46:32.395 [       t2] [출금 완료] 출금액: 800, 변경 잔액: 20022:46:32.395 [       t2] 거래 종료22:46:32.397 [       t1] [출금 완료] 출금액: 800, 변경 잔액: -60022:46:32.397 [       t1] 거래 종료22:46:32.401 [     main] 최종 잔액: -600```- 실행 결과를 보면 기대와는 다르게 `t1` , `t2` 는 각각 800원씩 총 1600원 출금에 성공한다.- 계좌의 잔액는 `-600` 원이 되어있고, 계좌는 예상치 못하게 마이너스 금액이 되어버렸다.- 분명히 계좌를 출금할 때 잔고를 체크하는 로직이 있는데도 불구하고, **왜 이런 문제가 발생했을까?**---<br/><img width="500" alt="스크린샷 2024-09-05 오후 11 04 23" src="https://github.com/user-attachments/assets/5f3ae473-43d6-47a2-bdf3-a4915827f729">- `t1` : 출금 검증 로직을 통과해서 출금을 위해 잠시 대기중이다. 출금에 걸리는 시간으로 생각하자.- `t2` : 검증 로직을 실행한다. 잔액이 출금 금액보다 많은지 확인한다. 잔액 [1000] 이 출금액 [800] 보다 많으므로 통과한다.**바로 이 부분이 문제다! t1이 아직 잔액(balance)를 줄이지 못했기 때문에 t2는 검증 로직에서 현재 잔액을 1000원으로 확인한다.**- 그렇다면 `sleep(1000)` 코드를 빼면 되지 않을까?   이렇게하면 `t1` 이 검증 로직을 통과하고 바로 잔액을 줄일 수 있을 것 같다.  하지만 `t1` 이 검증 로직을 통과하고 `balance = balance - amount` 를 계산하기 직전에 `t2` 가 실행 되면서 검증 로직을 통과할 수도 있다.   `sleep(1000)` 은 단지 이런 문제를 쉽게 확인하기 위해 넣었을 뿐이다.---<br/>### 🔋 t1, t2 동시에 실행 가정```00:58:36.526 [       t2] 거래 시작: BankAccountV100:58:36.526 [       t1] 거래 시작: BankAccountV100:58:36.531 [       t2] [검증 시작] 출금액: 800, 잔액: 100000:58:36.531 [       t1] [검증 시작] 출금액: 800, 잔액: 100000:58:36.531 [       t2] [검증 완료] 출금액: 800, 잔액: 100000:58:36.531 [       t1] [검증 완료] 출금액: 800, 잔액: 100000:58:37.020 [     main] t1 state: TIMED_WAITING00:58:37.020 [     main] t2 state: TIMED_WAITING00:58:37.537 [       t2] [출금 완료] 출금액: 800, 변경 잔액: 20000:58:37.537 [       t1] [출금 완료] 출금액: 800, 변경 잔액: 20000:58:37.538 [       t2] 거래 종료00:58:37.538 [       t1] 거래 종료00:58:37.543 [     main] 최종 잔액: 200```<img width="500" alt="스크린샷 2024-09-06 오후 3 55 42" src="https://github.com/user-attachments/assets/0737cb19-b0bf-4f28-9d2c-294896119bd9">- `t1` 은 800원을 출금하면서, 잔액을 1000원에서 출금 액수인 800원 만큼 차감한다. **이제 잔액은 200원이 된다.**- `t2` 은 800원을 출금하면서, 잔액을 1000원에서 출금 액수인 800원 만큼 차감한다. **이제 잔액은 200원이 된다.**- `t1` , `t2` 가 동시에 실행되기 때문에 둘다 잔액( `balance` )을 확인하는 시점에 잔액은 1000원이다!- `t1` , `t2` 둘다 동시에 계산된 결과를 잔액에 반영하는데, 둘다 계산 결과인 200원을 반영하므로 **최종 잔액은 200 원이 된다.****결과**- `t1` : 800원 출금완료- `t2` : 800원 출금완료- 원래 원금이 1000원이었는데, 최종 잔액는 200원이 된다.<u>**은행 입장에서 보면 총 1600원이 빠져나갔는데, 잔액은 800원만 줄어들었다. 800원이 감쪽같이 어디론가 사라진 것이다!**</u><br/><br/><br/># 💡 임계 영역, 공유 자원***이런 문제가 발생한 근본 원인은 `여러 스레드`가 함께 사용하는 `공유 자원`을 `여러 단계로 나누어 사용`하기 때문이다.***- **1. 검증 단계**: 잔액( `balance` )이 출금액( `amount` ) 보다 많은지 확인한다.- **2. 출금 단계**: 잔액( `balance` )을 출금액( `amount` ) 만큼 줄인다.```출금() {    1. 검증 단계: 잔액(balance) 확인    2. 출금 단계: 잔액(balance) 감소}```<u>**이 로직에는 하나의 큰 가정이 있다.**</u>- 결국 여기서는 내가 사용하는 값이 중간에 변경되지 않을 것이라는 가정이 있다.- 그런데 만약 중간에 다른 스레드가 잔액의 값을 변경한다면, 큰 혼란이 발생한다.<u>**공유 자원**</u>- 여기서 잔액( `balance` )은 여러 스레드가 함께 사용하는 공유 자원이다.<u>**한 번에 하나의 스레드만 실행**</u>  만약 `출금()` 이라는 메서드를 한 번에 하나의 스레드만 실행할 수 있게 제한한다면 어떻게 될까?- 이렇게 하면 공유 자원인 `balance` 를 한 번에 하나의 스레드만 변경할 수 있다.- **더 자세히는 출금을 진행할 때 잔액( `balance` )을 검증하는 단계부터 잔액의 계산을 완료할 때 까지 잔액의 값은 중간에 변하면 안된다.** - **이 검증과 계산 이 두 단계는 한 번에 하나의 스레드만 실행해야 한다. 그래야 잔액(`balance` )이 중간에 변하지 않고, 안전하게 계산을 수행할 수 있다.**<br/>### 🔋 **임계 영역(critical section)**> **여러 스레드가 동시에 접근해서는 안 되는 공유 자원을 접근하거나 수정하는 부분을 의미한다.**    > 예) 공유 변수나 공유 객체를 수정- 출금을 진행할 때 잔액( `balance` )을 검증하는 단계부터 잔액의 계산을 완료할 때 까지가 `임계 영역(critical section)`이다. - 여기서 `balance` 는 여러 스레드가 동시에 접근해서는 안되는 `공유 자원`이다.**임계 영역은 한 번에 하나의 스레드만 접근할 수 있도록 안전하게 보호해야 한다.**     여러가지 방법이 있지만 `자바`는 `synchronized` 키워드를 통해 **아주 간단하게 임계 영역을 보호할 수 있다.**<br/><br/><br/># 💡 synchronized 메서드<details><summary>synchronized 메서드 예시</summary>```javapackage thread.sync;import static util.MyLogger.log;import static util.ThreadUtils.sleep;public class BankAccountV2 implements BankAccount {//    private int balance;    volatile private int balance;    public BankAccountV2(int initialBalance) {        this.balance = initialBalance;    }    @Override    public synchronized boolean withdraw(int amount) {        log("거래 시작: " + getClass().getSimpleName());        log("[검증 시작] 출금액: " + amount + ", 잔액: " + balance);        if (balance < amount) {            log("[검증 실패] 출금액: " + amount + ", 잔액: " + balance);            return false;        }        log("[검증 완료] 출금액: " + amount + ", 잔액: " + balance);        sleep(1000); // 출금에 걸리는 시간으로 가정        balance = balance - amount;        log("[출금 완료] 출금액: " + amount + ", 변경 잔액: " + balance);        log("거래 종료");        return true;    }    @Override    public synchronized int getBalance() {        return balance;    }}```</details>```16:25:52.920 [       t1] 거래 시작: BankAccountV216:25:52.925 [       t1] [검증 시작] 출금액: 800, 잔액: 100016:25:52.925 [       t1] [검증 완료] 출금액: 800, 잔액: 100016:25:53.409 [     main] t1 state: TIMED_WAITING16:25:53.410 [     main] t2 state: BLOCKED16:25:53.932 [       t1] [출금 완료] 출금액: 800, 변경 잔액: 20016:25:53.933 [       t1] 거래 종료16:25:53.934 [       t2] 거래 시작: BankAccountV216:25:53.934 [       t2] [검증 시작] 출금액: 800, 잔액: 20016:25:53.935 [       t2] [검증 실패] 출금액: 800, 잔액: 20016:25:53.941 [     main] 최종 잔액: 200```---<img width="500" alt="스크린샷 2024-09-06 오후 4 26 48" src="https://github.com/user-attachments/assets/81b7b42c-b3fa-4ba2-8f65-07be2dcb826c">> **`모든 객체(인스턴스)`는 내부에 자신만의 락( `lock` )을 가지고 있다.**  `모니터 락(monitor lock)`이라고 부른다.- java 객체가 100개라면 100개 모두 lock 을 가지고 있다.- 객체 내부에 있고 우리가 확인하기는 어렵다.- java 가 기본으로 제공하는 기능이다.- 스레드가 `synchronized` 키워드가 있는 `메서드에 진입`하려면 반드시 **해당 인스턴스의 락이 있어야 한다!** - 여기서는 `BankAccount(x001)` 인스턴스의 `synchronized withdraw()` 메서드를 호출하므로 이 인스턴스의 락이 필요하다.---<img width="500" alt="스크린샷 2024-09-06 오후 4 51 28" src="https://github.com/user-attachments/assets/7b04a152-1587-44ee-a3bc-fff6da07eb6d"><img width="500" alt="스크린샷 2024-09-06 오후 4 52 04" src="https://github.com/user-attachments/assets/f27d650b-ce89-4e89-b84a-4f486ebcaad3">- `synchronized` 메서드를 호출하려면 먼저 해당 인스턴스의 락이 필요하다.- 락이 있으므로 스레드 `t1` 은 `BankAccount(x001)` 인스턴스에 있는 락을 획득한다.- `t2` 도 락 획득을 시도하지만, 락이 없다. 그래서 `t2` 스레드의상태는 `RUNNABLE` `BLOCKED` 상태로변하고,락을획득할때까지무한정대기한다.- `t2` : 인스턴스에 락이 반납되면 **락 획득을 대기하는 스레드는 자동으로 락을 획득**한다. 이때락을획득한스레드는 `BLOCKED` `RUNNABLE` 상태가되고,다시코드를실행한다.---<img width="500" alt="스크린샷 2024-09-06 오후 5 15 56" src="https://github.com/user-attachments/assets/09fb3df4-d23e-4655-96a2-befd5cc9e778">- `t1` : 800원 출금 완료- `t2` : 잔액 부족으로 출금 실패**자바의 `synchronized` 를 사용하면 한 번에 하나의 스레드만 실행하는 안전한 임계 영역 구간을 편리하게 만들 수 있다.**<br/>### 🔋 모니터 락(monitor lock)을 획득하는 순서는 보장되지 않는다.수 많은 스레드가 동시에 호출한다면, 1개의 스레드만 락 을 획득하고 나머지는 모두 `BLOCKED` 상태가 된다.   해당 인스턴스의 락을 기다리는 수 많은 스레드 중에 하나의 스레드만 락을 획득하고, 락을 획득한 스레드만 `BLOCKED` `RUNNABLE` 상태가 된다.> 이때 어떤 순서로 락을 획득하는지는 자바 표준에 정의되어 있지 않다. 따라서 순서를 보장하지 않고, 환경에 따라서 순서가 달라질 수 있다.  > **항상 그런 것은 아니지만. 확률적으로 오래 기다린 스레드가 아무래도 더 빨리 락을 획득할 수 있는 확률이 높다. 보장된 것은 아니다.**<br/><br/><br/># 💡 synchronized 코드 블럭> `synchronized` 의 가장 큰 장점이자 단점은 `한 번에 하나의 스레드만 실행`할 수 있다는 점이다.        여러 스레드가 동시에 실행하지 못하기 때문에, **전체로 보면 성능이 떨어질 수 있다.**      따라서, **꼭! 필요한 곳으로 한정해서 설정해야 한다.*****자바는 이런 문제를 해결하기 위해 `synchronized` 를 메서드 단위가 아니라, `특정 코드 블럭`에 최적화 해서 적용할 수 있는 기능을 제공한다.***<details><summary>synchronized 코드 블럭 코드 예시</summary>```javapackage thread.sync;import static util.MyLogger.log;import static util.ThreadUtils.sleep;public class BankAccountV3 implements BankAccount {//    private int balance;    volatile private int balance;    public BankAccountV3(int initialBalance) {        this.balance = initialBalance;    }    @Override    public boolean withdraw(int amount) {        log("거래 시작: " + getClass().getSimpleName());        synchronized (this) {            // -- 임계 영역 시작 --            log("[검증 시작] 출금액: " + amount + ", 잔액: " + balance);            if (balance < amount) {                log("[검증 실패] 출금액: " + amount + ", 잔액: " + balance);                return false;            }            log("[검증 완료] 출금액: " + amount + ", 잔액: " + balance);            sleep(1000); // 출금에 걸리는 시간으로 가정            balance = balance - amount;            log("[출금 완료] 출금액: " + amount + ", 변경 잔액: " + balance);            // -- 임계 영역 종료 --        }        log("거래 종료");        return true;    }    @Override    public synchronized int getBalance() {        return balance;    }}``````17:30:16.245 [       t1] 거래 시작: BankAccountV317:30:16.245 [       t2] 거래 시작: BankAccountV317:30:16.250 [       t1] [검증 시작] 출금액: 800, 잔액: 100017:30:16.250 [       t1] [검증 완료] 출금액: 800, 잔액: 100017:30:16.736 [     main] t1 state: TIMED_WAITING17:30:16.737 [     main] t2 state: BLOCKED17:30:17.255 [       t1] [출금 완료] 출금액: 800, 변경 잔액: 20017:30:17.256 [       t1] 거래 종료17:30:17.256 [       t2] [검증 시작] 출금액: 800, 잔액: 20017:30:17.257 [       t2] [검증 실패] 출금액: 800, 잔액: 20017:30:17.261 [     main] 최종 잔액: 200```</details>- `synchronized (this)` : 괄호 `()` 안에 들어가는 값은 락을 획득할 인스턴스의 참조이다.- **`synchronized (this)` 에서 `this` 자리에 다른 인스턴스를 넣을 수 있다. 그렇게 되면 `다른 인스턴스의 락`을 쓰게 된다.** - 아주 정교하게 쓸 때는 그렇게 하고, 일반적으로는 this 를 많이 사용한다.- 덕분에 아주 약간이지만 여러 스레드가 동시에 수행되는 부분을 더 늘려서, 전체적으로 성능을 더 향상할 수 있었다. - 지금의 예는 단순히 로그 몇 줄 출력하는 정도이지만, 만약 작업이 오래 수행된다면 큰 성능 차이가 발생할 것이다.<br/><br/><br/># 💡 지역 변수의 공유> **지역 변수는 절대로! 다른 스레드와 공유되지 않는다!**```javapublic class SyncTest2Main {    public static void main(String[] args) throws InterruptedException {        MyCounter myCounter = new MyCounter();        Runnable task = new Runnable() {            @Override            public void run() {                myCounter.count();            }        };        Thread thread1 = new Thread(task, "Thread-1");        Thread thread2 = new Thread(task, "Thread-2");        thread1.start();        thread2.start();    }    static class MyCounter {        public void count() {            int localValue = 0;            for (int i = 0; i < 1000; i++) {                localValue = localValue + 1;            }            log("결과: " + localValue);        }    }}``````> Task :SyncTest2Main.main()17:35:53.219 [ Thread-2] 결과: 100017:35:53.219 [ Thread-1] 결과: 1000```<img width="500" alt="스크린샷 2024-09-06 오후 5 36 28" src="https://github.com/user-attachments/assets/9133b541-a1e0-408d-92f6-2e119b0e187d">- 지역 변수는 스레드의 개별 저장 공간인 스택 영역에 생성된다.- 따라서 **지역 변수는 절대로! 다른 스레드와 공유되지 않는다!**- 여기에 `synchronized` 를 사용하면 아무 이득도 얻을 수 없다. 성능만 느려진다! - 지역 변수를 제외한, 인스턴스의 멤버 변수(필드), 클래스 변수 등은 공유될 수 있다.<br/><br/><br/># 💡 synchronized 정리자바는 처음부터 멀티스레드를 고려하고 나온 언어이다. 그래서 자바 1.0 부터 `synchronized` 같은 동기화 방법을 프로그래밍 언어의 문법에 포함해서 제공한다.## ⚡️ **synchronized 장점**- 프로그래밍 언어에 문법으로 제공- 아주 편리한 사용- **자동 잠금 해제**: `synchronized` 메서드나 블록이 완료되면 자동으로 락을 대기중인 다른 스레드의 잠금이 해제 된다. 개발자가 직접 특정 스레드를 깨우도록 관리해야 한다면, 매우 어렵고 번거로울 것이다.## ⚡️ **synchronized 단점**- **무한 대기**: `BLOCKED` 상태의 스레드는 락이 풀릴 때 까지 무한 대기한다.  - 특정 시간까지만 대기하는 타임아웃X  - 중간에 인터럽트X- **공정성**: 락이 돌아왔을 때 `BLOCKED` 상태의 여러 스레드 중에 어떤 스레드가 락을 획득할 지 알 수 없다. 최악의 경우 특정 스레드가 너무 오랜기간 락을 획득하지 못할 수 있다.> **`synchronized` 의 가장 치명적인 단점은 락을 얻기 위해 `BLOCKED` 상태가 되면 `락을 얻을 때까지 무한 대기`한다는 점이다.**이런 문제를 해결하기 위해 자바 1.5부터 `java.util.concurrent` 라는 동시성 문제 해결을 위한 패키지가 추가된다.  단순하고 편리하게 사용하기에는 `synchronized` 가 좋으므로, 목적에 부합한다면 `synchronized` 를 사용하면 된다.