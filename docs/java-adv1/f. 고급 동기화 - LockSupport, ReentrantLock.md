# 고급 동기화 - LockSupport, ReentrantLock<br/><br/><br/># 💡 LockSupport자바 1.5부터 `java.util.concurrent` 라는 동시성 문제 해결을 위한 라이브러리 패키지가 추가된다.  > `java.util.concurrent` 에는 수 많은 클래스가 있다.   > 그중에서 가장 기본이 되는 `LockSupport` 클래스를 사용해서 `synchronized` 의 가장 큰 단점인 `무한 대기 문제`를 해결할 수 있다.## ⚡️ **LockSupport**- `park()` : 스레드를 `WAITING` 상태로 변경한다.- `parkNanos(nanos)` : 스레드를 나노초 동안만 `TIMED_WAITING` 상태로 변경한다.  - 지정한 나노초가 지나면 `TIMED_WAITING` 상태에서 빠져나오고 `RUNNABLE` 상태로 변경된다.- `unpark(thread)` : `WAITING` 상태의 대상 스레드를 `RUNNABLE` 상태로 변경한다. - `parkNanos(nanos)` : 스레드를 나노초 동안만 `TIMED_WAITING` 상태로 변경한다.   - 지정한 나노초가 지나면 `TIMED_WAITING` 상태에서 빠져나와서 `RUNNABLE` 상태로 변경된다.- `parkUntil(밀리초)`: 특정 에포크(Epoch) 시간에 맞추어 깨어나는 메서드이다. 정확한 미래의 에포크 시점을 지정해야 한다.- 참고로 밀리초 동안만 대기하는 메서드는 없다.`LockSupport.unpark(thread1)` 는 왜 특정 스레드를 지정하는 매개변수가 있을까?- **왜냐하면 실행 중인 스레드는 `LockSupport.park()` 를 호출해서 스스로 대기 상태에 빠질 수 있지만, 대기 상태의 스레드는 자신의 코드를 실행할 수 없기 때문이다. 따라서 외부 스레드의 도움을 받아야 깨어날 수 있다.**`thread.interrupt()`- 스레드에 `interrupt` 를 걸어서 `WAITING` 상태에서 깨울 수 있다.<details><summary>LockSupport 예시 코드</summary>```javapublic class LockSupportMainV1 {    public static void main(String[] args) {        Thread thread1 = new Thread(new ParkTest(), "Thread-1");        thread1.start();        // 잠시 대기하여 Thread-1 이 park 상태에 빠질 시간을 준다.        sleep(100);        log("Thread-1 state: " + thread1.getState());        log("main -> unpark(Thread-1)");//        LockSupport.unpark(thread1); // 1. unpark() 사용        thread1.interrupt(); // 2. interrupt() 사용    }    static class ParkTest implements Runnable {        @Override        public void run() {            log("park 시작");            LockSupport.park();            log("park 종료, state = " + Thread.currentThread().getState());            log("인터럽트 상태: " + Thread.currentThread().isInterrupted());        }    }}```</details><details><summary>LockSupport.parkNanos() 예시 코드</summary>```javapublic class LockSupportMainV2 {    public static void main(String[] args) {        Thread thread1 = new Thread(new ParkTest(), "Thread-1");        thread1.start();        // 잠시 대기하여 Thread-1 이 park 상태에 빠질 시간을 준다.        sleep(100);        log("Thread-1 state: " + thread1.getState());        log("main -> unpark(Thread-1)");//        LockSupport.unpark(thread1); // 1. unpark() 사용//        thread1.interrupt(); // 2. interrupt() 사용    }    static class ParkTest implements Runnable {        @Override        public void run() {            log("park 시작");            LockSupport.parkNanos(2000_000_000); // 2초 TIMED_WAITING            log("park 종료, state = " + Thread.currentThread().getState());            log("인터럽트 상태: " + Thread.currentThread().isInterrupted());        }    }}```</details>## ⚡️ **LockSupport 정리**> `LockSupport` 를 이용하면, `WAITING`, `TIMED_WAITING` 상태로 변경할 수 있고, `interrupt` 를 사용하여 스레드를 깨울 수도 있다.     > 이런 것들을 이용해서 `synchronized` 의 단점인 `무한 대기 문제`를 해결할 수 있다.```javaif (!lock.tryLock(10초)) { // 내부에서 parkNanos() 사용     log("[진입 실패] 너무 오래 대기했습니다.");    return false;}//임계 영역 시작        ...//임계 영역 종료lock.unlock() // 내부에서 unpark() 사용```**하지만,**   이런 기능들 만을 이용하여 직접 구현하기는 매우 어렵다.  - 1개의 스레드만 깨우고, 다른 스레드들을 대기시키고, 어떤 스레드를 깨울지 우선 순위를 결정하고 히는 작업을 구현하는 것은 매우 어렵다.***한마디로 `LockSupport` 는 너무 저수준이다.***  **자바는 `Lock` 인터페이스와 `ReentrantLock` 이라는 구현체로 이런 기능들을 이미 다 구현해 두었다.**<br/><br/><br/># 💡 ReentrantLock- `Lock` 인터페이스는 동시성 프로그래밍에서 쓰이는 안전한 임계 영역을 위한 락을 구현하는데 사용된다.- 대표적인 구현체로 `ReentrantLock` 이 있다.**`Lock` 인터페이스**```javapackage java.util.concurrent.locks;public interface Lock {  void lock();  void lockInterruptibly() throws InterruptedException;  boolean tryLock();  boolean tryLock(long time, TimeUnit unit) throws InterruptedException;  void unlock();  Condition newCondition();}```- 여기서 사용하는 `락`은 객체 내부에 있는 `모니터 락(monitor lock)`이 아니다! **`Lock` 인터페이스와 `ReentrantLock` 이 제공하는 기능이다!**- `모니터 락(monitor lock)` 과 `BLOCKED` 상태는 `synchronized` 에서만 사용된다.---### 🔋 **`void lock()`**- 락을 획득한다. 만약 다른 스레드가 이미 락을 획득했다면, 락이 풀릴 때까지 현재 스레드는 대기( `WAITING` )한 다. - **이 메서드는 인터럽트에 응답하지 않는다.** - 예) 맛집에 한번 줄을 서면 끝까지 기다린다. 친구가 다른 맛집을 찾았다고 중간에 연락해도 포기하지 않고 기다린다.> `lock()` 을 호출해서 락을 얻기 위해 대기중인 스레드에 **인터럽트가 발생하면 순간 대기 상태를 빠져나오는 것은 맞다.**    그래서 아주 짧지만 `WAITING -> RUNNABLE` 이  된다.    **그런데 `lock()` 메서드 안에서 해당 스레드를 다시 `WAITING` 상태로 강제로 변경해버린다.** 이런 원리로 인터럽트를 무시하는 것이다.     참고로 인터럽트가 필요하면 `lockInterruptibly()` 를 사용하면 된다.---### 🔋 **`void lockInterruptibly() throws InterruptedException`**- 락 획득을 시도하되, 다른 스레드가 인터럽트할 수 있도록 한다. 만약 다른 스레드가 이미 락을 획득했다면, 현재 스레드는 락을 획득할 때까지 대기한다. - 대기 중에 인터럽트가 발생하면 `InterruptedException` 이 발생하며 락 획득을 포기한다. - 예) 맛집에 한번 줄을 서서 기다린다. 다만 친구가 다른 맛집을 찾았다고 중간에 연락하면 포기한다.---### 🔋 **`boolean tryLock()`**- 락 획득을 시도하고, 즉시 성공 여부를 반환한다. 만약 다른 스레드가 이미 락을 획득했다면 `false` 를 반환하고, 그렇지 않으면 락을 획득하고 `true` 를 반환한다.- 예) 맛집에 대기 줄이 없으면 바로 들어가고, 대기 줄이 있으면 즉시 포기한다.---### 🔋 **`boolean tryLock(long time, TimeUnit unit)`**- 주어진 시간 동안 락 획득을 시도한다. 주어진 시간 안에 락을 획득하면 `true` 를 반환한다. 주어진 시간이 지나도 락을 획득하지 못한 경우 `false` 를 반환한다. - 이 메서드는 대기 중 인터럽트가 발생하면 `InterruptedException` 이 발생하며 락 획득을 포기한다. - 예) 맛집에 줄을 서지만 특정 시간 만큼만 기다린다. 특정 시간이 지나도 계속 줄을 서야 한다면 포기한다. 친구가 다른 맛집을 찾았다고 중간에 연락해도 포기한다.---### **`void unlock()`**- 락을 해제한다. 락을 해제하면 락 획득을 대기 중인 스레드 중 하나가 락을 획득할 수 있게 된다.- 락을 획득한 스레드가 호출해야 하며, 그렇지 않으면 `IllegalMonitorStateException` 이 발생할 수 있다. - 예) 식당안에 있는 손님이 밥을 먹고 나간다. 식당에 자리가 하나 난다. 기다리는 손님께 이런 사실을 알려주어야 한다. 기다리던 손님중 한 명이 식당에 들어간다.---### **`Condition newCondition()`**- `Condition` 객체를 생성하여 반환한다. `Condition` 객체는 락과 결합되어 사용되며, 스레드가 특정 조건을 기다리거나 신호를 받을 수 있도록 한다. - 이는 `Object` 클래스의 `wait` , `notify` , `notifyAll` 메서드와 유사한 역할을 한다.--- <br/><br/><br/># 💡 ReentrantLock 공정성> `ReentrantLock`은 스레드가 `공정하게 락을 얻을 수 있는 모드`를 제공한다.   > `ReentrantLock` 락은 `공정성(fairness)` 모드와 `비공정(non-fair)` 모드로 설정할 수 있으며, 이 두 모드는 락을 획득 하는 방식에서 차이가 있다.```javapublic class ReentrantLockEx {    private final Lock nonFairLock = new ReentrantLock(); // 비공정 모드 락    private final Lock fairLock = new ReentrantLock(true); // 공정 모드 락}```### 🔋 **공정 모드 락(Fair mode)**- **공정성 보장**: 대기 큐에서 먼저 대기한 스레드가 락을 먼저 획득한다. - **기아 현상 방지**: 모든 스레드가 언젠가 락을 획득할 수 있게 보장된다. - **성능 저하**: ***락을 획득하는 속도가 느려질 수 있다.***### 🔋 **비공정 모드 락(Non-fair mode)**- **성능 우선**: 락을 획득하는 속도가 빠르다.- **선점 가능**: 새로운 스레드가 기존 대기 스레드보다 먼저 락을 획득할 수 있다. - **기아 현상 가능성**: ***특정 스레드가 계속해서 락을 획득하지 못할 수 있다.***---**<u>ReentrantLock 비공정 모드, 공정 모드 간의 성능이 생각보다 좀 차이가 난다.</u>****비공정 모드에서도 사실 내부에 queue 처럼 구현이 되어 있어서 거의 대부분의 경우에서 그냥 좀 오래 기다린 애가 락을 먼저 획득하게 된다.****그런데, 갑자기 들어온 스레드가 먼저 실행될 수 있는 상황이 발생할 수 있다.**            막 스레드의 경합이 엄청나게 일어나는 상황에서는 순서대로 락을 획득하지 못할 수 있다.         하지만, 그렇게 경합이 많지 않으면 순서대로 락을 획득한다.     경합이 많은 상황에서도 몇개의 갑자기 들어온 스레드가 먼저 락을 획득할 수 있는거지. 기본적으로는 어느 정도 순서대로 락을 획득한다.     그게 보장이 안될 뿐이다.> **결론적으로, 비공정모드를 사용하더라도 그냥 막 진짜 랜덤하게 튀어나오는 몇개 빼고는 거의 순서대로 실행되는데, 가끔씩 새치기하는 녀석들이 생길 수도 있다고 생각하면 된다.**<br/><br/><br/># 💡 ReentrantLock 예시 코드```javaprivate final Lock lock = new ReentrantLock();lock.lock();try {        ...} finally {    lock.unlock();}```- **임계 영역이 끝나면 반드시! 락을 반납해야 한다. 그렇지 않으면 대기하는 스레드가 락을 얻지 못한다.**   - 따라서 `lock.unlock()` 은 반드시 `finally` 블럭에 작성해야 한다.- **여기서 사용하는 락은 객체 내부에 있는 모니터 락이 아니다! `Lock` 인터페이스와 `ReentrantLock` 이 제공하는 기능이다!**<details><summary>ReentrantLock 예시 코드</summary>```javapublic class BankAccountV4 implements BankAccount {    private int balance;    //    volatile private int balance;    private final Lock lock = new ReentrantLock();    public BankAccountV4(int initialBalance) {        this.balance = initialBalance;    }    @Override    public boolean withdraw(int amount) {        log("거래 시작: " + getClass().getSimpleName());        lock.lock(); // ReentrantLock 이용하여 lock을 걸기        try {            // -- 임계 영역 시작 --            log("[검증 시작] 출금액: " + amount + ", 잔액: " + balance);            if (balance < amount) {                log("[검증 실패] 출금액: " + amount + ", 잔액: " + balance);                return false;            }            log("[검증 완료] 출금액: " + amount + ", 잔액: " + balance);            sleep(1000); // 출금에 걸리는 시간으로 가정            balance = balance - amount;            log("[출금 완료] 출금액: " + amount + ", 변경 잔액: " + balance);            // -- 임계 영역 종료 --        } finally {            lock.unlock(); // ReentrantLock 이용하여 lock을 해제        }        log("거래 종료");        return true;    }    @Override    public int getBalance() {        lock.lock(); // ReentrantLock 이용하여 lock 걸기        try {            return balance;        } finally {            lock.unlock(); // ReentrantLock 이용하여 lock 해제        }    }}``````16:09:59.563 [       t2] 거래 시작: BankAccountV416:09:59.563 [       t1] 거래 시작: BankAccountV416:09:59.568 [       t2] [검증 시작] 출금액: 800, 잔액: 100016:09:59.568 [       t2] [검증 완료] 출금액: 800, 잔액: 100016:10:00.053 [     main] t1 state: WAITING16:10:00.054 [     main] t2 state: TIMED_WAITING16:10:00.574 [       t2] [출금 완료] 출금액: 800, 변경 잔액: 20016:10:00.575 [       t2] 거래 종료16:10:00.575 [       t1] [검증 시작] 출금액: 800, 잔액: 20016:10:00.576 [       t1] [검증 실패] 출금액: 800, 잔액: 20016:10:00.583 [     main] 최종 잔액: 200```</details>---<img width="500" alt="스크린샷 2024-09-09 오후 4 13 04" src="https://github.com/user-attachments/assets/7ee120de-f222-4ae3-8ebc-46533f88aed6">- `ReenterantLock` 내부에는 락과 락을 얻지 못해 대기하는 스레드를 관리하는 **`대기 큐`가 존재한다.** - 여기서의 `락(lock)`은 객체 내부에 있는 모니터 락이 아니다. - **`ReentrantLock` 이 제공하는 기능이다.**---<img width="500" alt="스크린샷 2024-09-09 오후 4 15 12" src="https://github.com/user-attachments/assets/451046bd-7cb1-450e-8af6-26730cbf182a">- **1. t1**: 락을 반납한다.- **2. t1**: 대기 큐의 스레드를 하나 깨운다. **`LockSupoort.unpark(thread)` 가 내부에서 호출된다. -> `ReentrantLock` 내부에서 `LockSupport` 클래스를 이용한다.** - **3. t2**: `RUNNABLE` 상태가 되면서 깨어난 스레드는 락 획득을 시도한다.  - 이때 락을 획득하면 `lock.lock()` 을 빠져나오면서 대기 큐에서도 제거된다.   - **이때 락을 획득하지 못하면 다시 `대기 상태(WAITING)`가 되면서 `대기 큐`에 유지된다.**   - ***참고로 락 획득을 시도하는 잠깐 사이에 새로운 스레드가 락을 먼저 가져갈 수 있다.***   - **`공정 모드`의 경우 대기 큐에 먼저 대기한 스레드가 먼저 락을 가져간다.**<br/><br/><br/># 💡 ReentrantLock - 대기 중단### 🔋 **`boolean tryLock()`**- 락 획득을 시도하고, 즉시 성공 여부를 반환한다. 만약 다른 스레드가 이미 락을 획득했다면 `false` 를 반환하고, 그렇지 않으면 락을 획득하고 `true` 를 반환한다.- 예) 맛집에 대기 줄이 없으면 바로 들어가고, 대기 줄이 있으면 즉시 포기한다.---### 🔋 **`boolean tryLock(long time, TimeUnit unit)`**- 주어진 시간 동안 락 획득을 시도한다. 주어진 시간 안에 락을 획득하면 `true` 를 반환한다. 주어진 시간이 지나도 락을 획득하지 못한 경우 `false` 를 반환한다.- 이 메서드는 대기 중 인터럽트가 발생하면 `InterruptedException` 이 발생하며 락 획득을 포기한다.- 예) 맛집에 줄을 서지만 특정 시간 만큼만 기다린다. 특정 시간이 지나도 계속 줄을 서야 한다면 포기한다. 친구가 다른 맛집을 찾았다고 중간에 연락해도 포기한다.<details><summary>tryLock 예시 코드</summary>```javapublic class BankAccountV5 implements BankAccount {    private int balance;    //    volatile private int balance;    private final Lock lock = new ReentrantLock();    public BankAccountV5(int initialBalance) {        this.balance = initialBalance;    }    @Override    public boolean withdraw(int amount) {        log("거래 시작: " + getClass().getSimpleName());        if (!lock.tryLock()) {            log("[진입 실패] 이미 처리중인 작업이 있습니다.");            return false;        }        try {            // -- 임계 영역 시작 --            log("[검증 시작] 출금액: " + amount + ", 잔액: " + balance);            if (balance < amount) {                log("[검증 실패] 출금액: " + amount + ", 잔액: " + balance);                return false;            }            log("[검증 완료] 출금액: " + amount + ", 잔액: " + balance);            sleep(1000); // 출금에 걸리는 시간으로 가정            balance = balance - amount;            log("[출금 완료] 출금액: " + amount + ", 변경 잔액: " + balance);            // -- 임계 영역 종료 --        } finally {            lock.unlock(); // ReentrantLock 이용하여 lock을 해제        }        log("거래 종료");        return true;    }    @Override    public int getBalance() {        lock.lock(); // ReentrantLock 이용하여 lock 걸기        try {            return balance;        } finally {            lock.unlock(); // ReentrantLock 이용하여 lock 해제        }    }}``````16:26:55.267 [       t2] 거래 시작: BankAccountV516:26:55.267 [       t1] 거래 시작: BankAccountV516:26:55.268 [       t1] [진입 실패] 이미 처리중인 작업이 있습니다.16:26:55.271 [       t2] [검증 시작] 출금액: 800, 잔액: 100016:26:55.271 [       t2] [검증 완료] 출금액: 800, 잔액: 100016:26:55.756 [     main] t1 state: TERMINATED16:26:55.757 [     main] t2 state: TIMED_WAITING16:26:56.277 [       t2] [출금 완료] 출금액: 800, 변경 잔액: 20016:26:56.278 [       t2] 거래 종료16:26:56.286 [     main] 최종 잔액: 200```- `t2` : 락이 없다는 것을 확인하고 `lock.tryLock()` 에서 **즉시 빠져나온다.** 이때 `false` 가 반환된다.- `t2` : `"[진입 실패] 이미 처리중인 작업이 있습니다."` 를 출력하고 `false` 를 반환하면서 메서드를 종료한다.- `t1` : 임계 영역의 수행을 완료하고 거래를 종료한다. 마지막으로 락을 반납한다.</details>---<details><summary>tryLock(시간) 예시 코드</summary>```javapublic class BankAccountV6 implements BankAccount {    private int balance;    //    volatile private int balance;    private final Lock lock = new ReentrantLock();    public BankAccountV6(int initialBalance) {        this.balance = initialBalance;    }    @Override    public boolean withdraw(int amount) {        log("거래 시작: " + getClass().getSimpleName());        try {            if (!lock.tryLock(500, TimeUnit.MILLISECONDS)) {                log("[진입 실패] 이미 처리중인 작업이 있습니다.");                return false;            }        } catch (InterruptedException e) {            throw new RuntimeException(e);        }        try {            // -- 임계 영역 시작 --            log("[검증 시작] 출금액: " + amount + ", 잔액: " + balance);            if (balance < amount) {                log("[검증 실패] 출금액: " + amount + ", 잔액: " + balance);                return false;            }            log("[검증 완료] 출금액: " + amount + ", 잔액: " + balance);            sleep(1000); // 출금에 걸리는 시간으로 가정            balance = balance - amount;            log("[출금 완료] 출금액: " + amount + ", 변경 잔액: " + balance);            // -- 임계 영역 종료 --        } finally {            lock.unlock(); // ReentrantLock 이용하여 lock을 해제        }        log("거래 종료");        return true;    }    @Override    public int getBalance() {        lock.lock(); // ReentrantLock 이용하여 lock 걸기        try {            return balance;        } finally {            lock.unlock(); // ReentrantLock 이용하여 lock 해제        }    }}``````> Task :BankMain.main()16:29:46.118 [       t2] 거래 시작: BankAccountV616:29:46.118 [       t1] 거래 시작: BankAccountV616:29:46.122 [       t2] [검증 시작] 출금액: 800, 잔액: 100016:29:46.122 [       t2] [검증 완료] 출금액: 800, 잔액: 100016:29:46.607 [     main] t1 state: TIMED_WAITING // sleep(1000) 때문에 TIMED_WAITING16:29:46.608 [     main] t2 state: TIMED_WAITING // tryLock(500, TimeUnit.MILLISECONDS) 때문에 TIMED_WAITING16:29:46.624 [       t1] [진입 실패] 이미 처리중인 작업이 있습니다.16:29:47.128 [       t2] [출금 완료] 출금액: 800, 변경 잔액: 20016:29:47.129 [       t2] 거래 종료16:29:47.136 [     main] 최종 잔액: 200```- `t2` : `lock.tryLock(0.5초)` 을 호출하고 락 획득을 시도한다. 락이 없으므로 0.5초간 대기한다.   - 이때 `t2` 는 `TIMED_WAITING` 상태가 된다.    - 내부에서는 `LockSupport.parkNanos(시간)` 이 호출된다.- `t2` : 대기 시간인 0.5초간 락을 획득하지 못했다. `lock.tryLock(시간)` 에서 즉시 빠져나온다. 이때 `false`가 반환된다.  - 스레드는 `TIMED_WAITING` `RUNNABLE` 이 된다.- `t2` : `"[진입 실패] 이미 처리중인 작업이 있습니다."`를 출력하고 `false` 를 반환하면서 메서드를 종료한다. - `t1` : 임계 영역의 수행을 완료하고 거래를 종료한다. 마지막으로 락을 반납한다.</details>