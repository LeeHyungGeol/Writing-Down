# 고급 동기화 - LockSupport, ReentrantLock<br/><br/><br/># 💡 LockSupport자바 1.5부터 `java.util.concurrent` 라는 동시성 문제 해결을 위한 라이브러리 패키지가 추가된다.  > `java.util.concurrent` 에는 수 많은 클래스가 있다.   > 그중에서 가장 기본이 되는 `LockSupport` 클래스를 사용해서 `synchronized` 의 가장 큰 단점인 `무한 대기 문제`를 해결할 수 있다.## ⚡️ **LockSupport**- `park()` : 스레드를 `WAITING` 상태로 변경한다.- `parkNanos(nanos)` : 스레드를 나노초 동안만 `TIMED_WAITING` 상태로 변경한다.  - 지정한 나노초가 지나면 `TIMED_WAITING` 상태에서 빠져나오고 `RUNNABLE` 상태로 변경된다.- `unpark(thread)` : `WAITING` 상태의 대상 스레드를 `RUNNABLE` 상태로 변경한다. - `parkNanos(nanos)` : 스레드를 나노초 동안만 `TIMED_WAITING` 상태로 변경한다.   - 지정한 나노초가 지나면 `TIMED_WAITING` 상태에서 빠져나와서 `RUNNABLE` 상태로 변경된다.- `parkUntil(밀리초)`: 특정 에포크(Epoch) 시간에 맞추어 깨어나는 메서드이다. 정확한 미래의 에포크 시점을 지정해야 한다.- 참고로 밀리초 동안만 대기하는 메서드는 없다.`LockSupport.unpark(thread1)` 는 왜 특정 스레드를 지정하는 매개변수가 있을까?- **왜냐하면 실행 중인 스레드는 `LockSupport.park()` 를 호출해서 스스로 대기 상태에 빠질 수 있지만, 대기 상태의 스레드는 자신의 코드를 실행할 수 없기 때문이다. 따라서 외부 스레드의 도움을 받아야 깨어날 수 있다.**`thread.interrupt()`- 스레드에 `interrupt` 를 걸어서 `WAITING` 상태에서 깨울 수 있다.<details><summary>LockSupport 예시 코드</summary>```javapublic class LockSupportMainV1 {    public static void main(String[] args) {        Thread thread1 = new Thread(new ParkTest(), "Thread-1");        thread1.start();        // 잠시 대기하여 Thread-1 이 park 상태에 빠질 시간을 준다.        sleep(100);        log("Thread-1 state: " + thread1.getState());        log("main -> unpark(Thread-1)");//        LockSupport.unpark(thread1); // 1. unpark() 사용        thread1.interrupt(); // 2. interrupt() 사용    }    static class ParkTest implements Runnable {        @Override        public void run() {            log("park 시작");            LockSupport.park();            log("park 종료, state = " + Thread.currentThread().getState());            log("인터럽트 상태: " + Thread.currentThread().isInterrupted());        }    }}```</details><details><summary>LockSupport.parkNanos() 예시 코드</summary>```javapublic class LockSupportMainV2 {    public static void main(String[] args) {        Thread thread1 = new Thread(new ParkTest(), "Thread-1");        thread1.start();        // 잠시 대기하여 Thread-1 이 park 상태에 빠질 시간을 준다.        sleep(100);        log("Thread-1 state: " + thread1.getState());        log("main -> unpark(Thread-1)");//        LockSupport.unpark(thread1); // 1. unpark() 사용//        thread1.interrupt(); // 2. interrupt() 사용    }    static class ParkTest implements Runnable {        @Override        public void run() {            log("park 시작");            LockSupport.parkNanos(2000_000_000); // 2초 TIMED_WAITING            log("park 종료, state = " + Thread.currentThread().getState());            log("인터럽트 상태: " + Thread.currentThread().isInterrupted());        }    }}```</details>## ⚡️ **LockSupport 정리**> `LockSupport` 를 이용하면, `WAITING`, `TIMED_WAITING` 상태로 변경할 수 있고, `interrupt` 를 사용하여 스레드를 깨울 수도 있다.     > 이런 것들을 이용해서 `synchronized` 의 단점인 `무한 대기 문제`를 해결할 수 있다.```javaif (!lock.tryLock(10초)) { // 내부에서 parkNanos() 사용     log("[진입 실패] 너무 오래 대기했습니다.");    return false;}//임계 영역 시작        ...//임계 영역 종료lock.unlock() // 내부에서 unpark() 사용```**하지만,**   이런 기능들 만을 이용하여 직접 구현하기는 매우 어렵다.  - 1개의 스레드만 깨우고, 다른 스레드들을 대기시키고, 어떤 스레드를 깨울지 우선 순위를 결정하고 히는 작업을 구현하는 것은 매우 어렵다.***한마디로 `LockSupport` 는 너무 저수준이다.***  **자바는 `Lock` 인터페이스와 `ReentrantLock` 이라는 구현체로 이런 기능들을 이미 다 구현해 두었다.**<br/><br/><br/># 💡 ReentrantLock- `Lock` 인터페이스는 동시성 프로그래밍에서 쓰이는 안전한 임계 영역을 위한 락을 구현하는데 사용된다.- 대표적인 구현체로 `ReentrantLock` 이 있다.**`Lock` 인터페이스**```javapackage java.util.concurrent.locks;public interface Lock {  void lock();  void lockInterruptibly() throws InterruptedException;  boolean tryLock();  boolean tryLock(long time, TimeUnit unit) throws InterruptedException;  void unlock();  Condition newCondition();}```- 여기서 사용하는 `락`은 객체 내부에 있는 `모니터 락(monitor lock)`이 아니다! **`Lock` 인터페이스와 `ReentrantLock` 이 제공하는 기능이다!**- `모니터 락(monitor lock)` 과 `BLOCKED` 상태는 `synchronized` 에서만 사용된다.---### 🔋 **`void lock()`**- 락을 획득한다. 만약 다른 스레드가 이미 락을 획득했다면, 락이 풀릴 때까지 현재 스레드는 대기( `WAITING` )한 다. - **이 메서드는 인터럽트에 응답하지 않는다.** - 예) 맛집에 한번 줄을 서면 끝까지 기다린다. 친구가 다른 맛집을 찾았다고 중간에 연락해도 포기하지 않고 기다린다.> `lock()` 을 호출해서 락을 얻기 위해 대기중인 스레드에 **인터럽트가 발생하면 순간 대기 상태를 빠져나오는 것은 맞다.**    그래서 아주 짧지만 `WAITING` `RUNNABLE` 이된다.    **그런데 `lock()` 메서드 안에서 해당 스레드를 다시 `WAITING` 상태로 강제로 변경해버린다.** 이런 원리로 인터럽트를 무시하는 것이다.     참고로 인터럽트가 필요하면 `lockInterruptibly()` 를 사용하면 된다.---### 🔋 **`void lockInterruptibly() throws InterruptedException`**- 락 획득을 시도하되, 다른 스레드가 인터럽트할 수 있도록 한다. 만약 다른 스레드가 이미 락을 획득했다면, 현재 스레드는 락을 획득할 때까지 대기한다. - 대기 중에 인터럽트가 발생하면 `InterruptedException` 이 발생하며 락 획득을 포기한다. - 예) 맛집에 한번 줄을 서서 기다린다. 다만 친구가 다른 맛집을 찾았다고 중간에 연락하면 포기한다.---### 🔋 **`boolean tryLock()`**- 락 획득을 시도하고, 즉시 성공 여부를 반환한다. 만약 다른 스레드가 이미 락을 획득했다면 `false` 를 반환하고, 그렇지 않으면 락을 획득하고 `true` 를 반환한다.- 예) 맛집에 대기 줄이 없으면 바로 들어가고, 대기 줄이 있으면 즉시 포기한다.---### 🔋 **`boolean tryLock(long time, TimeUnit unit)`**- 주어진 시간 동안 락 획득을 시도한다. 주어진 시간 안에 락을 획득하면 `true` 를 반환한다. 주어진 시간이 지나도 락을 획득하지 못한 경우 `false` 를 반환한다. - 이 메서드는 대기 중 인터럽트가 발생하면 `InterruptedException` 이 발생하며 락 획득을 포기한다. - 예) 맛집에 줄을 서지만 특정 시간 만큼만 기다린다. 특정 시간이 지나도 계속 줄을 서야 한다면 포기한다. 친구가 다른 맛집을 찾았다고 중간에 연락해도 포기한다.---### **`void unlock()`**- 락을 해제한다. 락을 해제하면 락 획득을 대기 중인 스레드 중 하나가 락을 획득할 수 있게 된다.- 락을 획득한 스레드가 호출해야 하며, 그렇지 않으면 `IllegalMonitorStateException` 이 발생할 수 있다. - 예) 식당안에 있는 손님이 밥을 먹고 나간다. 식당에 자리가 하나 난다. 기다리는 손님께 이런 사실을 알려주어야 한다. 기다리던 손님중 한 명이 식당에 들어간다.---### **`Condition newCondition()`**- `Condition` 객체를 생성하여 반환한다. `Condition` 객체는 락과 결합되어 사용되며, 스레드가 특정 조건을 기다리거나 신호를 받을 수 있도록 한다. - 이는 `Object` 클래스의 `wait` , `notify` , `notifyAll` 메서드와 유사한 역할을 한다.--- 