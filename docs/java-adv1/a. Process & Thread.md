# Process & Thread# 💡 멀티태스킹(Multi-Tasking)과 멀티프로세싱(Multi-Processing)> 멀티프로세싱은 `하드웨어 장비`의 관점  - 여러 CPU(여러 CPU 코어)를 사용하여 동시에 여러 작업을 수행하는 것  - 하드웨어 기반으로 성능을 향상> 멀티태스킹은 `운영체제 소프트웨어`의 관점  - 단일 CPU(단일 CPU 코어)가 여러 작업을 동시에 수행하는 것처럼 보이게 하는 것  - 예: 현대 운영 체제에서 여러 애플리케이션이 동시에 실행되는 환경<br/><br/>## ⚡️ 초창기 컴퓨터의 단일 프로그램 실행> 초창기의 컴퓨터는 하나의 프로그램을 모두 실행한 후에야 다음 프로그램을 실행할 수 있는 `단일 프로그램을 실행`<img width="500" alt="스크린샷 2024-08-07 오후 3 40 11" src="https://github.com/user-attachments/assets/988cf744-36ce-45e7-bc02-02510f2370a7"><img width="500" alt="스크린샷 2024-08-07 오후 3 40 37" src="https://github.com/user-attachments/assets/40498c83-3b68-4261-907c-8ce4fabd42ef">- `프로그램의 실행`: 프로그램을 구성하는 `코드`를 **순서대로 CPU 에서 실행하는 일**- 예시에서는 CPU 코어는 하나로 가정하므로, 한 번에 하나의 프로그램 코드만 실행- 예를 들어, 하나의 프로그램이 모두 끝난 후에야 다음 프로그램을 실행할 수 있다면 사용자는 매우 답답할 것이다.  - 초창기의 컴퓨터는 이렇게 한 번에 하나의 프로그램만 실행> 이것을 해결하기 위해 **하나의 CPU 코어로 여러 프로그램을 동시에 실행**하는 `멀티태스킹`이 등장했다.<br/>## ⚡️ 멀티태스킹(Multi-Tasking) (feat, 시분할(Time-Sharing))> `멀티태스킹(Multi-Tasking)`: **하나의 컴퓨터 시스템이 동시에 여러 작업을 수행하는 능력**<img width="500" alt="스크린샷 2024-08-07 오후 3 48 23" src="https://github.com/user-attachments/assets/cf6f84ab-970b-41af-a022-1677fe0620ff">현대의 CPU는 초당 수십억 번 이상의 연산을 수행한다. 쉽게 이야기해서 초당 수십억 장의 사진이 빠르게 교차되는 것이다.  만약 CPU가 매우 빠르게 두 프로그램의 코드를 번갈아 수행한다면, **사람이 느낄 때 두 프로그램이 동시에 실행되는 것 처럼 느껴질 것**이다. **(대략 0.01초(10ms) 단위로 돌아가며 실행한다.)**> `시분할(Time Sharing, 시간 공유) 기법`: 각 프로그램의 **실행 시간을 분할**해서 **마치 동시에 실행되는 것 처럼 하는** 기법> `스케줄링(Scheduling)`:  CPU 에 어떤 프로그램이 얼마만큼 실행될지는 `운영체제가 결정`- 단순히 시간으로만 작업을 분할하지는 않고, CPU를 최대한 활용할 수 있는 다양한 우선순위와 최적화 기법을 사용한다.<br/>## ⚡️ 멀티프로세싱(Multi-Processing)<img width="500" alt="스크린샷 2024-08-07 오후 4 32 16" src="https://github.com/user-attachments/assets/63b7fd41-7780-4a25-a87e-d08804b39658">`CPU` 안에는 실제로 연산을 처리하는 `코어(Core)` 라는 것이 있다.  - 과거에는 하나의 CPU 안에 하나의 코어(Core)- 현재는 `하나의 CPU` 안에 보통 `2개 이상의 코어`가 들어있다.> `멀티프로세싱(Multi-Processing)`: `둘 이상의 프로세서(CPU 코어)`를 사용하여 여러 작업을 동시에 처리하는 기술<br/><br/><br/># 💡 프로세스와 스레드> `프로세스(Process)`: **실행 환경과 자원을 제공하는 컨테이너 역할**- 실행 환경에는 메모리 공간, 파일 핸들, 시스템 자원(네트워크 연결) 등이 포함된다.운영체제의 스케줄러에 의해 직접 실행되지 않으며, 프로세스 내의 스레드가 실행된다.- 운영체제 같은 거에서 현재 실행 중인 프로세스를 확인하면 여러개가 나온다. 사실, 프로세스가 있는 것은 맞지만 안에서 **실제로 돌아가는 것은 프로세스안의 스레드이다.**`운영체제 안에 프로세스, 프로세스 안에 스레드의 개념`으로 계층을 보면 된다.> `스레드(Thread)`: **CPU 를 사용해서 코드를 하나씩 실행** <img width="500" alt="스크린샷 2024-08-07 오후 4 39 49" src="https://github.com/user-attachments/assets/f3e6d61b-76d1-47a3-a06d-f5627608f683"><br/>## ⚡️ 프로세스(Process)- 프로그램은 실제 실행하기 전까지는 `단순한 파일`에 불과하다.- `프로그램을 실행하면 프로세스가 만들어지고` 프로그램이 실행된다.- 이렇게 운영체제 안에서 **실행중인 프로그램을 프로세스**라 한다.- 프로세스는 실행 중인 프로그램의 **인스턴스**이다.- 자바 언어로 비유를 하자면 `클래스`는 `프로그램`이고, `인스턴스`는 `프로세스`이다.- 각 프로세스는 독립적인 메모리 공간, 서로 간섭하지 않는다. 하나의 프로세스에 문제가 생겨도 다른 프로세스에 영향을 주지 않는다.- 운영체제에서 별도의 작업 단위로 분리해서 관리## ⚡️ 프로세스의 메모리 구성- **코드 섹션**: 실행할 프로그램의 코드가 저장되는 부분- **데이터 섹션**: 전역 변수 및 정적 변수가 저장되는 부분(그림에서 기타에 포함)- **힙 (Heap)**: 동적으로 할당되는 메모리 영역- **스택 (Stack)**: 메서드(함수) 호출 시 생성되는 지역 변수와 반환 주소가 저장되는 영역(스레드에 포함)<br/><br/>## ⚡️ 스레드(Thread)> `스레드(Thread)`: **프로세스 내에서 실행되는 작업의 단위**> **프로세스는 하나 이상의 스레드를 반드시 포함한다.**- `프로그램 실행` > `운영체제`는 먼저 `디스크`에 있는 `파일(file) 덩어리인 프로그램`을 `메모리(memory)`로 불러오면서 `프로세스 생성` > `프로세스 실행`(프로세스 안의 코드가 한 줄씩 실행)```javapublic class Operator {  public static void main(String[] args) {    int a = 10;    int b = a + 5;    System.out.println(b);  }}```위의 **코드를 하나씩 실행**하면서 내려가는 것이 `스레드(Thread)` 이다.- **하나의 프로세스 안에는 최소한 하나의 스레드가 존재한다.**<br/>### 🔋 **스레드의 메모리 구성**- **공유 메모리**: 같은 프로세스의 코드 섹션, 데이터 섹션, 힙(메모리)은 프로세스 안의 모든 스레드가 공유한다.- **개별 스택**: 각 스레드는 자신의 스택을 갖고 있다.<br/>## ⚡️ 멀티스레드가 필요한 이유하나의 프로그램도 **그 안에서 동시에 여러 작업**이 필요하다.- ex) 유튜브는 영상을 보는 동시에 댓글도 달 수 있고, 좋아요도 누를 수 있다.- 스레드가 여러개면, `여러가지 작업`을 `병렬`로 나눠서 작업을 할 수 있다.<br/><br/><br/># 💡 스레드와 스케쥴링## ⚡️ 단일 코어 스케쥴링<img width="500" alt="스크린샷 2024-08-07 오후 5 29 22" src="https://github.com/user-attachments/assets/4848d6c1-7c18-429c-9b1d-510fe285bacb">- `운영체제`는 내부에 `스케줄링 큐`를 가지고 있고, 각각의 스레드는 스케줄링 큐에서 대기한다.- 운영체제는 스케쥴링 알고리즘을 통해 어떤 스레드를 실행할지 결정한다.- 코어가 하나이기 때문에 한번에 하나의 스레드의 코드만 실행된다.## ⚡️ 멀티 코어 스케쥴링<img width="500" alt="스크린샷 2024-08-07 오후 5 33 46" src="https://github.com/user-attachments/assets/2234b819-dbec-4a7c-b1c2-2fd1dbb62b78">- 한 번에 더 많은 스레드를 `물리적으로 진짜 동시에 실행`할 수 있다.- 스레드 N 개를 `병렬`로 실행한다.<br/><br/><br/># 💡 컨텍스트 스위칭(Context-Switching)**멀티태스킹이 반드시 효율적인 것 만은 아니다.**> `컨텍스트 스위칭(Context-Switching)`: **스레드A를 멈추는 시점에 CPU에서 사용하던 이런 값들을 메모리에 저장해두어야 한다. 그리고 이후에 스레드A 를 다시 실행할 때 이 값들을 CPU에 다시 불러오는 과정**- 결과적으로 컨텍스트 스위칭 과정에는 **약간의 비용이 발생한다.*****멀티스레드는 대부분 효율적이지만, 컨텍스트 스위칭 과정이 필요하므로 `항상 효율적인 것은 아니다`***- 멀티쓰레드는 비율로 따지자면, **90% 이상이 효율적인데, 가끔 1,2,3% 정도 컨텍스트 스위칭 과정 때문에 효율적이지 않은 상황이 발생할 수 있다.**- `실제로 컨텍스트 스위칭에 걸리는 시간은 아주 짧다.` **하지만 스레드가 매우 많다면 이 비용이 커질 수 있다.****예시)**<u>1 ~ 10000까지 더해야 한다고 가정해보자.</u>- 스레드1: 1 ~ 5000까지 더함 - 스레드2: 5001 ~ 10000까지 더함 - 마지막에 스레드1의 결과와 스레드2의 결과를 더함<u>CPU 코어가 2개</u>- CPU 코어가 2개 있다면 스레드1, 스레드2로 나누어 멀티스레드로 병렬 처리하는게 효율적이다. 모든 CPU를 사용하므로 연산을 2배 빠르게 처리할 수 있다.<u>CPU 코어가 1개</u>- CPU 코어가 1개 있는데, 스레드를 2개로 만들어서 연산하면 중간중간 컨텍스트 스위칭 비용이 발생한다.- 스레드1을 1 ~ 1000 정도까지 연산한 상태에서 잠시 멈추고 스레드2를 5001 ~ 6001까지 연산하는 식으로 반복할 수 있다. - 이때 CPU는 스레드1을 멈추고 다시 실행할 때 어디까지 연산했는지 알아야 하고, 그 값을 CPU에 다시 불러와야 한다. 결과적으로 이렇게 반복할 때 마다 컨텍스트 스위칭 비용(시간)이든다.<br/><br/># 💡 실무에서<u>CPU - 4개, 스레드 2개 - CPU 의 갯수에 비해 스레드의 숫자가 적은 경우</u>- 스레드의 숫자가 너무 적으면 모든 CPU를 100% 다 활용할 수 없지만, - 스레드가 몇 개 없으므로 컨텍스트 스위칭 비용이 줄어든다.<u>CPU - 4개, 스레드 100개 - CPU 의 갯수에 비해 스레드의 숫자가 많은 경우</u>- 스레드의 숫자가 너무 많으면 CPU를 100% 다 활용할 수 있지만 - **컨텍스트 스위칭 비용이 늘어난다.**<u>CPU - 4개, 스레드 4개</u>- 스레드의 숫자를 CPU의 숫자에 맞춘다면 CPU를 100% 활용할 수 있고, 컨텍스트 스위칭 비용도 자주 발생하지 않기 때문에 최적의 상태가 된다. - 작업 코드에 따라 다르지만, CPU 작업을 많이 하는 스레드라도 **스레드가 잠깐 쉬는 경우들이 발생할 수 있으므로** - 이상적으로는 `CPU 코어 수 + 1개` 정도로 `스레드`를 맞추면 된다.<br/>## ⚡️ **CPU 바운드 작업 vs I/O 바운드 작업**> `스레드가 하는 작업`은 **크게 2가지로 구분**- `CPU-바운드 작업 (CPU-bound tasks)`: **CPU의 연산 능력을 많이 요구하는 작업** (계산이 많이 필요한 작업)  - 이러한 작업은 주로 계산, 데이터 처리, 알고리즘 실행 등 CPU의 처리 속도가 작업 완료 시간을 결정하는 경우  - **예시: 복잡한 수학 연산, 데이터 분석, 비디오 인코딩, 과학적 시뮬레이션 등**- `I/O-바운드 작업 (I/O-bound tasks)`: **디스크, 네트워크, 파일 시스템 등과 같은 입출력(I/O) 작업을 많이 요구하는 작업**  - 스레드가 CPU를 사용하지 않고 **I/O 작업이 완료될 때 까지 대기**한다.  - **예시: 데이터베이스 쿼리 처리, 파일 읽기/쓰기, 네트워크 통신, 사용자 입력 처리 등.**<br/>## ⚡️ **실무에서 웹 애플리케이션 서버**> `실무`에서는 `I/O-바운드 작업`이 많다.(대체로)- 대부분 사용자의 입력을 기다리거나, 데이터베이스를 호출하고 그 결과를 기다리는 등, **기다리는 일이 많다.**- **`I/O-바운드 작업`이 많다는 뜻**일반적인 자바 웹 애플리케이션 서버의 경우 `사용자의 요청 하나`를 처리하는데 `1개의 스레드`가 필요하다.- 사용자의 요청을 하나 처리하는데, 스레드는 CPU를 1% 정도 사용하고, **대부분 데이터베이스 서버에 어떤 결과를 조회하면서 기다린다고 가정하자.** - 이때는 스레드는 CPU를 거의 사용하지 않고 대기한다. - 바로 I/O-바운드 작업이 많다는 것이다.<u>**이 경우 CPU 코어가 4개 있다고해서 스레드 숫자도 CPU 코어에 맞추어 4개로 설정하면 안된다!**</u>- 그러면 동시에 4명의 사용자 요청`만` 처리 가능- 결국 사용자는 동시에 4명 밖에 못받지만 CPU는 4%만 사용하며 **CPU가 놀고 있는 사태가 벌어질 수 있다.**<u>**이 경우에는 단순 계산으로 사용자의 요청 하나를 처리하는데 CPU를 1%만 사용한다면 단순하게 생각해도 100개의 스레드를 만들 수 있다.**</u>- 그러면 동시에 100명의 사용자 요청을 처리할 수 있다.- 물론 실무에서는 `성능 테스트`를 통해 최적의 스레드 숫자를 찾는 것이 제일 좋다.**성능테스트가 별개의 것이 아니고, 테스트 서버를 하나 만들고 거기에다가 부하 테스트를 해보자. 그러면 우리 서버가 대략 몇개까지 받을 수 있구나를 알 수 있을 것이다.**<br/><br/>## ⚡️ 정리- **CPU-바운드 작업**: `CPU 코어 수 + 1개`   - PU를 거의 100% 사용하는 작업이므로 스레드를 CPU 숫자에 최적화- **I/O-바운드 작업**: `CPU 코어 수 보다 많은 스레드를 생성`, CPU를 최대한 사용할 수 있는 숫자까지 스레드 생성   - CPU를 많이 사용하지 않으므로 `성능 테스트`를 통해 **CPU를 최대한 활용하는 숫자까지 스레드 생성**   - 단 너무 많은 스레드를 생성하면 컨텍스트 스위칭 비용도 함께 증가 - **적절한 성능 테스트 필요**> **스레드의 숫자는 CPU-바운드 작업이 많은가, 아니면 I/O-바운드 작업이 많은가에 따라 다르게 설정해야 한다.**