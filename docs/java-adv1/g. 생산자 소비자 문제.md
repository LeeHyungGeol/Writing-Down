# 생산자 소비자 문제(producer-consumer problem)<br/><br/><br/># 💡 생산자 소비자 문제(producer-consumer problem)> **멀티스레드 프로그래밍에서 자주 등장하는 동시성 문제 중 하나로, 여러 스레드가 동시에 데이터를 생산하고 소비하는 상황을 다룬다.**<u>**기본 개념**</u>- **`생산자(Producer)`**: **데이터를 생성하는 역할**을 한다.   - 예) 파일에서 데이터를 읽어오거나 네트워크에서 데이터를 받아오는 스레드가 생산자 역할을 할 수 있다.  - **`소비자(Consumer)`**: **생성된 데이터를 사용하는 역할**을 한다.   - 예) 데이터를 처리하거나 저장하는 스레드가 소비자 역할을 할 수 있다.  - **`버퍼(Buffer)`**: 생산자가 생성한 데이터를 일시적으로 저장하는 공간이다.   - 이 버퍼는 한정된 크기를 가지며, 생산자와 소비자가 이 버퍼를 통해 데이터를 주고받는다.<u>**문제 상황**</u>- **생산자가 너무 빠를 때**: 버퍼가 가득 차서 더 이상 데이터를 넣을 수 없을 때까지 생산자가 데이터를 생성한다.   - 버퍼가 가득 찬 경우 생산자는 버퍼에 빈 공간이 생길 때까지 기다려야 한다.- **소비자가 너무 빠를 때**: 버퍼가 비어서 더 이상 소비할 데이터가 없을 때까지 소비자가 데이터를 처리한다.   - 버퍼가 비어있을 때 소비자는 버퍼에 새로운 데이터가 들어올 때까지 기다려야 한다.<u>**생산자 소비자 문제 예시 그림 - 프린터 예제**</u><img width="500" alt="스크린샷 2024-09-10 오후 3 58 35" src="https://github.com/user-attachments/assets/050508ba-a752-4b03-8f87-4b231d863ed9">- **생산자 소비자 문제**`(producer-consumer problem)`: 생산자 소비자 문제는, 생산자 스레드와 소비자 스레드가 특정 자원을 함께 생산하고, 소비하면서 발생하는 문제이다.- **한정된 버퍼 문제**`(bounded-buffer problem)`: 이 문제는 결국 중간에 있는 버퍼의 크기가 한정되어 있기 때문에 발생한다. 따라서 한정된 버퍼 문제라고도 한다.**위의 2개 문제는 서로 같은 뜻이다.**<br/><br/><br/># 💡 생산자 소비자 문제 예제 코드 1```javapublic interface BoundedQueue {    void put(String data);    String take();}``````javapublic class ProducerTask implements Runnable {    private BoundedQueue queue;    private String request;    public ProducerTask(BoundedQueue queue, String request) {        this.queue = queue;        this.request = request;    }    @Override    public void run() {        log("[생산 시도] " + request + " -> " + queue);        queue.put(request);        log("[생산 완료] " + request + " -> " + queue);    }}``````javapublic class ConsumerTask implements Runnable {    private BoundedQueue queue;    public ConsumerTask(BoundedQueue queue) {        this.queue = queue;    }    @Override    public void run() {        log("[소비 시도]     ? <- " + queue);        String data = queue.take();        log("[소비 완료] " + data + " <- " + queue);    }}``````javapublic class BoundedQueueV1 implements BoundedQueue {    private final Queue<String> queue = new ArrayDeque<>();    private final int max;    public BoundedQueueV1(int max) {        this.max = max;    }    @Override    public synchronized void put(String data) {        if (queue.size() == max) {            log("[put] 큐가 가득 참, 버림: " + data);            return;        }        queue.offer(data);    }    @Override    public synchronized String take() {        if (queue.isEmpty()) {            return null;        }        return queue.poll();    }    // 원칙적으로는 여기에도 synchronized 를 붙여줘야 한다.    // A 스레드가 큐에 접근 중일 때, B 스레드가 toString() 을 호출한다면 기대하지 않는 값을 얻을 수 있기 때문에 원칙적으로는 synchronized 를 붙여줘야 한다.    @Override    public String toString() {        return queue.toString();    }}````synchronized`- 원칙적으로는 여기에도 synchronized 를 붙여줘야 한다. - A 스레드가 큐에 접근 중일 때, B 스레드가 toString() 을 호출한다면 기대하지 않는 값을 얻을 수 있기 때문에 원칙적으로는 synchronized 를 붙여줘야 한다.<u>**임계 영역`(critical section)`**</u>- **핵심 공유 자원**은 `queue(ArrayDeque)`- 여러 스레드가 함께 접근해서 공유해야 하므로 `synchronized` 를 사용해서 `한번에 하나의 스레드만 접근(put(), take())`할 수 있도록 제한한다.```javapackage thread.bounded;import static util.MyLogger.log;import static util.ThreadUtils.sleep;import java.util.ArrayList;import java.util.List;public class BoundedMain {    public static void main(String[] args) {        // 1. BoundedQueue 선택        BoundedQueue queue = new BoundedQueueV1(2);//        BoundedQueue queue = new BoundedQueueV2(2);//        BoundedQueue queue = new BoundedQueueV3(2);//        BoundedQueue queue = new BoundedQueueV4(2);//        BoundedQueue queue = new BoundedQueueV5(2);//        BoundedQueue queue = new BoundedQueueV6_1(2);//        BoundedQueue queue = new BoundedQueueV6_2(2);//        BoundedQueue queue = new BoundedQueueV6_3(2);//        BoundedQueue queue = new BoundedQueueV6_4(2);        // 2. 생산자, 소비자 실행 순서 선택, 반드시 하나만 선택!        producerFirst(queue); // 생산자 먼저 실행//        consumerFirst(queue); // 소비자 먼저 실행    }    private static void producerFirst(BoundedQueue queue) {        log("== [생산자 먼저 실행] 시작, " + queue.getClass().getSimpleName() + " ==");        List<Thread> threads = new ArrayList<>();        startProducer(queue, threads);        printAllState(queue, threads);        startConsumer(queue, threads);        printAllState(queue, threads);        log("== [생산자 먼저 실행] 종료, " + queue.getClass().getSimpleName() + " ==");    }    private static void consumerFirst(BoundedQueue queue) {        log("== [소비자 먼저 실행] 시작, " + queue.getClass().getSimpleName() + " ==");        List<Thread> threads = new ArrayList<>();        startConsumer(queue, threads);        printAllState(queue, threads);        startProducer(queue, threads);        printAllState(queue, threads);        log("== [소비자 먼저 실행] 종료, " + queue.getClass().getSimpleName() + " ==");    }    private static void startProducer(BoundedQueue queue, List<Thread> threads) {        System.out.println();        for (int i = 1; i <= 3; i++) {            Thread producer = new Thread(new ProducerTask(queue, "data" + i), "producer" + i);            threads.add(producer);            producer.start();            sleep(100);        }    }    private static void printAllState(BoundedQueue queue, List<Thread> threads) {        System.out.println();        log("현재 상태 출력, 큐 데이터: " + queue);        for (Thread thread : threads) {            log(thread.getName() + ": " + thread.getState());        }    }    private static void startConsumer(BoundedQueue queue, List<Thread> threads) {        System.out.println();        log("소비자 시작");        for (int i = 1; i <= 3; i++) {            Thread consumer = new Thread(new ConsumerTask(queue), "consumer" + i);            threads.add(consumer);            consumer.start();            sleep(100);        }    }}```<u>**BoundedQueue 선택**</u>- `BoundedQueue queue = new BoundedQueueV1(2);`  - `BoundedQueue` 의 구현체를 선택해서 생성한다.   - 버퍼의 크기는 `2` 를 사용한다. 따라서 버퍼에는 데이터를 2개 까지만 보관할 수 있다.     - 만약 생산자가 2개를 넘어서는 데이터를 추가로 저장하려고 하면 문제가 발생한다.     - 반대로 버퍼에 데이터가 없는데, 소비자가 데이터를 가져갈 때도 문제가 발생한다.<u>`startProducer()`, `startConsumer()`</u>- **여기서는 이해를 돕기 위해 `sleep(100)` 을 주면서 스레드를 0.1초 단위로 쉬면서 순서대로 실행한다.**<img width="500" alt="스크린샷 2024-09-10 오후 4 59 35" src="https://github.com/user-attachments/assets/db645f1f-ca1d-443d-aebc-da0955d3969c">- 임계 영역은 `synchronized` 를 영역을 뜻한다. 스레드가 이 영역에 들어가려면 모니터 락( `lock` )이 필요하다.---### 🔋 실행 결과 - BoundedQueueV1, 생산자 먼저 실행<details><summary>실행 결과 - BoundedQueueV1, 생산자 먼저 실행</summary>```> Task :BoundedMain.main()16:33:31.244 [     main] == [생산자 먼저 실행] 시작, BoundedQueueV1 ==16:33:31.251 [producer1] [생산 시도] data1 -> []16:33:31.251 [producer1] [생산 완료] data1 -> [data1]16:33:31.353 [producer2] [생산 시도] data2 -> [data1]16:33:31.353 [producer2] [생산 완료] data2 -> [data1, data2]16:33:31.458 [producer3] [생산 시도] data3 -> [data1, data2]16:33:31.459 [producer3] [put] 큐가 가득 참, 버림: data316:33:31.459 [producer3] [생산 완료] data3 -> [data1, data2]16:33:31.564 [     main] 현재 상태 출력, 큐 데이터: [data1, data2]16:33:31.564 [     main] producer1: TERMINATED16:33:31.565 [     main] producer2: TERMINATED16:33:31.565 [     main] producer3: TERMINATED16:33:31.565 [     main] 소비자 시작16:33:31.567 [consumer1] [소비 시도]     ? <- [data1, data2]16:33:31.568 [consumer1] [소비 완료] data1 <- [data2]16:33:31.672 [consumer2] [소비 시도]     ? <- [data2]16:33:31.672 [consumer2] [소비 완료] data2 <- []16:33:31.773 [consumer3] [소비 시도]     ? <- []16:33:31.773 [consumer3] [소비 완료] null <- []16:33:31.878 [     main] 현재 상태 출력, 큐 데이터: []16:33:31.879 [     main] producer1: TERMINATED16:33:31.879 [     main] producer2: TERMINATED16:33:31.879 [     main] producer3: TERMINATED16:33:31.880 [     main] consumer1: TERMINATED16:33:31.880 [     main] consumer2: TERMINATED16:33:31.880 [     main] consumer3: TERMINATED16:33:31.881 [     main] == [생산자 먼저 실행] 종료, BoundedQueueV1 ==```</details><img width="500" alt="스크린샷 2024-09-10 오후 5 00 41" src="https://github.com/user-attachments/assets/7e0e8baa-1764-4ef2-bf0d-4d8aa958c011"><u>**데이터를 버리지 않는 대안**</u>       `data3` 을 버리지 않는 대안은, 큐에 빈 공간이 생길 때 까지 `p3` 스레드가 기다리는 것이다.**그럼 어떻게 기다릴 수 있을까?** - 단순하게 생각하면 생산자 스레드가 반복문을 사용해서 큐에 빈 공간이 생기는지 주기적으로 체크한 다음에, - 만약 빈 공간이 없다면 `sleep()` 을 짧게 사용해서 잠시 대기하고, 깨어난 다음에 다시 반복문에서 큐의 빈 공간을 체크하는 식으로 구현하면 될 것 같다.<br/><img width="500" alt="스크린샷 2024-09-10 오후 5 03 58" src="https://github.com/user-attachments/assets/65014b43-9ff7-4ed6-93ab-20b9fc957d36"><u>**큐에 데이터가 없다면 기다리자**</u>     **소비자 입장에서 큐에 데이터가 없다면 기다리는 것도 대안이다.****그럼 어떻게 기다릴 수 있을까?**- 단순하게 생각하면 소비자 스레드가 반복문을 사용해서 큐에 데이터가 있는지 주기적으로 체크한 다음에, - 만약 데이터가 없다면 `sleep()` 을 짧게 사용해서 잠시 대기하고, 깨어난 다음에 다시 반복문에서 큐에 데이터가 있는지 체크하는 식으로 구현하면 될 것 같다.---### 🔋 실행 결과 - BoundedQueueV1, 소비자 먼저 실행<details><summary>실행 결과 - BoundedQueueV1, 소비자 먼저 실행</summary>```> Task :BoundedMain.main()16:35:09.888 [     main] == [소비자 먼저 실행] 시작, BoundedQueueV1 ==16:35:09.890 [     main] 소비자 시작16:35:09.893 [consumer1] [소비 시도]     ? <- []16:35:09.895 [consumer1] [소비 완료] null <- []16:35:09.994 [consumer2] [소비 시도]     ? <- []16:35:09.994 [consumer2] [소비 완료] null <- []16:35:10.094 [consumer3] [소비 시도]     ? <- []16:35:10.095 [consumer3] [소비 완료] null <- []16:35:10.200 [     main] 현재 상태 출력, 큐 데이터: []16:35:10.200 [     main] consumer1: TERMINATED16:35:10.201 [     main] consumer2: TERMINATED16:35:10.201 [     main] consumer3: TERMINATED16:35:10.202 [producer1] [생산 시도] data1 -> []16:35:10.202 [producer1] [생산 완료] data1 -> [data1]16:35:10.307 [producer2] [생산 시도] data2 -> [data1]16:35:10.307 [producer2] [생산 완료] data2 -> [data1, data2]16:35:10.412 [producer3] [생산 시도] data3 -> [data1, data2]16:35:10.413 [producer3] [put] 큐가 가득 참, 버림: data316:35:10.414 [producer3] [생산 완료] data3 -> [data1, data2]16:35:10.514 [     main] 현재 상태 출력, 큐 데이터: [data1, data2]16:35:10.515 [     main] consumer1: TERMINATED16:35:10.515 [     main] consumer2: TERMINATED16:35:10.515 [     main] consumer3: TERMINATED16:35:10.516 [     main] producer1: TERMINATED16:35:10.516 [     main] producer2: TERMINATED16:35:10.516 [     main] producer3: TERMINATED16:35:10.517 [     main] == [소비자 먼저 실행] 종료, BoundedQueueV1 ==```</details><img width="500" alt="스크린샷 2024-09-10 오후 5 11 12" src="https://github.com/user-attachments/assets/d238b938-dd7d-4df5-846b-71b13f7974c6">- 큐에 데이터가 없으므로 `null` 을 반환한다. 결과적으로 `c1` , `c2` , `c3` 모두 데이터를 받지 못하고 종료된다.<br/><img width="500" alt="스크린샷 2024-09-10 오후 5 12 56" src="https://github.com/user-attachments/assets/7b8710ba-c6a7-49a6-8680-0a260a498fd2"><img width="500" alt="스크린샷 2024-09-10 오후 5 13 31" src="https://github.com/user-attachments/assets/6a40484a-4ae0-4671-adcd-4da6c70759b4">### 🔋 **문제점**- **버퍼가 가득 찬 경우**: 생산자 입장에서 버퍼에 여유가 생길 때 까지 조금만 기다리면 되는데, 기다리지 못하고, 데 이터를 버리는 것은 아쉽다.- **버퍼가 빈 경우**: 소비자 입장에서 버퍼에 데이터가 채워질 때 까지 조금만 기다리면 되는데, 기다리지 못하고, `null` 데이터를 얻는 것은 아쉽다.---## ⚡️ 해결방법**문제의 해결 방안은 단순하다. `스레드가 기다리면` 되는 것이다!**<br/><br/><br/># 💡 생산자 소비자 문제 예제 코드 2```javapublic class BoundedQueueV2 implements BoundedQueue {    private final Queue<String> queue = new ArrayDeque<>();    private final int max;    public BoundedQueueV2(int max) {        this.max = max;    }    @Override    public synchronized void put(String data) {        while (queue.size() == max) {            log("[put] 큐가 가득 참, 생산자 대기");            sleep(1000);            Thread.yield();        }        queue.offer(data);    }    @Override    public synchronized String take() {        while (queue.isEmpty()) {            log("[take] 큐에 데이터가 없음, 소비자 대기");            sleep(1000);            Thread.yield();        }        return queue.poll();    }    // 원칙적으로는 여기에도 synchronized 를 붙여줘야 한다.    // A 스레드가 큐에 접근 중일 때, B 스레드가 toString() 을 호출한다면 기대하지 않는 값을 얻을 수 있기 때문에 원칙적으로는 synchronized 를 붙여줘야 한다.    @Override    public String toString() {        return queue.toString();    }}```<u>**`put(data)` - 데이터를 버리지 않는 대안**</u>- `data3` 을 버리지 않는 대안은, 큐가 가득 찾을 때, 큐에 빈 공간이 생길 때 까지, 생산자 스레드가 기다리면 된다. - 여기서는 생산자 스레드가 반복문을 사용해서 큐에 빈 공간이 생기는지 주기적으로 체크한다. - 만약 빈 공간이 없다면 `sleep()` 을 사용해서 잠시 대기하고, 깨어난 다음에 다시 반복문에서 큐의 빈 공간을 체크하는 식으로 구현했다.<u>**`take()` - 큐에 데이터가 없다면 기다리자**</u>- 소비자 입장에서 큐에 데이터가 없다면 기다리는 것도 대안이다. - 큐에 데이터가 없을 때 `null` 을 받지 않는 대안은, 큐에 데이터가 추가될 때 까지 소비자 스레드가 기다리는 것이다.- 여기서는 소비자 스레드가 반복문을 사용해서 큐에 데이터가 있는지 주기적으로 체크한 다음에, - 만약 데이터가 없다면 `sleep()` 을 사용해서 잠시 대기하고, 깨어난 다음에 다시 반복문에서 큐에 데이터가 있는지 체크하는 식으로 구현했---### 🔋 실행 결과 - BoundedQueueV2, 생산자 먼저 실행<details><summary>실행 결과 - BoundedQueueV2, 생산자 먼저 실행</summary>```> Task :BoundedMain.main()17:24:48.118 [     main] == [생산자 먼저 실행] 시작, BoundedQueueV2 ==17:24:48.125 [producer1] [생산 시도] data1 -> []17:24:48.125 [producer1] [생산 완료] data1 -> [data1]17:24:48.227 [producer2] [생산 시도] data2 -> [data1]17:24:48.228 [producer2] [생산 완료] data2 -> [data1, data2]17:24:48.331 [producer3] [생산 시도] data3 -> [data1, data2]17:24:48.331 [producer3] [put] 큐가 가득 참, 생산자 대기17:24:48.437 [     main] 현재 상태 출력, 큐 데이터: [data1, data2]17:24:48.437 [     main] producer1: TERMINATED17:24:48.437 [     main] producer2: TERMINATED17:24:48.438 [     main] producer3: TIMED_WAITING17:24:48.438 [     main] 소비자 시작17:24:48.438 [consumer1] [소비 시도]     ? <- [data1, data2]17:24:48.539 [consumer2] [소비 시도]     ? <- [data1, data2]17:24:48.645 [consumer3] [소비 시도]     ? <- [data1, data2]17:24:48.750 [     main] 현재 상태 출력, 큐 데이터: [data1, data2]17:24:48.750 [     main] producer1: TERMINATED17:24:48.750 [     main] producer2: TERMINATED17:24:48.751 [     main] producer3: TIMED_WAITING17:24:48.751 [     main] consumer1: BLOCKED17:24:48.751 [     main] consumer2: BLOCKED17:24:48.751 [     main] consumer3: BLOCKED17:24:48.752 [     main] == [생산자 먼저 실행] 종료, BoundedQueueV2 ==17:24:49.337 [producer3] [put] 큐가 가득 참, 생산자 대기17:24:50.341 [producer3] [put] 큐가 가득 참, 생산자 대기17:24:51.347 [producer3] [put] 큐가 가득 참, 생산자 대기17:24:52.352 [producer3] [put] 큐가 가득 참, 생산자 대기17:24:53.356 [producer3] [put] 큐가 가득 참, 생산자 대기```</details><img width="500" alt="스크린샷 2024-09-10 오후 5 26 03" src="https://github.com/user-attachments/assets/3e3dd479-d220-4e22-a9a8-62524472e1ef">`p3` 는 `sleep(1000)` 을사용해서잠시대기한다.이때 `RUNNABLE -> TIMED_WAITING` 상태가된다.- 빈 자리가 없다면 `sleep()` 으로 잠시 대기한 다음 반복문을 계속해서 수행한다. 1초마다 한 번씩 체크하 기 때문에 `"큐가 가득 참, 생산자 대기"`라는 메시지가 계속 출력될 것이다.**여기서 핵심은 `p3` 스레드가 락을 가지고 있는 상태에서, 큐에 빈 자리가 나올 때 까지 대기한다는 점이다.**<br/><img width="500" alt="스크린샷 2024-09-10 오후 5 29 27" src="https://github.com/user-attachments/assets/eb1a5ea1-e67c-442f-b79e-f82e6d0aa097"><u>**무한 대기 문제**</u>- `p3` 가 락을 가지고 임계영역에 이미 들어가 있기 때문이다. - `p3` 가 락을 반납하기 전까지는 `c1`, `c2`, `c3` 은 절대로 임계 영역(여기서는 `synchronized`)에 들어갈 수 없다!**락을 반납하려면 `c1` 이 먼저 큐의 데이터를 소비해야 한다. 그래야 `p3` 가 큐에 `data3` 을 저장하고 임계영역을 빠져나가며 락을 반납할 수 있다.**     ***그런데 `p3` 가 `락을 가지고 임계영역 안`에 있기 때문에, 임계영역 밖의 `c1` 은 락을 획득할 수 없으므로, 큐에 접근하지 못하고 `무한 대기`한다.***> **결과적으로 `c1` , `c2` , `c3` 는 모두 락을 획득하기 위해 `BLOCKED` 상태로 대기한다.** 결국 이런 상태가 무한하게 지속된다.---### 🔋 실행 결과 - BoundedQueueV2, 소비자 먼저 실행<details><summary>실행 결과 - BoundedQueueV2, 소비자 먼저 실행</summary>```> Task :BoundedMain.main()17:35:02.518 [     main] == [소비자 먼저 실행] 시작, BoundedQueueV2 ==17:35:02.519 [     main] 소비자 시작17:35:02.522 [consumer1] [소비 시도]     ? <- []17:35:02.522 [consumer1] [take] 큐에 데이터가 없음, 소비자 대기17:35:02.623 [consumer2] [소비 시도]     ? <- []17:35:02.727 [consumer3] [소비 시도]     ? <- []17:35:02.833 [     main] 현재 상태 출력, 큐 데이터: []17:35:02.836 [     main] consumer1: TIMED_WAITING17:35:02.836 [     main] consumer2: BLOCKED17:35:02.836 [     main] consumer3: BLOCKED17:35:02.837 [producer1] [생산 시도] data1 -> []17:35:02.941 [producer2] [생산 시도] data2 -> []17:35:03.047 [producer3] [생산 시도] data3 -> []17:35:03.152 [     main] 현재 상태 출력, 큐 데이터: []17:35:03.152 [     main] consumer1: TIMED_WAITING17:35:03.152 [     main] consumer2: BLOCKED17:35:03.153 [     main] consumer3: BLOCKED17:35:03.153 [     main] producer1: BLOCKED17:35:03.153 [     main] producer2: BLOCKED17:35:03.153 [     main] producer3: BLOCKED17:35:03.153 [     main] == [소비자 먼저 실행] 종료, BoundedQueueV2 ==17:35:03.525 [consumer1] [take] 큐에 데이터가 없음, 소비자 대기17:35:04.530 [consumer1] [take] 큐에 데이터가 없음, 소비자 대기17:35:05.533 [consumer1] [take] 큐에 데이터가 없음, 소비자 대기17:35:06.538 [consumer1] [take] 큐에 데이터가 없음, 소비자 대기```</details><u>**무한 대기 문제**</u><img width="500" alt="스크린샷 2024-09-10 오후 5 37 00" src="https://github.com/user-attachments/assets/d8b51faf-f941-48bd-b9e9-9022aef6310f">- `c1` 은 `sleep(1000)` 을 사용해서 잠시 대기한다. 이때 `RUNNABLE -> TIMED_WAITING` 상태가된다.- `c1` 이 락을 가지고 임계영역에 들어가 있기 때문에, `c2`, `c3` 는 절대로 임계 영역(여기서는 `synchronized` )은 들어갈 수 없고, `BLOCKED` 상태가 된다.- 락을 반납하려면 `p1` 이 먼저 큐의 데이터를 추가해야 한다. 그래야 `c1` 이 큐에서 데이터를 획득하고 임계영역을 빠져나가며 락을 반납할 수 있다.- 그런데 `c1` 이 락을 가지고 임계영역 안에 있기 때문에, 임계영역 밖의 `p1` 은 락을 획득할 수 없으므로, 큐에 접근하지 못하고 무한 대기한다.**결과적으로 `c1` 을 제외한 모든 스레드가 락을 획득하기 위해 `BLOCKED` 상태로 대기한다.**---## ⚡️ 해결방법생각해보면 결국 임계 영역 안에서 락을 가지고 대기하는 것이 문제이다. 이것은 마치 열쇠를 가진 사람이 안에서 문을 잠궈버린 것과 같다.> **"락을 가지고 대기하는 스레드가 대기하는 동안 다른 스레드에게 락을 양보할 수 있다면, 이 문제를 쉽게 풀 수 있다."**자바의 `Object.wait()` , `Object.noitfy()` 를 사용하면 락을 가지고 대기하는 스레드가 대기하는 동안 다른 스레드에게 락을 양보할 수 있다.<br/><br/><br/># 💡 생산자 소비자 문제 예제 코드 3 - Object - wait, notify### 🔋 Object.wait()- 현재 스레드가 가진 락을 반납하고 대기( `WAITING` )한다. - 현재 스레드를 대기( `WAITING` ) 상태로 전환한다. **이 메서드는 현재 스레드가 `synchronized` 블록이나 메서드에서 락을 소유하고 있을 때만 호출할 수 있다.** - 호출한 스레드는 락을 반납하고, 다른 스레드가 해당 락을 획득할 수 있도록 한다. - 이렇게 대기 상태로 전환된 스레드는 다른 스레드가 `notify()` 또는 `notifyAll()` 을 호출할 때까지 대기 상태를 유지한다. ### 🔋 Object.notify()- 대기 중인 스레드 중 하나를 깨운다.- **이 메서드는 `synchronized` 블록이나 메서드에서 호출되어야 한다.** 깨운 스레드는 락을 다시 획득할 기회를 얻게 된다. - 만약 대기 중인 스레드가 여러 개라면, 그 중 하나만이 깨워지게 된다. ### 🔋 Object.notifyAll()- 대기 중인 모든 스레드를 깨운다.- **이 메서드 역시 `synchronized` 블록이나 메서드에서 호출되어야 하며,** 모든 대기 중인 스레드가 락을 획 득할 수 있는 기회를 얻게 된다. - 이 방법은 모든 스레드를 깨워야 할 필요가 있는 경우에 유용하다.```javapublic class BoundedQueueV3 implements BoundedQueue {    private final Queue<String> queue = new ArrayDeque<>();    private final int max;    public BoundedQueueV3(int max) {        this.max = max;    }    @Override    public synchronized void put(String data) {        while (queue.size() == max) {            log("[put] 큐가 가득 참, 생산자 대기");            try {                wait(); // RUNNABLE -> WAITING, 락 반납                log("[put] 생산자 깨어남");            } catch (InterruptedException e) {                throw new RuntimeException(e);            }        }        queue.offer(data);        log("[put] 생산자 데이터 저장, notify() 호출");        notify(); // 대기 스레드, WAITING -> BLOCKED    }    @Override    public synchronized String take() {        while (queue.isEmpty()) {            log("[take] 큐에 데이터가 없음, 소비자 대기");            try {                wait(); // RUNNABLE -> WAITING, 락 반납                log("[take] 소비자 깨어남");            } catch (InterruptedException e) {                throw new RuntimeException(e);            }        }        String data = queue.poll();        log("[take] 소비자 데이터 획득, notify() 호출");        notify(); // 대기 스레드, WAITING -> BLOCKED        return data;    }    // 원칙적으로는 여기에도 synchronized 를 붙여줘야 한다.    // A 스레드가 큐에 접근 중일 때, B 스레드가 toString() 을 호출한다면 기대하지 않는 값을 얻을 수 있기 때문에 원칙적으로는 synchronized 를 붙여줘야 한다.    @Override    public String toString() {        return queue.toString();    }}```<u>**put(data) - wait(), notify()**</u>- `Object.wait()` 을 사용해서 대기한다. **대기할 때 락을 반납하고 대기**한다. - `wait()` 를 호출해서 대기하는 경우 `RUNNABLE -> WAITING` 상태가 된다.<u>**take() - wait(), notify()**</u>- `Object.wait()` 을 사용해서 대기한다. **대기할 때 락을 반납하고 대기**한다.- 대기하는 경우 `RUNNABLE -> WAITING` 상태가 된다.> **여기서 중요한 핵심은 `wait()` 를 호출해서 대기 상태에 빠질 때 `락을 반납하고` 대기 상태에 빠진다는 것이다.**### 🔋 **스레드 대기 집합(wait set)**<img width="500" alt="스크린샷 2024-09-10 오후 5 49 33" src="https://github.com/user-attachments/assets/9ab52d65-8229-4683-845c-76e99522340b">`synchronized` 임계 영역 안에서 `Object.wait()` 를 호출하면 스레드는 대기( `WAITING` ) 상태에 들어간다.> **`대기 상태에 들어간 스레드를 관리하는 것`을 `대기 집합(wait set)`이라 한다.**- ***모든 객체는 `각자의 대기 집합`을 가지고 있다.***- ***모든 객체는 `락(모니터 락)`과 `대기 집합`을 가지고 있다.*** **둘은 한 쌍으로 사용된다.** - 따라서 락을 획득한 객체의 대기 집합을 사용해야 한다.---### 🔋 실행 결과 - BoundedQueueV3, 생산자 먼저 실행<details><summary>실행 결과 - BoundedQueueV3, 생산자 먼저 실행</summary>```> Task :BoundedMain.main()17:53:04.527 [     main] == [생산자 먼저 실행] 시작, BoundedQueueV3 ==17:53:04.534 [producer1] [생산 시도] data1 -> []17:53:04.534 [producer1] [put] 생산자 데이터 저장, notify() 호출17:53:04.534 [producer1] [생산 완료] data1 -> [data1]17:53:04.631 [producer2] [생산 시도] data2 -> [data1]17:53:04.631 [producer2] [put] 생산자 데이터 저장, notify() 호출17:53:04.632 [producer2] [생산 완료] data2 -> [data1, data2]17:53:04.733 [producer3] [생산 시도] data3 -> [data1, data2]17:53:04.733 [producer3] [put] 큐가 가득 참, 생산자 대기17:53:04.838 [     main] 현재 상태 출력, 큐 데이터: [data1, data2]17:53:04.838 [     main] producer1: TERMINATED17:53:04.838 [     main] producer2: TERMINATED17:53:04.838 [     main] producer3: WAITING17:53:04.838 [     main] 소비자 시작17:53:04.840 [consumer1] [소비 시도]     ? <- [data1, data2]17:53:04.840 [consumer1] [take] 소비자 데이터 획득, notify() 호출17:53:04.840 [producer3] [put] 생산자 깨어남17:53:04.840 [consumer1] [소비 완료] data1 <- [data2]17:53:04.840 [producer3] [put] 생산자 데이터 저장, notify() 호출17:53:04.840 [producer3] [생산 완료] data3 -> [data2, data3]17:53:04.945 [consumer2] [소비 시도]     ? <- [data2, data3]17:53:04.945 [consumer2] [take] 소비자 데이터 획득, notify() 호출17:53:04.945 [consumer2] [소비 완료] data2 <- [data3]17:53:05.047 [consumer3] [소비 시도]     ? <- [data3]17:53:05.048 [consumer3] [take] 소비자 데이터 획득, notify() 호출17:53:05.048 [consumer3] [소비 완료] data3 <- []17:53:05.152 [     main] 현재 상태 출력, 큐 데이터: []17:53:05.153 [     main] producer1: TERMINATED17:53:05.153 [     main] producer2: TERMINATED17:53:05.153 [     main] producer3: TERMINATED17:53:05.153 [     main] consumer1: TERMINATED17:53:05.154 [     main] consumer2: TERMINATED17:53:05.154 [     main] consumer3: TERMINATED17:53:05.154 [     main] == [생산자 먼저 실행] 종료, BoundedQueueV3 ==```</details><img width="500" alt="스크린샷 2024-09-10 오후 5 56 54" src="https://github.com/user-attachments/assets/adb47264-82a9-4348-8a98-63c0ab356903">`wait()` 를 호출하면- 락을 반납한다. - 스레드의 상태가 `RUNNABLE -> WAITING` 로 변경된다. - 스레드 대기 집합에서 관리된다.<img width="500" alt="스크린샷 2024-09-10 오후 5 58 03" src="https://github.com/user-attachments/assets/cea35b53-36fe-4df7-a023-f33256e48a52"><img width="500" alt="스크린샷 2024-09-10 오후 5 58 58" src="https://github.com/user-attachments/assets/9a726aed-2593-4d9a-ba26-0561789280b0"><img width="500" alt="스크린샷 2024-09-10 오후 6 03 54" src="https://github.com/user-attachments/assets/5264c2ba-1e27-4666-aa75-c9efad751ebf"><img width="500" alt="스크린샷 2024-09-10 오후 6 04 18" src="https://github.com/user-attachments/assets/026c7ca0-f870-424f-a2e1-e4df000ea866">- **그런데 대기 집합에 있는 스레드가 깨어난다고 바로 작동하는 것은 아니다. 깨어난 스레드는 여전히 임계 영역 안에 있다.**- 임계 영역에 있는 코드를 실행하려면 먼저 락이 필요하다. - `p3` 는 대기 집합에서는 나가지만 여전히 임계 영역에 있으므로 락을 획득하기 위해 `BLOCKED` 상태로 대기한다. - 당연한 이야기지만 임계 영역 안에서 2개의 스레드가 실행되면 큰 문제가 발생한다! 임계 영역 안에서는 락을 가지고 있는 하나의 스레드만 실행 되어야 한다.  - `p3` : `WAITING -> BLOCKED`***참고로 이때 임계 영역의 코드를 처음으로 돌아가서 실행하는 것은 아니다. 대기 집합에 들어오게 된 `wait()` 를 호출한 부분 부터 실행된다. 락을 획득하면 `wait()` 이후의 코드를 실행한다.***---### 🔋 실행 결과 - BoundedQueueV3, 소비자 먼저 실행<details><summary>실행 결과 - BoundedQueueV3, 소비자 먼저 실행</summary>```> Task :BoundedMain.main()18:09:04.557 [     main] == [소비자 먼저 실행] 시작, BoundedQueueV3 ==18:09:04.558 [     main] 소비자 시작18:09:04.561 [consumer1] [소비 시도]     ? <- []18:09:04.561 [consumer1] [take] 큐에 데이터가 없음, 소비자 대기18:09:04.662 [consumer2] [소비 시도]     ? <- []18:09:04.662 [consumer2] [take] 큐에 데이터가 없음, 소비자 대기18:09:04.765 [consumer3] [소비 시도]     ? <- []18:09:04.765 [consumer3] [take] 큐에 데이터가 없음, 소비자 대기18:09:04.867 [     main] 현재 상태 출력, 큐 데이터: []18:09:04.873 [     main] consumer1: WAITING18:09:04.873 [     main] consumer2: WAITING18:09:04.873 [     main] consumer3: WAITING18:09:04.875 [producer1] [생산 시도] data1 -> []18:09:04.875 [producer1] [put] 생산자 데이터 저장, notify() 호출18:09:04.875 [consumer1] [take] 소비자 깨어남18:09:04.875 [producer1] [생산 완료] data1 -> [data1]18:09:04.875 [consumer1] [take] 소비자 데이터 획득, notify() 호출18:09:04.875 [consumer2] [take] 소비자 깨어남18:09:04.876 [consumer1] [소비 완료] data1 <- []18:09:04.876 [consumer2] [take] 큐에 데이터가 없음, 소비자 대기18:09:04.980 [producer2] [생산 시도] data2 -> []18:09:04.980 [producer2] [put] 생산자 데이터 저장, notify() 호출18:09:04.981 [consumer3] [take] 소비자 깨어남18:09:04.981 [producer2] [생산 완료] data2 -> [data2]18:09:04.981 [consumer3] [take] 소비자 데이터 획득, notify() 호출18:09:04.981 [consumer2] [take] 소비자 깨어남18:09:04.981 [consumer3] [소비 완료] data2 <- []18:09:04.981 [consumer2] [take] 큐에 데이터가 없음, 소비자 대기18:09:05.083 [producer3] [생산 시도] data3 -> []18:09:05.084 [producer3] [put] 생산자 데이터 저장, notify() 호출18:09:05.084 [consumer2] [take] 소비자 깨어남18:09:05.084 [producer3] [생산 완료] data3 -> [data3]18:09:05.084 [consumer2] [take] 소비자 데이터 획득, notify() 호출18:09:05.085 [consumer2] [소비 완료] data3 <- []18:09:05.186 [     main] 현재 상태 출력, 큐 데이터: []18:09:05.187 [     main] consumer1: TERMINATED18:09:05.188 [     main] consumer2: TERMINATED18:09:05.188 [     main] consumer3: TERMINATED18:09:05.188 [     main] producer1: TERMINATED18:09:05.189 [     main] producer2: TERMINATED18:09:05.189 [     main] producer3: TERMINATED18:09:05.190 [     main] == [소비자 먼저 실행] 종료, BoundedQueueV3 ==```</details><img width="500" alt="스크린샷 2024-09-10 오후 6 11 06" src="https://github.com/user-attachments/assets/bb317c99-0f62-47bc-81c5-bbd874329de2"><img width="500" alt="스크린샷 2024-09-10 오후 6 10 36" src="https://github.com/user-attachments/assets/66453779-429f-4b4d-9acc-e68108399f24"><img width="500" alt="스크린샷 2024-09-10 오후 6 11 55" src="https://github.com/user-attachments/assets/69a15fc7-815e-49b0-8c86-79c31ccbd9e3">- 여기서 `c1` , `c2` , `c3` 중에 어떤 스레드가 깨어날까? 정답은 `"예측할 수 없다"`이다.- **어떤 스레드가 깨워질지는 JVM 스펙에 명시되어 있지 않다. 따라서 JVM 버전 환경등에 따라서 달라진다. 그런데 대기 집합에 있는 스레드가 깨어난다고 바로 작동하는 것은 아니다. 깨어난 스레드는 여전히 임계 영역 안에 있다.**- 임계 영역에 있는 코드를 실행하려면 먼저 락이 필요하다. 대기 집합에서는 나가지만 여전히 임계 영역에 있으므 로 락을 획득하기 위해 `BLOCKED` 상태로 대기한다.  - `c1` : `WAITING -> BLOCKED`<img width="500" alt="스크린샷 2024-09-10 오후 6 33 35" src="https://github.com/user-attachments/assets/656b3508-d262-4545-92d0-490271242cb9"><img width="500" alt="스크린샷 2024-09-10 오후 6 34 07" src="https://github.com/user-attachments/assets/1f4493b0-f4c7-49d3-8ecd-07a41abf3a37"><img width="500" alt="스크린샷 2024-09-10 오후 6 34 38" src="https://github.com/user-attachments/assets/09c2921c-25b8-4b56-a0f7-aff45a4c77fc">- ***`c1` 이 `notify()` 로 스레드 대기 집합에 알렸지만, 생산자 스레드가 아니라 소비자 스레드만 있다.*** - 따라서 의도 와는 다르게 소비자 스레드인 `c2` 가 대기 상태에서 깨어난다. - **물론 대기 집합에 있는 어떤 스레드가 깨어날지는 알 수 없다.** 여기서는 `c2` 가 깨어난다고 가정한다. - **심지어 생산자와 소비자 스레드가 함께 대기 집합에 있어도 어떤 스레드가 깨어날지는 알 수 없다.**<img width="500" alt="스크린샷 2024-09-10 오후 6 38 08" src="https://github.com/user-attachments/assets/8d18d12a-f703-49e1-8bac-53feed9a2abf"><img width="500" alt="스크린샷 2024-09-10 오후 6 38 25" src="https://github.com/user-attachments/assets/d75780be-b044-46de-8c09-dacfddc96aef"><img width="500" alt="스크린샷 2024-09-10 오후 6 38 42" src="https://github.com/user-attachments/assets/c0e69ac9-1247-4fbf-b67c-30146ea84634">- **소비자인 `c1` 이 같은 소비자인 `c2` 를 깨우는 것은 `상당히 비효율적`이다.**- `c1` 입장에서 `c2` 를 깨우게 되면 **아무 일도 하지 않고 그냥 다시 스레드 대기 집합에 들어갈 수 있다.** - ***결과적으로 CPU만 사용하고, 아무 일도 하지 않은 상태로 다시 대기 상태가 되어버린다.***- ***그렇다고 `c1` 이 스레드 대기 집합에 있는 어떤 스레드를 깨울지 선택할 수는 없다. `notify()` 는 스레드 대기 집합에 있는 스레드 중 임의의 하나를 깨울 뿐이다.***- 물론 이것이 비효율적이라는 것이지 문제가 되는 것은 아니다. 결과에는 문제가 없다. 가끔씩 약간 돌아서 갈 뿐이다.<br/><br/><br/># 💡 Object - wait, notify - 한계## ⚡️ 비효율성 - 같은 종류의 스래드를 깨울 때> ***같은 종류의 스레드를 깨울 때 비효율이 발생한다.***- 생산자가 같은 생산자를 깨우거나, 소비자가 같은 소비자를 깨울 때 비효율이 발생 할 수 있다는 점이다.## ⚡️ 스레드 기아(thread starvation)> ***어떤 스레드가 깨어날 지 알 수 없기 때문에 발생할 수 있는 스레드 기아 문제가 발생한다.***- **대기 상태의 스레드가 실행 순서를 계속 얻지 못해서 실행되지 않는 상황**을 `스레드 기아(starvation) 상태`라고 한다.- 결과적으로 **notifyAll()** 을 사용해서 스레드 기아 문제는 막을 수 있지만, **`비효율`을 막지는 못한다.**<br/><br/><br/># 💡 