# 생산자 소비자 문제(producer-consumer problem)<br/><br/><br/># 💡 생산자 소비자 문제(producer-consumer problem)> **멀티스레드 프로그래밍에서 자주 등장하는 동시성 문제 중 하나로, 여러 스레드가 동시에 데이터를 생산하고 소비하는 상황을 다룬다.**<u>**기본 개념**</u>- **`생산자(Producer)`**: **데이터를 생성하는 역할**을 한다.   - 예) 파일에서 데이터를 읽어오거나 네트워크에서 데이터를 받아오는 스레드가 생산자 역할을 할 수 있다.  - **`소비자(Consumer)`**: **생성된 데이터를 사용하는 역할**을 한다.   - 예) 데이터를 처리하거나 저장하는 스레드가 소비자 역할을 할 수 있다.  - **`버퍼(Buffer)`**: 생산자가 생성한 데이터를 일시적으로 저장하는 공간이다.   - 이 버퍼는 한정된 크기를 가지며, 생산자와 소비자가 이 버퍼를 통해 데이터를 주고받는다.<u>**문제 상황**</u>- **생산자가 너무 빠를 때**: 버퍼가 가득 차서 더 이상 데이터를 넣을 수 없을 때까지 생산자가 데이터를 생성한다.   - 버퍼가 가득 찬 경우 생산자는 버퍼에 빈 공간이 생길 때까지 기다려야 한다.- **소비자가 너무 빠를 때**: 버퍼가 비어서 더 이상 소비할 데이터가 없을 때까지 소비자가 데이터를 처리한다.   - 버퍼가 비어있을 때 소비자는 버퍼에 새로운 데이터가 들어올 때까지 기다려야 한다.<u>**생산자 소비자 문제 예시 그림 - 프린터 예제**</u><img width="500" alt="스크린샷 2024-09-10 오후 3 58 35" src="https://github.com/user-attachments/assets/050508ba-a752-4b03-8f87-4b231d863ed9">- **생산자 소비자 문제**`(producer-consumer problem)`: 생산자 소비자 문제는, 생산자 스레드와 소비자 스레드가 특정 자원을 함께 생산하고, 소비하면서 발생하는 문제이다.- **한정된 버퍼 문제**`(bounded-buffer problem)`: 이 문제는 결국 중간에 있는 버퍼의 크기가 한정되어 있기 때문에 발생한다. 따라서 한정된 버퍼 문제라고도 한다.**위의 2개 문제는 서로 같은 뜻이다.**<br/><br/><br/># 💡 생산자 소비자 문제 예제 1```javapublic interface BoundedQueue {    void put(String data);    String take();}``````javapublic class ProducerTask implements Runnable {    private BoundedQueue queue;    private String request;    public ProducerTask(BoundedQueue queue, String request) {        this.queue = queue;        this.request = request;    }    @Override    public void run() {        log("[생산 시도] " + request + " -> " + queue);        queue.put(request);        log("[생산 완료] " + request + " -> " + queue);    }}``````javapublic class ConsumerTask implements Runnable {    private BoundedQueue queue;    public ConsumerTask(BoundedQueue queue) {        this.queue = queue;    }    @Override    public void run() {        log("[소비 시도]     ? <- " + queue);        String data = queue.take();        log("[소비 완료] " + data + " <- " + queue);    }}``````javapublic class BoundedQueueV1 implements BoundedQueue {    private final Queue<String> queue = new ArrayDeque<>();    private final int max;    public BoundedQueueV1(int max) {        this.max = max;    }    @Override    public synchronized void put(String data) {        if (queue.size() == max) {            log("[put] 큐가 가득 참, 버림: " + data);            return;        }        queue.offer(data);    }    @Override    public synchronized String take() {        if (queue.isEmpty()) {            return null;        }        return queue.poll();    }    // 원칙적으로는 여기에도 synchronized 를 붙여줘야 한다.    // A 스레드가 큐에 접근 중일 때, B 스레드가 toString() 을 호출한다면 기대하지 않는 값을 얻을 수 있기 때문에 원칙적으로는 synchronized 를 붙여줘야 한다.    @Override    public String toString() {        return queue.toString();    }}````synchronized`- 원칙적으로는 여기에도 synchronized 를 붙여줘야 한다. - A 스레드가 큐에 접근 중일 때, B 스레드가 toString() 을 호출한다면 기대하지 않는 값을 얻을 수 있기 때문에 원칙적으로는 synchronized 를 붙여줘야 한다.<u>**임계 영역`(critical section)`**</u>- **핵심 공유 자원**은 `queue(ArrayDeque)`- 여러 스레드가 함께 접근해서 공유해야 하므로 `synchronized` 를 사용해서 `한번에 하나의 스레드만 접근(put(), take())`할 수 있도록 제한한다.```javapackage thread.bounded;import static util.MyLogger.log;import static util.ThreadUtils.sleep;import java.util.ArrayList;import java.util.List;public class BoundedMain {    public static void main(String[] args) {        // 1. BoundedQueue 선택        BoundedQueue queue = new BoundedQueueV1(2);//        BoundedQueue queue = new BoundedQueueV2(2);//        BoundedQueue queue = new BoundedQueueV3(2);//        BoundedQueue queue = new BoundedQueueV4(2);//        BoundedQueue queue = new BoundedQueueV5(2);//        BoundedQueue queue = new BoundedQueueV6_1(2);//        BoundedQueue queue = new BoundedQueueV6_2(2);//        BoundedQueue queue = new BoundedQueueV6_3(2);//        BoundedQueue queue = new BoundedQueueV6_4(2);        // 2. 생산자, 소비자 실행 순서 선택, 반드시 하나만 선택!        producerFirst(queue); // 생산자 먼저 실행//        consumerFirst(queue); // 소비자 먼저 실행    }    private static void producerFirst(BoundedQueue queue) {        log("== [생산자 먼저 실행] 시작, " + queue.getClass().getSimpleName() + " ==");        List<Thread> threads = new ArrayList<>();        startProducer(queue, threads);        printAllState(queue, threads);        startConsumer(queue, threads);        printAllState(queue, threads);        log("== [생산자 먼저 실행] 종료, " + queue.getClass().getSimpleName() + " ==");    }    private static void consumerFirst(BoundedQueue queue) {        log("== [소비자 먼저 실행] 시작, " + queue.getClass().getSimpleName() + " ==");        List<Thread> threads = new ArrayList<>();        startConsumer(queue, threads);        printAllState(queue, threads);        startProducer(queue, threads);        printAllState(queue, threads);        log("== [소비자 먼저 실행] 종료, " + queue.getClass().getSimpleName() + " ==");    }    private static void startProducer(BoundedQueue queue, List<Thread> threads) {        System.out.println();        for (int i = 1; i <= 3; i++) {            Thread producer = new Thread(new ProducerTask(queue, "data" + i), "producer" + i);            threads.add(producer);            producer.start();            sleep(100);        }    }    private static void printAllState(BoundedQueue queue, List<Thread> threads) {        System.out.println();        log("현재 상태 출력, 큐 데이터: " + queue);        for (Thread thread : threads) {            log(thread.getName() + ": " + thread.getState());        }    }    private static void startConsumer(BoundedQueue queue, List<Thread> threads) {        System.out.println();        log("소비자 시작");        for (int i = 1; i <= 3; i++) {            Thread consumer = new Thread(new ConsumerTask(queue), "consumer" + i);            threads.add(consumer);            consumer.start();            sleep(100);        }    }}```<u>**BoundedQueue 선택**</u>- `BoundedQueue queue = new BoundedQueueV1(2);`  - `BoundedQueue` 의 구현체를 선택해서 생성한다.   - 버퍼의 크기는 `2` 를 사용한다. 따라서 버퍼에는 데이터를 2개 까지만 보관할 수 있다.     - 만약 생산자가 2개를 넘어서는 데이터를 추가로 저장하려고 하면 문제가 발생한다.     - 반대로 버퍼에 데이터가 없는데, 소비자가 데이터를 가져갈 때도 문제가 발생한다.<u>`startProducer()`, `startConsumer()`</u>- **여기서는 이해를 돕기 위해 `sleep(100)` 을 주면서 스레드를 0.1초 단위로 쉬면서 순서대로 실행한다.**<img width="500" alt="스크린샷 2024-09-10 오후 4 59 35" src="https://github.com/user-attachments/assets/db645f1f-ca1d-443d-aebc-da0955d3969c">- 임계 영역은 `synchronized` 를 영역을 뜻한다. 스레드가 이 영역에 들어가려면 모니터 락( `lock` )이 필요하다.---### 🔋 실행 결과 - BoundedQueueV1, 생산자 먼저 실행<details><summary>실행 결과 - BoundedQueueV1, 생산자 먼저 실행</summary>```> Task :BoundedMain.main()16:33:31.244 [     main] == [생산자 먼저 실행] 시작, BoundedQueueV1 ==16:33:31.251 [producer1] [생산 시도] data1 -> []16:33:31.251 [producer1] [생산 완료] data1 -> [data1]16:33:31.353 [producer2] [생산 시도] data2 -> [data1]16:33:31.353 [producer2] [생산 완료] data2 -> [data1, data2]16:33:31.458 [producer3] [생산 시도] data3 -> [data1, data2]16:33:31.459 [producer3] [put] 큐가 가득 참, 버림: data316:33:31.459 [producer3] [생산 완료] data3 -> [data1, data2]16:33:31.564 [     main] 현재 상태 출력, 큐 데이터: [data1, data2]16:33:31.564 [     main] producer1: TERMINATED16:33:31.565 [     main] producer2: TERMINATED16:33:31.565 [     main] producer3: TERMINATED16:33:31.565 [     main] 소비자 시작16:33:31.567 [consumer1] [소비 시도]     ? <- [data1, data2]16:33:31.568 [consumer1] [소비 완료] data1 <- [data2]16:33:31.672 [consumer2] [소비 시도]     ? <- [data2]16:33:31.672 [consumer2] [소비 완료] data2 <- []16:33:31.773 [consumer3] [소비 시도]     ? <- []16:33:31.773 [consumer3] [소비 완료] null <- []16:33:31.878 [     main] 현재 상태 출력, 큐 데이터: []16:33:31.879 [     main] producer1: TERMINATED16:33:31.879 [     main] producer2: TERMINATED16:33:31.879 [     main] producer3: TERMINATED16:33:31.880 [     main] consumer1: TERMINATED16:33:31.880 [     main] consumer2: TERMINATED16:33:31.880 [     main] consumer3: TERMINATED16:33:31.881 [     main] == [생산자 먼저 실행] 종료, BoundedQueueV1 ==```</details><img width="500" alt="스크린샷 2024-09-10 오후 5 00 41" src="https://github.com/user-attachments/assets/7e0e8baa-1764-4ef2-bf0d-4d8aa958c011"><u>**데이터를 버리지 않는 대안**</u>       `data3` 을 버리지 않는 대안은, 큐에 빈 공간이 생길 때 까지 `p3` 스레드가 기다리는 것이다.**그럼 어떻게 기다릴 수 있을까?** - 단순하게 생각하면 생산자 스레드가 반복문을 사용해서 큐에 빈 공간이 생기는지 주기적으로 체크한 다음에, - 만약 빈 공간이 없다면 `sleep()` 을 짧게 사용해서 잠시 대기하고, 깨어난 다음에 다시 반복문에서 큐의 빈 공간을 체크하는 식으로 구현하면 될 것 같다.<br/><img width="500" alt="스크린샷 2024-09-10 오후 5 03 58" src="https://github.com/user-attachments/assets/65014b43-9ff7-4ed6-93ab-20b9fc957d36"><u>**큐에 데이터가 없다면 기다리자**</u>     **소비자 입장에서 큐에 데이터가 없다면 기다리는 것도 대안이다.****그럼 어떻게 기다릴 수 있을까?**- 단순하게 생각하면 소비자 스레드가 반복문을 사용해서 큐에 데이터가 있는지 주기적으로 체크한 다음에, - 만약 데이터가 없다면 `sleep()` 을 짧게 사용해서 잠시 대기하고, 깨어난 다음에 다시 반복문에서 큐에 데이터가 있는지 체크하는 식으로 구현하면 될 것 같다.---### 🔋 실행 결과 - BoundedQueueV1, 소비자 먼저 실행<details><summary>실행 결과 - BoundedQueueV1, 소비자 먼저 실행</summary>```> Task :BoundedMain.main()16:35:09.888 [     main] == [소비자 먼저 실행] 시작, BoundedQueueV1 ==16:35:09.890 [     main] 소비자 시작16:35:09.893 [consumer1] [소비 시도]     ? <- []16:35:09.895 [consumer1] [소비 완료] null <- []16:35:09.994 [consumer2] [소비 시도]     ? <- []16:35:09.994 [consumer2] [소비 완료] null <- []16:35:10.094 [consumer3] [소비 시도]     ? <- []16:35:10.095 [consumer3] [소비 완료] null <- []16:35:10.200 [     main] 현재 상태 출력, 큐 데이터: []16:35:10.200 [     main] consumer1: TERMINATED16:35:10.201 [     main] consumer2: TERMINATED16:35:10.201 [     main] consumer3: TERMINATED16:35:10.202 [producer1] [생산 시도] data1 -> []16:35:10.202 [producer1] [생산 완료] data1 -> [data1]16:35:10.307 [producer2] [생산 시도] data2 -> [data1]16:35:10.307 [producer2] [생산 완료] data2 -> [data1, data2]16:35:10.412 [producer3] [생산 시도] data3 -> [data1, data2]16:35:10.413 [producer3] [put] 큐가 가득 참, 버림: data316:35:10.414 [producer3] [생산 완료] data3 -> [data1, data2]16:35:10.514 [     main] 현재 상태 출력, 큐 데이터: [data1, data2]16:35:10.515 [     main] consumer1: TERMINATED16:35:10.515 [     main] consumer2: TERMINATED16:35:10.515 [     main] consumer3: TERMINATED16:35:10.516 [     main] producer1: TERMINATED16:35:10.516 [     main] producer2: TERMINATED16:35:10.516 [     main] producer3: TERMINATED16:35:10.517 [     main] == [소비자 먼저 실행] 종료, BoundedQueueV1 ==```</details><img width="500" alt="스크린샷 2024-09-10 오후 5 11 12" src="https://github.com/user-attachments/assets/d238b938-dd7d-4df5-846b-71b13f7974c6">- 큐에 데이터가 없으므로 `null` 을 반환한다. 결과적으로 `c1` , `c2` , `c3` 모두 데이터를 받지 못하고 종료된다.<br/><img width="500" alt="스크린샷 2024-09-10 오후 5 12 56" src="https://github.com/user-attachments/assets/7b8710ba-c6a7-49a6-8680-0a260a498fd2"><img width="500" alt="스크린샷 2024-09-10 오후 5 13 31" src="https://github.com/user-attachments/assets/6a40484a-4ae0-4671-adcd-4da6c70759b4">### 🔋 **문제점**- **버퍼가 가득 찬 경우**: 생산자 입장에서 버퍼에 여유가 생길 때 까지 조금만 기다리면 되는데, 기다리지 못하고, 데 이터를 버리는 것은 아쉽다.- **버퍼가 빈 경우**: 소비자 입장에서 버퍼에 데이터가 채워질 때 까지 조금만 기다리면 되는데, 기다리지 못하고, `null` 데이터를 얻는 것은 아쉽다.---## ⚡️ 해결방법**문제의 해결 방안은 단순하다. `스레드가 기다리면` 되는 것이다!**<br/><br/><br/># 💡 생산자 소비자 문제 예제 2```javapublic class BoundedQueueV2 implements BoundedQueue {    private final Queue<String> queue = new ArrayDeque<>();    private final int max;    public BoundedQueueV2(int max) {        this.max = max;    }    @Override    public synchronized void put(String data) {        while (queue.size() == max) {            log("[put] 큐가 가득 참, 생산자 대기");            sleep(1000);            Thread.yield();        }        queue.offer(data);    }    @Override    public synchronized String take() {        while (queue.isEmpty()) {            log("[take] 큐에 데이터가 없음, 소비자 대기");            sleep(1000);            Thread.yield();        }        return queue.poll();    }    // 원칙적으로는 여기에도 synchronized 를 붙여줘야 한다.    // A 스레드가 큐에 접근 중일 때, B 스레드가 toString() 을 호출한다면 기대하지 않는 값을 얻을 수 있기 때문에 원칙적으로는 synchronized 를 붙여줘야 한다.    @Override    public String toString() {        return queue.toString();    }}```<u>**`put(data)` - 데이터를 버리지 않는 대안**</u>- `data3` 을 버리지 않는 대안은, 큐가 가득 찾을 때, 큐에 빈 공간이 생길 때 까지, 생산자 스레드가 기다리면 된다. - 여기서는 생산자 스레드가 반복문을 사용해서 큐에 빈 공간이 생기는지 주기적으로 체크한다. - 만약 빈 공간이 없다면 `sleep()` 을 사용해서 잠시 대기하고, 깨어난 다음에 다시 반복문에서 큐의 빈 공간을 체크하는 식으로 구현했다.<u>**`take()` - 큐에 데이터가 없다면 기다리자**</u>- 소비자 입장에서 큐에 데이터가 없다면 기다리는 것도 대안이다. - 큐에 데이터가 없을 때 `null` 을 받지 않는 대안은, 큐에 데이터가 추가될 때 까지 소비자 스레드가 기다리는 것이다.- 여기서는 소비자 스레드가 반복문을 사용해서 큐에 데이터가 있는지 주기적으로 체크한 다음에, - 만약 데이터가 없다면 `sleep()` 을 사용해서 잠시 대기하고, 깨어난 다음에 다시 반복문에서 큐에 데이터가 있는지 체크하는 식으로 구현했---### 🔋 실행 결과 - BoundedQueueV2, 생산자 먼저 실행<details><summary>실행 결과 - BoundedQueueV2, 생산자 먼저 실행</summary>```> Task :BoundedMain.main()17:24:48.118 [     main] == [생산자 먼저 실행] 시작, BoundedQueueV2 ==17:24:48.125 [producer1] [생산 시도] data1 -> []17:24:48.125 [producer1] [생산 완료] data1 -> [data1]17:24:48.227 [producer2] [생산 시도] data2 -> [data1]17:24:48.228 [producer2] [생산 완료] data2 -> [data1, data2]17:24:48.331 [producer3] [생산 시도] data3 -> [data1, data2]17:24:48.331 [producer3] [put] 큐가 가득 참, 생산자 대기17:24:48.437 [     main] 현재 상태 출력, 큐 데이터: [data1, data2]17:24:48.437 [     main] producer1: TERMINATED17:24:48.437 [     main] producer2: TERMINATED17:24:48.438 [     main] producer3: TIMED_WAITING17:24:48.438 [     main] 소비자 시작17:24:48.438 [consumer1] [소비 시도]     ? <- [data1, data2]17:24:48.539 [consumer2] [소비 시도]     ? <- [data1, data2]17:24:48.645 [consumer3] [소비 시도]     ? <- [data1, data2]17:24:48.750 [     main] 현재 상태 출력, 큐 데이터: [data1, data2]17:24:48.750 [     main] producer1: TERMINATED17:24:48.750 [     main] producer2: TERMINATED17:24:48.751 [     main] producer3: TIMED_WAITING17:24:48.751 [     main] consumer1: BLOCKED17:24:48.751 [     main] consumer2: BLOCKED17:24:48.751 [     main] consumer3: BLOCKED17:24:48.752 [     main] == [생산자 먼저 실행] 종료, BoundedQueueV2 ==17:24:49.337 [producer3] [put] 큐가 가득 참, 생산자 대기17:24:50.341 [producer3] [put] 큐가 가득 참, 생산자 대기17:24:51.347 [producer3] [put] 큐가 가득 참, 생산자 대기17:24:52.352 [producer3] [put] 큐가 가득 참, 생산자 대기17:24:53.356 [producer3] [put] 큐가 가득 참, 생산자 대기```</details><img width="500" alt="스크린샷 2024-09-10 오후 5 26 03" src="https://github.com/user-attachments/assets/3e3dd479-d220-4e22-a9a8-62524472e1ef">`p3` 는 `sleep(1000)` 을사용해서잠시대기한다.이때 `RUNNABLE -> TIMED_WAITING` 상태가된다.- 빈 자리가 없다면 `sleep()` 으로 잠시 대기한 다음 반복문을 계속해서 수행한다. 1초마다 한 번씩 체크하 기 때문에 `"큐가 가득 참, 생산자 대기"`라는 메시지가 계속 출력될 것이다.**여기서 핵심은 `p3` 스레드가 락을 가지고 있는 상태에서, 큐에 빈 자리가 나올 때 까지 대기한다는 점이다.**<br/><img width="500" alt="스크린샷 2024-09-10 오후 5 29 27" src="https://github.com/user-attachments/assets/eb1a5ea1-e67c-442f-b79e-f82e6d0aa097"><u>**무한 대기 문제**</u>- `p3` 가 락을 가지고 임계영역에 이미 들어가 있기 때문이다. - `p3` 가 락을 반납하기 전까지는 `c1`, `c2`, `c3` 은 절대로 임계 영역(여기서는 `synchronized`)에 들어갈 수 없다!**락을 반납하려면 `c1` 이 먼저 큐의 데이터를 소비해야 한다. 그래야 `p3` 가 큐에 `data3` 을 저장하고 임계영역을 빠져나가며 락을 반납할 수 있다.**     ***그런데 `p3` 가 `락을 가지고 임계영역 안`에 있기 때문에, 임계영역 밖의 `c1` 은 락을 획득할 수 없으므로, 큐에 접근하지 못하고 `무한 대기`한다.***> **결과적으로 `c1` , `c2` , `c3` 는 모두 락을 획득하기 위해 `BLOCKED` 상태로 대기한다.** 결국 이런 상태가 무한하게 지속된다.---### 🔋 실행 결과 - BoundedQueueV2, 소비자 먼저 실행<details><summary>실행 결과 - BoundedQueueV2, 소비자 먼저 실행</summary>```> Task :BoundedMain.main()17:35:02.518 [     main] == [소비자 먼저 실행] 시작, BoundedQueueV2 ==17:35:02.519 [     main] 소비자 시작17:35:02.522 [consumer1] [소비 시도]     ? <- []17:35:02.522 [consumer1] [take] 큐에 데이터가 없음, 소비자 대기17:35:02.623 [consumer2] [소비 시도]     ? <- []17:35:02.727 [consumer3] [소비 시도]     ? <- []17:35:02.833 [     main] 현재 상태 출력, 큐 데이터: []17:35:02.836 [     main] consumer1: TIMED_WAITING17:35:02.836 [     main] consumer2: BLOCKED17:35:02.836 [     main] consumer3: BLOCKED17:35:02.837 [producer1] [생산 시도] data1 -> []17:35:02.941 [producer2] [생산 시도] data2 -> []17:35:03.047 [producer3] [생산 시도] data3 -> []17:35:03.152 [     main] 현재 상태 출력, 큐 데이터: []17:35:03.152 [     main] consumer1: TIMED_WAITING17:35:03.152 [     main] consumer2: BLOCKED17:35:03.153 [     main] consumer3: BLOCKED17:35:03.153 [     main] producer1: BLOCKED17:35:03.153 [     main] producer2: BLOCKED17:35:03.153 [     main] producer3: BLOCKED17:35:03.153 [     main] == [소비자 먼저 실행] 종료, BoundedQueueV2 ==17:35:03.525 [consumer1] [take] 큐에 데이터가 없음, 소비자 대기17:35:04.530 [consumer1] [take] 큐에 데이터가 없음, 소비자 대기17:35:05.533 [consumer1] [take] 큐에 데이터가 없음, 소비자 대기17:35:06.538 [consumer1] [take] 큐에 데이터가 없음, 소비자 대기```</details><u>**무한 대기 문제**</u><img width="500" alt="스크린샷 2024-09-10 오후 5 37 00" src="https://github.com/user-attachments/assets/d8b51faf-f941-48bd-b9e9-9022aef6310f">- `c1` 은 `sleep(1000)` 을 사용해서 잠시 대기한다. 이때 `RUNNABLE -> TIMED_WAITING` 상태가된다.- `c1` 이 락을 가지고 임계영역에 들어가 있기 때문에, `c2`, `c3` 는 절대로 임계 영역(여기서는 `synchronized` )은 들어갈 수 없고, `BLOCKED` 상태가 된다.- 락을 반납하려면 `p1` 이 먼저 큐의 데이터를 추가해야 한다. 그래야 `c1` 이 큐에서 데이터를 획득하고 임계영역을 빠져나가며 락을 반납할 수 있다.- 그런데 `c1` 이 락을 가지고 임계영역 안에 있기 때문에, 임계영역 밖의 `p1` 은 락을 획득할 수 없으므로, 큐에 접근하지 못하고 무한 대기한다.**결과적으로 `c1` 을 제외한 모든 스레드가 락을 획득하기 위해 `BLOCKED` 상태로 대기한다.**---## ⚡️ 해결방법생각해보면 결국 임계 영역 안에서 락을 가지고 대기하는 것이 문제이다. 이것은 마치 열쇠를 가진 사람이 안에서 문을 잠궈버린 것과 같다.> **"락을 가지고 대기하는 스레드가 대기하는 동안 다른 스레드에게 락을 양보할 수 있다면, 이 문제를 쉽게 풀 수 있다."**자바의 `Object.wait()` , `Object.noitfy()` 를 사용하면 락을 가지고 대기하는 스레드가 대기하는 동안 다른 스레드에게 락을 양보할 수 있다.<br/><br/><br/># 💡 생산자 소비자 문제 예제 3 - Object - wait, notify### 🔋 Object.wait()- 현재 스레드가 가진 락을 반납하고 대기( `WAITING` )한다. - 현재 스레드를 대기( `WAITING` ) 상태로 전환한다. **이 메서드는 현재 스레드가 `synchronized` 블록이나 메서드에서 락을 소유하고 있을 때만 호출할 수 있다.** - 호출한 스레드는 락을 반납하고, 다른 스레드가 해당 락을 획득할 수 있도록 한다. - 이렇게 대기 상태로 전환된 스레드는 다른 스레드가 `notify()` 또는 `notifyAll()` 을 호출할 때까지 대기 상태를 유지한다. ### 🔋 Object.notify()- 대기 중인 스레드 중 하나를 깨운다.- **이 메서드는 `synchronized` 블록이나 메서드에서 호출되어야 한다.** 깨운 스레드는 락을 다시 획득할 기회를 얻게 된다. - 만약 대기 중인 스레드가 여러 개라면, 그 중 하나만이 깨워지게 된다. ### 🔋 Object.notifyAll()- 대기 중인 모든 스레드를 깨운다.- **이 메서드 역시 `synchronized` 블록이나 메서드에서 호출되어야 하며,** 모든 대기 중인 스레드가 락을 획 득할 수 있는 기회를 얻게 된다. - 이 방법은 모든 스레드를 깨워야 할 필요가 있는 경우에 유용하다.```javapublic class BoundedQueueV3 implements BoundedQueue {    private final Queue<String> queue = new ArrayDeque<>();    private final int max;    public BoundedQueueV3(int max) {        this.max = max;    }    @Override    public synchronized void put(String data) {        while (queue.size() == max) {            log("[put] 큐가 가득 참, 생산자 대기");            try {                wait(); // RUNNABLE -> WAITING, 락 반납                log("[put] 생산자 깨어남");            } catch (InterruptedException e) {                throw new RuntimeException(e);            }        }        queue.offer(data);        log("[put] 생산자 데이터 저장, notify() 호출");        notify(); // 대기 스레드, WAITING -> BLOCKED    }    @Override    public synchronized String take() {        while (queue.isEmpty()) {            log("[take] 큐에 데이터가 없음, 소비자 대기");            try {                wait(); // RUNNABLE -> WAITING, 락 반납                log("[take] 소비자 깨어남");            } catch (InterruptedException e) {                throw new RuntimeException(e);            }        }        String data = queue.poll();        log("[take] 소비자 데이터 획득, notify() 호출");        notify(); // 대기 스레드, WAITING -> BLOCKED        return data;    }    // 원칙적으로는 여기에도 synchronized 를 붙여줘야 한다.    // A 스레드가 큐에 접근 중일 때, B 스레드가 toString() 을 호출한다면 기대하지 않는 값을 얻을 수 있기 때문에 원칙적으로는 synchronized 를 붙여줘야 한다.    @Override    public String toString() {        return queue.toString();    }}```<u>**put(data) - wait(), notify()**</u>- `Object.wait()` 을 사용해서 대기한다. **대기할 때 락을 반납하고 대기**한다. - `wait()` 를 호출해서 대기하는 경우 `RUNNABLE -> WAITING` 상태가 된다.<u>**take() - wait(), notify()**</u>- `Object.wait()` 을 사용해서 대기한다. **대기할 때 락을 반납하고 대기**한다.- 대기하는 경우 `RUNNABLE -> WAITING` 상태가 된다.> **여기서 중요한 핵심은 `wait()` 를 호출해서 대기 상태에 빠질 때 `락을 반납하고` 대기 상태에 빠진다는 것이다.**### 🔋 **스레드 대기 집합(wait set)**<img width="500" alt="스크린샷 2024-09-10 오후 5 49 33" src="https://github.com/user-attachments/assets/9ab52d65-8229-4683-845c-76e99522340b">`synchronized` 임계 영역 안에서 `Object.wait()` 를 호출하면 스레드는 대기( `WAITING` ) 상태에 들어간다.> **`대기 상태에 들어간 스레드를 관리하는 것`을 `대기 집합(wait set)`이라 한다.**- ***모든 객체는 `각자의 대기 집합`을 가지고 있다.***- ***모든 객체는 `락(모니터 락)`과 `대기 집합`을 가지고 있다.*** **둘은 한 쌍으로 사용된다.** - 따라서 락을 획득한 객체의 대기 집합을 사용해야 한다.---### 🔋 실행 결과 - BoundedQueueV3, 생산자 먼저 실행<details><summary>실행 결과 - BoundedQueueV3, 생산자 먼저 실행</summary>```> Task :BoundedMain.main()17:53:04.527 [     main] == [생산자 먼저 실행] 시작, BoundedQueueV3 ==17:53:04.534 [producer1] [생산 시도] data1 -> []17:53:04.534 [producer1] [put] 생산자 데이터 저장, notify() 호출17:53:04.534 [producer1] [생산 완료] data1 -> [data1]17:53:04.631 [producer2] [생산 시도] data2 -> [data1]17:53:04.631 [producer2] [put] 생산자 데이터 저장, notify() 호출17:53:04.632 [producer2] [생산 완료] data2 -> [data1, data2]17:53:04.733 [producer3] [생산 시도] data3 -> [data1, data2]17:53:04.733 [producer3] [put] 큐가 가득 참, 생산자 대기17:53:04.838 [     main] 현재 상태 출력, 큐 데이터: [data1, data2]17:53:04.838 [     main] producer1: TERMINATED17:53:04.838 [     main] producer2: TERMINATED17:53:04.838 [     main] producer3: WAITING17:53:04.838 [     main] 소비자 시작17:53:04.840 [consumer1] [소비 시도]     ? <- [data1, data2]17:53:04.840 [consumer1] [take] 소비자 데이터 획득, notify() 호출17:53:04.840 [producer3] [put] 생산자 깨어남17:53:04.840 [consumer1] [소비 완료] data1 <- [data2]17:53:04.840 [producer3] [put] 생산자 데이터 저장, notify() 호출17:53:04.840 [producer3] [생산 완료] data3 -> [data2, data3]17:53:04.945 [consumer2] [소비 시도]     ? <- [data2, data3]17:53:04.945 [consumer2] [take] 소비자 데이터 획득, notify() 호출17:53:04.945 [consumer2] [소비 완료] data2 <- [data3]17:53:05.047 [consumer3] [소비 시도]     ? <- [data3]17:53:05.048 [consumer3] [take] 소비자 데이터 획득, notify() 호출17:53:05.048 [consumer3] [소비 완료] data3 <- []17:53:05.152 [     main] 현재 상태 출력, 큐 데이터: []17:53:05.153 [     main] producer1: TERMINATED17:53:05.153 [     main] producer2: TERMINATED17:53:05.153 [     main] producer3: TERMINATED17:53:05.153 [     main] consumer1: TERMINATED17:53:05.154 [     main] consumer2: TERMINATED17:53:05.154 [     main] consumer3: TERMINATED17:53:05.154 [     main] == [생산자 먼저 실행] 종료, BoundedQueueV3 ==```</details><img width="500" alt="스크린샷 2024-09-10 오후 5 56 54" src="https://github.com/user-attachments/assets/adb47264-82a9-4348-8a98-63c0ab356903">`wait()` 를 호출하면- 락을 반납한다. - 스레드의 상태가 `RUNNABLE -> WAITING` 로 변경된다. - 스레드 대기 집합에서 관리된다.<img width="500" alt="스크린샷 2024-09-10 오후 5 58 03" src="https://github.com/user-attachments/assets/cea35b53-36fe-4df7-a023-f33256e48a52"><img width="500" alt="스크린샷 2024-09-10 오후 5 58 58" src="https://github.com/user-attachments/assets/9a726aed-2593-4d9a-ba26-0561789280b0"><img width="500" alt="스크린샷 2024-09-10 오후 6 03 54" src="https://github.com/user-attachments/assets/5264c2ba-1e27-4666-aa75-c9efad751ebf"><img width="500" alt="스크린샷 2024-09-10 오후 6 04 18" src="https://github.com/user-attachments/assets/026c7ca0-f870-424f-a2e1-e4df000ea866">- **그런데 대기 집합에 있는 스레드가 깨어난다고 바로 작동하는 것은 아니다. 깨어난 스레드는 여전히 임계 영역 안에 있다.**- 임계 영역에 있는 코드를 실행하려면 먼저 락이 필요하다. - `p3` 는 대기 집합에서는 나가지만 여전히 임계 영역에 있으므로 락을 획득하기 위해 `BLOCKED` 상태로 대기한다. - 당연한 이야기지만 임계 영역 안에서 2개의 스레드가 실행되면 큰 문제가 발생한다! 임계 영역 안에서는 락을 가지고 있는 하나의 스레드만 실행 되어야 한다.  - `p3` : `WAITING -> BLOCKED`***참고로 이때 임계 영역의 코드를 처음으로 돌아가서 실행하는 것은 아니다. 대기 집합에 들어오게 된 `wait()` 를 호출한 부분 부터 실행된다. 락을 획득하면 `wait()` 이후의 코드를 실행한다.***---### 🔋 실행 결과 - BoundedQueueV3, 소비자 먼저 실행<details><summary>실행 결과 - BoundedQueueV3, 소비자 먼저 실행</summary>```> Task :BoundedMain.main()18:09:04.557 [     main] == [소비자 먼저 실행] 시작, BoundedQueueV3 ==18:09:04.558 [     main] 소비자 시작18:09:04.561 [consumer1] [소비 시도]     ? <- []18:09:04.561 [consumer1] [take] 큐에 데이터가 없음, 소비자 대기18:09:04.662 [consumer2] [소비 시도]     ? <- []18:09:04.662 [consumer2] [take] 큐에 데이터가 없음, 소비자 대기18:09:04.765 [consumer3] [소비 시도]     ? <- []18:09:04.765 [consumer3] [take] 큐에 데이터가 없음, 소비자 대기18:09:04.867 [     main] 현재 상태 출력, 큐 데이터: []18:09:04.873 [     main] consumer1: WAITING18:09:04.873 [     main] consumer2: WAITING18:09:04.873 [     main] consumer3: WAITING18:09:04.875 [producer1] [생산 시도] data1 -> []18:09:04.875 [producer1] [put] 생산자 데이터 저장, notify() 호출18:09:04.875 [consumer1] [take] 소비자 깨어남18:09:04.875 [producer1] [생산 완료] data1 -> [data1]18:09:04.875 [consumer1] [take] 소비자 데이터 획득, notify() 호출18:09:04.875 [consumer2] [take] 소비자 깨어남18:09:04.876 [consumer1] [소비 완료] data1 <- []18:09:04.876 [consumer2] [take] 큐에 데이터가 없음, 소비자 대기18:09:04.980 [producer2] [생산 시도] data2 -> []18:09:04.980 [producer2] [put] 생산자 데이터 저장, notify() 호출18:09:04.981 [consumer3] [take] 소비자 깨어남18:09:04.981 [producer2] [생산 완료] data2 -> [data2]18:09:04.981 [consumer3] [take] 소비자 데이터 획득, notify() 호출18:09:04.981 [consumer2] [take] 소비자 깨어남18:09:04.981 [consumer3] [소비 완료] data2 <- []18:09:04.981 [consumer2] [take] 큐에 데이터가 없음, 소비자 대기18:09:05.083 [producer3] [생산 시도] data3 -> []18:09:05.084 [producer3] [put] 생산자 데이터 저장, notify() 호출18:09:05.084 [consumer2] [take] 소비자 깨어남18:09:05.084 [producer3] [생산 완료] data3 -> [data3]18:09:05.084 [consumer2] [take] 소비자 데이터 획득, notify() 호출18:09:05.085 [consumer2] [소비 완료] data3 <- []18:09:05.186 [     main] 현재 상태 출력, 큐 데이터: []18:09:05.187 [     main] consumer1: TERMINATED18:09:05.188 [     main] consumer2: TERMINATED18:09:05.188 [     main] consumer3: TERMINATED18:09:05.188 [     main] producer1: TERMINATED18:09:05.189 [     main] producer2: TERMINATED18:09:05.189 [     main] producer3: TERMINATED18:09:05.190 [     main] == [소비자 먼저 실행] 종료, BoundedQueueV3 ==```</details><img width="500" alt="스크린샷 2024-09-10 오후 6 11 06" src="https://github.com/user-attachments/assets/bb317c99-0f62-47bc-81c5-bbd874329de2"><img width="500" alt="스크린샷 2024-09-10 오후 6 10 36" src="https://github.com/user-attachments/assets/66453779-429f-4b4d-9acc-e68108399f24"><img width="500" alt="스크린샷 2024-09-10 오후 6 11 55" src="https://github.com/user-attachments/assets/69a15fc7-815e-49b0-8c86-79c31ccbd9e3">- 여기서 `c1` , `c2` , `c3` 중에 어떤 스레드가 깨어날까? 정답은 `"예측할 수 없다"`이다.- **어떤 스레드가 깨워질지는 JVM 스펙에 명시되어 있지 않다. 따라서 JVM 버전 환경등에 따라서 달라진다. 그런데 대기 집합에 있는 스레드가 깨어난다고 바로 작동하는 것은 아니다. 깨어난 스레드는 여전히 임계 영역 안에 있다.**- 임계 영역에 있는 코드를 실행하려면 먼저 락이 필요하다. 대기 집합에서는 나가지만 여전히 임계 영역에 있으므 로 락을 획득하기 위해 `BLOCKED` 상태로 대기한다.  - `c1` : `WAITING -> BLOCKED`<img width="500" alt="스크린샷 2024-09-10 오후 6 33 35" src="https://github.com/user-attachments/assets/656b3508-d262-4545-92d0-490271242cb9"><img width="500" alt="스크린샷 2024-09-10 오후 6 34 07" src="https://github.com/user-attachments/assets/1f4493b0-f4c7-49d3-8ecd-07a41abf3a37"><img width="500" alt="스크린샷 2024-09-10 오후 6 34 38" src="https://github.com/user-attachments/assets/09c2921c-25b8-4b56-a0f7-aff45a4c77fc">- ***`c1` 이 `notify()` 로 스레드 대기 집합에 알렸지만, 생산자 스레드가 아니라 소비자 스레드만 있다.*** - 따라서 의도 와는 다르게 소비자 스레드인 `c2` 가 대기 상태에서 깨어난다. - **물론 대기 집합에 있는 어떤 스레드가 깨어날지는 알 수 없다.** 여기서는 `c2` 가 깨어난다고 가정한다. - **심지어 생산자와 소비자 스레드가 함께 대기 집합에 있어도 어떤 스레드가 깨어날지는 알 수 없다.**<img width="500" alt="스크린샷 2024-09-10 오후 6 38 08" src="https://github.com/user-attachments/assets/8d18d12a-f703-49e1-8bac-53feed9a2abf"><img width="500" alt="스크린샷 2024-09-10 오후 6 38 25" src="https://github.com/user-attachments/assets/d75780be-b044-46de-8c09-dacfddc96aef"><img width="500" alt="스크린샷 2024-09-10 오후 6 38 42" src="https://github.com/user-attachments/assets/c0e69ac9-1247-4fbf-b67c-30146ea84634">- **소비자인 `c1` 이 같은 소비자인 `c2` 를 깨우는 것은 `상당히 비효율적`이다.**- `c1` 입장에서 `c2` 를 깨우게 되면 **아무 일도 하지 않고 그냥 다시 스레드 대기 집합에 들어갈 수 있다.** - ***결과적으로 `CPU`만 사용하고, 아무 일도 하지 않은 상태로 다시 대기 상태가 되어버린다.***- ***그렇다고 `c1` 이 스레드 대기 집합에 있는 어떤 스레드를 깨울지 선택할 수는 없다. `notify()` 는 스레드 대기 집합에 있는 스레드 중 임의의 하나를 깨울 뿐이다.***- 물론 이것이 비효율적이라는 것이지 문제가 되는 것은 아니다. 결과에는 문제가 없다. 가끔씩 약간 돌아서 갈 뿐이다.<br/><br/><br/># 💡 Object - wait, notify - 한계## ⚡️ 비효율성 - 같은 종류의 스래드를 깨울 때> ***같은 종류의 스레드를 깨울 때 비효율이 발생한다.***- 생산자가 같은 생산자를 깨우거나, 소비자가 같은 소비자를 깨울 때 비효율이 발생 할 수 있다는 점이다.## ⚡️ 스레드 기아(thread starvation)> ***어떤 스레드가 깨어날 지 알 수 없기 때문에 발생할 수 있는 스레드 기아 문제가 발생한다.***- **대기 상태의 스레드가 실행 순서를 계속 얻지 못해서 실행되지 않는 상황**을 `스레드 기아(starvation) 상태`라고 한다.- 결과적으로 **notifyAll()** 을 사용해서 스레드 기아 문제는 막을 수 있지만, **`비효율`을 막지는 못한다.**> `notify()`가 랜덤으로 스레드를 호출하는 것은 맞지만, 자바가 내부적으로 오래 기다린 스레드를 호출하도록 로직들이 짜여져 있습니다.      > **따라서, 스레드가 엄청 경합이 있는 상황이 아니라면, 먼저 기다린 스레드가 조금이라도 먼저 실행될 가능성이 높다.**      > **그렇다고 완전히 순서를 보장하는 것은 아니다.**<br/><br/><br/># 💡 생산자 소비자 문제 예제 4, 5 - Lock Condition> **`생산자 스레드가 대기하는 대기 집합`과, `소비자 스레드가 대기하는 대기 집합`을 둘로 나누면 된다.**<u>**Condition 분리**</u>- `consumerCond` : 생산자를 위한 스레드 대기 공간 - `producerCond` : 소비자를 위한 스레드 대기 공간```javapublic class BoundedQueueV5 implements BoundedQueue {  private final Lock lock = new ReentrantLock();  private final Condition producerCond = lock.newCondition(); // 생산자 스레드가 대기하는 대기집합  private final Condition consumerCond = lock.newCondition(); // 소비자 스레드가 대기하는 대기집합  private final Queue<String> queue = new ArrayDeque<>();  private final int max;  public BoundedQueueV5(int max) {    this.max = max;  }  @Override  public void put(String data) {    lock.lock();    try {      while (queue.size() == max) {        log("[put] 큐가 가득 참, 생산자 대기");        try {          producerCond.await();          log("[put] 생산자 깨어남");        } catch (InterruptedException e) {          throw new RuntimeException(e);        }      }      queue.offer(data);      log("[put] 생산자 데이터 저장, consumerCond.signal() 호출");      consumerCond.signal();    } finally {      lock.unlock();    }  }  @Override  public String take() {    lock.lock();    try {      while (queue.isEmpty()) {        log("[take] 큐에 데이터가 없음, 소비자 대기");        try {          consumerCond.await();          log("[take] 소비자 깨어남");        } catch (InterruptedException e) {          throw new RuntimeException(e);        }      }      String data = queue.poll();      log("[take] 소비자 데이터 획득, producerCond.signal() 호출");      producerCond.signal();      return data;    } finally {      lock.unlock();    }  }  // 원칙적으로는 여기에도 synchronized 를 붙여줘야 한다.  // A 스레드가 큐에 접근 중일 때, B 스레드가 toString() 을 호출한다면 기대하지 않는 값을 얻을 수 있기 때문에 원칙적으로는 synchronized 를 붙여줘야 한다.  @Override  public String toString() {    return queue.toString();  }}```<img width="500" alt="스크린샷 2024-09-11 오후 5 42 40" src="https://github.com/user-attachments/assets/c8b82954-83b5-4fd0-9491-f3f3b10ab0a1">> **이 그림에서 `lock` 은 `synchronized` 에서 사용하는 객체 내부에 있는 `모니터 락`이 아니라, `ReentrantLock 락`을 뜻한다.**  **`ReentrantLock` 은 내부에 락과, 락 획득을 대기하는 스레드를 관리하는 `대기 큐(Condition)`가 있다.**<u>**Condition**</u>- `Condition condition = lock.newCondition()`- `Condition` 은 `ReentrantLock` 을 사용하는 스레드가 대기하는 `스레드 대기 공간`이다.- `lock.newCondition()` 메서드를 호출하면 스레드 대기 공간이 만들어진다. `Lock(ReentrantLock)` 의 `스레드 대기 공간`은 이렇게 만들 수 있다.- ***참고로 `Object.wait()` 에서 사용한 스레드 대기 공간은 모든 객체 인스턴스가 내부에 기본으로 가지고 있다. 반면에 `Lock(ReentrantLock)` 을 사용하는 경우 이렇게 스레드 대기 공간을 직접 만들어서 사용해야 한다.***<u>**condition.await()**</u>- `Object.wait()` 와 유사한 기능이다. 지정한 `condition` 에 현재 스레드를 대기( `WAITING` ) 상태로 보관한다.- 이때 `ReentrantLock` 에서 획득한 락을 반납하고 대기 상태로 `condition` 에 보관된다.<u>**condition.signal()**</u>- `Object.notify()` 와 유사한 기능이다. 지정한 `condition` 에서 대기중인 스레드를 하나 깨운다. 깨어난 스레드는 `condition` 에서 빠져나온다.> **여기서 핵심은 생산자는 소비자를 깨우고, 소비자는 생산자를 깨운다는 점이다.**---### 🔋 실행 결과 - BoundedQueueV5, 생산자 먼저 실행<details><summary>실행 결과 - BoundedQueueV5, 생산자 먼저 실행</summary>```> Task :BoundedMain.main()17:52:23.275 [     main] == [생산자 먼저 실행] 시작, BoundedQueueV5 ==17:52:23.282 [producer1] [생산 시도] data1 -> []17:52:23.282 [producer1] [put] 생산자 데이터 저장, consumerCond.signal() 호출17:52:23.282 [producer1] [생산 완료] data1 -> [data1]17:52:23.383 [producer2] [생산 시도] data2 -> [data1]17:52:23.384 [producer2] [put] 생산자 데이터 저장, consumerCond.signal() 호출17:52:23.384 [producer2] [생산 완료] data2 -> [data1, data2]17:52:23.489 [producer3] [생산 시도] data3 -> [data1, data2]17:52:23.489 [producer3] [put] 큐가 가득 참, 생산자 대기17:52:23.591 [     main] 현재 상태 출력, 큐 데이터: [data1, data2]17:52:23.591 [     main] producer1: TERMINATED17:52:23.592 [     main] producer2: TERMINATED17:52:23.592 [     main] producer3: WAITING17:52:23.592 [     main] 소비자 시작17:52:23.593 [consumer1] [소비 시도]     ? <- [data1, data2]17:52:23.594 [consumer1] [take] 소비자 데이터 획득, producerCond.signal() 호출17:52:23.594 [producer3] [put] 생산자 깨어남17:52:23.594 [consumer1] [소비 완료] data1 <- [data2]17:52:23.594 [producer3] [put] 생산자 데이터 저장, consumerCond.signal() 호출17:52:23.595 [producer3] [생산 완료] data3 -> [data2, data3]17:52:23.699 [consumer2] [소비 시도]     ? <- [data2, data3]17:52:23.699 [consumer2] [take] 소비자 데이터 획득, producerCond.signal() 호출17:52:23.700 [consumer2] [소비 완료] data2 <- [data3]17:52:23.804 [consumer3] [소비 시도]     ? <- [data3]17:52:23.805 [consumer3] [take] 소비자 데이터 획득, producerCond.signal() 호출17:52:23.805 [consumer3] [소비 완료] data3 <- []17:52:23.905 [     main] 현재 상태 출력, 큐 데이터: []17:52:23.906 [     main] producer1: TERMINATED17:52:23.906 [     main] producer2: TERMINATED17:52:23.907 [     main] producer3: TERMINATED17:52:23.907 [     main] consumer1: TERMINATED17:52:23.908 [     main] consumer2: TERMINATED17:52:23.908 [     main] consumer3: TERMINATED17:52:23.909 [     main] == [생산자 먼저 실행] 종료, BoundedQueueV5 ==```</details><img width="500" alt="스크린샷 2024-09-11 오후 5 55 52" src="https://github.com/user-attachments/assets/477f7a66-b02b-4cd9-9b03-729542758cad"><img width="500" alt="스크린샷 2024-09-11 오후 5 56 08" src="https://github.com/user-attachments/assets/67417f2c-2a88-466e-8e3d-95255df2e997">---<br/>### 🔋 실행 결과 - BoundedQueueV5, 소비자 먼저 실행<details><summary>실행 결과 - BoundedQueueV5, 소비자 먼저 실행</summary>```> Task :BoundedMain.main()17:54:24.341 [     main] == [소비자 먼저 실행] 시작, BoundedQueueV5 ==17:54:24.342 [     main] 소비자 시작17:54:24.345 [consumer1] [소비 시도]     ? <- []17:54:24.345 [consumer1] [take] 큐에 데이터가 없음, 소비자 대기17:54:24.448 [consumer2] [소비 시도]     ? <- []17:54:24.448 [consumer2] [take] 큐에 데이터가 없음, 소비자 대기17:54:24.553 [consumer3] [소비 시도]     ? <- []17:54:24.553 [consumer3] [take] 큐에 데이터가 없음, 소비자 대기17:54:24.655 [     main] 현재 상태 출력, 큐 데이터: []17:54:24.662 [     main] consumer1: WAITING17:54:24.662 [     main] consumer2: WAITING17:54:24.662 [     main] consumer3: WAITING17:54:24.663 [producer1] [생산 시도] data1 -> []17:54:24.664 [producer1] [put] 생산자 데이터 저장, consumerCond.signal() 호출17:54:24.664 [consumer1] [take] 소비자 깨어남17:54:24.664 [producer1] [생산 완료] data1 -> [data1]17:54:24.664 [consumer1] [take] 소비자 데이터 획득, producerCond.signal() 호출17:54:24.664 [consumer1] [소비 완료] data1 <- []17:54:24.767 [producer2] [생산 시도] data2 -> []17:54:24.768 [producer2] [put] 생산자 데이터 저장, consumerCond.signal() 호출17:54:24.768 [producer2] [생산 완료] data2 -> [data2]17:54:24.768 [consumer2] [take] 소비자 깨어남17:54:24.769 [consumer2] [take] 소비자 데이터 획득, producerCond.signal() 호출17:54:24.769 [consumer2] [소비 완료] data2 <- []17:54:24.871 [producer3] [생산 시도] data3 -> []17:54:24.872 [producer3] [put] 생산자 데이터 저장, consumerCond.signal() 호출17:54:24.872 [producer3] [생산 완료] data3 -> [data3]17:54:24.872 [consumer3] [take] 소비자 깨어남17:54:24.873 [consumer3] [take] 소비자 데이터 획득, producerCond.signal() 호출17:54:24.874 [consumer3] [소비 완료] data3 <- []17:54:24.976 [     main] 현재 상태 출력, 큐 데이터: []17:54:24.976 [     main] consumer1: TERMINATED17:54:24.976 [     main] consumer2: TERMINATED17:54:24.977 [     main] consumer3: TERMINATED17:54:24.977 [     main] producer1: TERMINATED17:54:24.977 [     main] producer2: TERMINATED17:54:24.978 [     main] producer3: TERMINATED17:54:24.978 [     main] == [소비자 먼저 실행] 종료, BoundedQueueV5 ==```</details><img width="500" alt="스크린샷 2024-09-11 오후 6 06 29" src="https://github.com/user-attachments/assets/e7d7dd6f-87da-4a23-b8db-94ecf3423929"><img width="500" alt="스크린샷 2024-09-11 오후 6 06 45" src="https://github.com/user-attachments/assets/14b9a150-173e-47f2-ab63-a95ef36dc301"><br/><br/><br/># 💡 스레드의 대기## ⚡️ synchronized 에서의 2가지 대기 상태<u>**synchronized 대기**</u> - **대기1: 락 획득 대기** - ***락 대기 집합(`BLOCKED`)***  - `BLOCKED` 상태로 락 획득 대기  - `synchronized` 를 시작할 때 락이 없으면 대기  - 다른 스레드가 `synchronized` 를 빠져나갈 때 대기가 풀리며 락 획득 시도   - **대기2: wait() 대기** - ***스레드 대기 집합(`WAITING`)***  - `WAITING` 상대로 대기  - `wait()` 를 호출 했을 때 스레드 대기 집합에서 대기  - 다른 스레드가 `notify()` 를 호출 했을 때 빠져나감> 락을 기다리는 `c2` , `c3` 도 어딘가에서 관리가 되어야 한다. 그래야 락이 반환되었을 때 `JAVA`가 `c2` , `c3` 중에 하나를 선택해서 **락을 제공할 수 있다.**   > ***`BLOCKED` 상태의 스레드도 자바 내부에서 따로 관리된다.***<img width="500" alt="스크린샷 2024-09-11 오후 6 20 14" src="https://github.com/user-attachments/assets/732cbce4-c367-4cb7-8425-f33ab5e2e21b">- `락 대기 집합`이라는 곳이 있다. 이곳은 락을 기다리는 `BLOCKED` 상태의 스레드들을 관리한다. - **`락 대기 집합`은 자바 내부에 구현되어 있기 때문에 `모니터 락과 같이 개발자가 확인하기는 어렵다.`**---<u>**자바의 모든 객체 인스턴스**는 `멀티스레드`와 `임계 영역`을 다루기 위해 내부에 3가지 기본 요소를 가진다.</u>- **모니터 락**- **락 대기 집합(모니터 락 대기 집합)** - **스레드 대기 집합**> **여기서 `락 대기 집합`이 `1차 대기소`이고, `스레드 대기 집합`이 `2차 대기소`라 생각하면 된다.**      > **2차 대기소에 들어간 스레드는 2차, 1차 대기소를 모두 빠져나와야 `임계 영역`을 수행할 수 있다.**<br/>## ⚡️ ReentrantLock 에서의 2가지 대기 상태<img width="500" alt="스크린샷 2024-09-11 오후 6 41 37" src="https://github.com/user-attachments/assets/7ff91ce7-2ae0-4da2-8f6a-acf7a5f4a76a"><u>**대기1: ReentrantLock 락 획득 대기**</u> - `ReentrantLock` 의 대기 큐에서 관리 ***`WAITING` 상태로 락 획득 대기***- `lock.lock()` 을 호출 했을 때 락이 없으면 대기- 다른 스레드가 `lock.unlock()` 을 호출 했을 때 대기가 풀리며 락 획득 시도, 락을 획득하면 대기 큐를 빠져나감<u>**대기2: await() 대기**</u>- `condition.await()` 를 호출 했을 때, `condition` 객체의 스레드 대기 공간에서 관리 - ***`WAITING` 상태로 대기***- 다른 스레드가 `condition.signal()` 을 호출 했을 때 `condition` 객체의 스레드 대기 공간에서 빠져 나감> 임계 영역 안에서는 항상 락이 있는 하나의 스레드만 실행될 수 있다.      > 여기서는 `ReentrantLock` 의 락을 획득해야 `RUNNABLE` 상태가 되면서 그 다음 코드를 실행할 수 있다.      > **락을 획득하지 못하면 `WAITING` 상태로 락을 획득할 때 까지 `ReentrantLock` 의 대기 큐에서 대기한다.**<br/><br/><br/># 💡 생산자 소비자 문제 예제 6 - BlockingQueue> 자바는 생산자 소비자 문제를 해결하기 위해 `java.util.concurrent.BlockingQueue` 라는 특별한 `멀티스레드 자료 구조`를 제공한다.- **데이터 추가 차단**: 큐가 가득 차면 데이터 추가 작업( `put()` )을 시도하는 스레드는 공간이 생길 때까지 차단된다. - **데이터 획득 차단**: 큐가 비어 있으면 획득 작업( `take()` )을 시도하는 스레드는 큐에 데이터가 들어올 때까지 차단된다.```javapackage java.util.concurrent;public interface BlockingQueue<E> extends Queue<E> {    boolean add(E e);    boolean offer(E e);    void put(E e) throws InterruptedException;    boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException;    E take() throws InterruptedException;    E poll(long timeout, TimeUnit unit) throws InterruptedException;    boolean remove(Object o);//...}```**`BlockingQueue` 인터페이스의 대표적인 구현체**- `ArrayBlockingQueue`: 배열 기반으로 구현되어 있고, 버퍼의 크기가 고정되어 있다. - `LinkedBlockingQueue`: 링크 기반으로 구현되어 있고, 버퍼의 크기를 고정할 수도, 또는 무한하게 사용할 수 도 있다.- `BlockingDeque`: `Deque` 용 동시성 자료 구조이다. <u>**`BlockingQueue` 를 적용한 코드**</u>```javapublic class BoundedQueueV6_1 implements BoundedQueue {    private BlockingQueue<String> queue;    public BoundedQueueV6_1(int max) {        this.queue = new ArrayBlockingQueue<>(max);    }    @Override    public void put(String data) {        try {            queue.put(data);        } catch (InterruptedException e) {            throw new RuntimeException(e);        }    }    @Override    public String take() {        try {            return queue.take();        } catch (InterruptedException e) {            throw new RuntimeException(e);        }    }    @Override    public String toString() {        return queue.toString();    }}```---### 🔋 BoundedQueueV6_1 - 실행 결과 <details><summary>실행 결과 - BoundedQueueV6_1</summary><u>**생산자 먼저 실행**</u>```> Task :BoundedMain.main()23:20:29.174 [     main] == [생산자 먼저 실행] 시작, BoundedQueueV6_1 ==23:20:29.180 [producer1] [생산 시도] data1 -> []23:20:29.181 [producer1] [생산 완료] data1 -> [data1]23:20:29.282 [producer2] [생산 시도] data2 -> [data1]23:20:29.282 [producer2] [생산 완료] data2 -> [data1, data2]23:20:29.382 [producer3] [생산 시도] data3 -> [data1, data2]23:20:29.484 [     main] 현재 상태 출력, 큐 데이터: [data1, data2]23:20:29.485 [     main] producer1: TERMINATED23:20:29.485 [     main] producer2: TERMINATED23:20:29.485 [     main] producer3: WAITING23:20:29.485 [     main] 소비자 시작23:20:29.486 [consumer1] [소비 시도]     ? <- [data1, data2]23:20:29.486 [producer3] [생산 완료] data3 -> [data2, data3]23:20:29.486 [consumer1] [소비 완료] data1 <- [data2]23:20:29.587 [consumer2] [소비 시도]     ? <- [data2, data3]23:20:29.587 [consumer2] [소비 완료] data2 <- [data3]23:20:29.688 [consumer3] [소비 시도]     ? <- [data3]23:20:29.688 [consumer3] [소비 완료] data3 <- []23:20:29.788 [     main] 현재 상태 출력, 큐 데이터: []23:20:29.788 [     main] producer1: TERMINATED23:20:29.789 [     main] producer2: TERMINATED23:20:29.789 [     main] producer3: TERMINATED23:20:29.789 [     main] consumer1: TERMINATED23:20:29.790 [     main] consumer2: TERMINATED23:20:29.790 [     main] consumer3: TERMINATED23:20:29.790 [     main] == [생산자 먼저 실행] 종료, BoundedQueueV6_1 ==```<u>**소비자 먼저 실행**</u>```> Task :BoundedMain.main()23:20:51.046 [     main] == [소비자 먼저 실행] 시작, BoundedQueueV6_1 ==23:20:51.047 [     main] 소비자 시작23:20:51.051 [consumer1] [소비 시도]     ? <- []23:20:51.155 [consumer2] [소비 시도]     ? <- []23:20:51.260 [consumer3] [소비 시도]     ? <- []23:20:51.365 [     main] 현재 상태 출력, 큐 데이터: []23:20:51.371 [     main] consumer1: WAITING23:20:51.371 [     main] consumer2: WAITING23:20:51.372 [     main] consumer3: WAITING23:20:51.373 [producer1] [생산 시도] data1 -> []23:20:51.373 [producer1] [생산 완료] data1 -> [data1]23:20:51.373 [consumer1] [소비 완료] data1 <- []23:20:51.478 [producer2] [생산 시도] data2 -> []23:20:51.479 [producer2] [생산 완료] data2 -> [data2]23:20:51.479 [consumer2] [소비 완료] data2 <- []23:20:51.583 [producer3] [생산 시도] data3 -> []23:20:51.584 [consumer3] [소비 완료] data3 <- []23:20:51.584 [producer3] [생산 완료] data3 -> [data3]23:20:51.685 [     main] 현재 상태 출력, 큐 데이터: []23:20:51.686 [     main] consumer1: TERMINATED23:20:51.686 [     main] consumer2: TERMINATED23:20:51.687 [     main] consumer3: TERMINATED23:20:51.687 [     main] producer1: TERMINATED23:20:51.688 [     main] producer2: TERMINATED23:20:51.688 [     main] producer3: TERMINATED23:20:51.689 [     main] == [소비자 먼저 실행] 종료, BoundedQueueV6_1 ==```</details>---<br/><br/><br/># 💡 BlockingQueue - 기능 설명> **실무에서 멀티스레드를 사용할 때는 `응답성이 중요`하다.** 예를 들어서 대기 상태에 있어도, 고객이 중지 요청을 하거나, 또는 너무 오래 대기한 경우 포기하고 빠져나갈 수 있는 방법이 필요하다.- 생산자가 무언가 데이터를 생산하는데, 버퍼가 빠지지 않아서 **너무 오래 대기해야 한다면**, 무한정 기다리는 것 보다는 **작업을 포기**하고, 고객분께는 "죄송합니다. 현재 시스템에 문제가 있습니다. 나중에 다시 시도해주세요." 라고 하는 것이 더 나은 선택일 것이다.- 결국 고객도 응답을 받지 못하고 무한 대기하게 된 다. 고객 입장에서 무작정 무한 대기하고 결과도 알 수 없는 상황이 가장 나쁜 상황일 것이다.> 이렇게 생산자 스레드가 큐에 데이터를 추가할 때 큐가 가득 찬 경우, 또는 큐에 데이터를 추가하기 위해 너무 오래 대기한 경우에는      > **데이터 추가를 포기**하고, **고객에게** 주문 폭주로 너무 많은 사용자가 몰려서 **요청을 처리할 수 없다거나**, 또는 **나중에 다시 시도해달라고 하는 것**이 더 나은 선택일 것이다.---<u>**큐가 가득 찼을 때 생각할 수 있는 선택지**</u>- **예외를 던진다. 예외를 받아서 처리한다.** - **대기하지 않는다. 즉시 `false` 를 반환한다.** - **대기한다.** - **특정 시간 만큼만 대기한다.**---## ⚡️ BlockingQueue의 다양한 기능| Operation   |Throws exception|Special value|Blocks|Times out||-------------|---|---|---|---|| **Insert(추가)**  |add(e)|offer(e)|put(e)|offer(e, time, unit)|| **Remove(제거)**  |remove()|poll()|take()|poll(time, unit)|| **Examine(관찰)** |element()|peek()|not applicable|not applicable|---### 🔋 **Throws Exception - 대기시 예외**- **add(e)**: 지정된 요소를 큐에 추가하며, 큐가 가득 차면 `IllegalStateException` 예외를 던진다. - **remove()**: 큐에서 요소를 제거하며 반환한다. 큐가 비어 있으면 `NoSuchElementException` 예외를 던진다.- **element()**: 큐의 머리 요소를 반환하지만, 요소를 큐에서 제거하지 않는다. 큐가 비어 있으면 `NoSuchElementException` 예외를 던진다.<details><summary>BlockingQueue - 대기시 예외 코드</summary>```javapublic class BoundedQueueV6_4 implements BoundedQueue {    private BlockingQueue<String> queue;    public BoundedQueueV6_4(int max) {        this.queue = new ArrayBlockingQueue<>(max);    }    @Override    public void put(String data) {        queue.add(data); // java.lang.IllegalStateException: Queue full    }    @Override    public String take() {        return queue.remove(); // java.util.NoSuchElementException    }    @Override    public String toString() {        return queue.toString();    }}```- `add(data)` 는 성공하면 `true` 를 반환하고, 버퍼가 가득 차면 즉시 예외가 발생한다. `java.lang.IllegalStateException: Queue full`- `remove()` 는 버퍼에 데이터가 없으면, 즉시 예외가 발생한다. `java.util.NoSuchElementException````> Task :BoundedMain.main()23:53:16.072 [     main] == [생산자 먼저 실행] 시작, BoundedQueueV6_4 ==23:53:16.080 [producer1] [생산 시도] data1 -> []23:53:16.080 [producer1] [생산 완료] data1 -> [data1]23:53:16.182 [producer2] [생산 시도] data2 -> [data1]23:53:16.182 [producer2] [생산 완료] data2 -> [data1, data2]23:53:16.287 [producer3] [생산 시도] data3 -> [data1, data2]23:53:16.388 [     main] 현재 상태 출력, 큐 데이터: [data1, data2]23:53:16.389 [     main] producer1: TERMINATED23:53:16.389 [     main] producer2: TERMINATED23:53:16.389 [     main] producer3: TERMINATED23:53:16.389 [     main] 소비자 시작23:53:16.390 [consumer1] [소비 시도]     ? <- [data1, data2]23:53:16.391 [consumer1] [소비 완료] data1 <- [data2]23:53:16.496 [consumer2] [소비 시도]     ? <- [data2]23:53:16.497 [consumer2] [소비 완료] data2 <- []23:53:16.601 [consumer3] [소비 시도]     ? <- []23:53:16.703 [     main] 현재 상태 출력, 큐 데이터: []23:53:16.703 [     main] producer1: TERMINATED23:53:16.704 [     main] producer2: TERMINATED23:53:16.704 [     main] producer3: TERMINATED23:53:16.704 [     main] consumer1: TERMINATED23:53:16.704 [     main] consumer2: TERMINATED23:53:16.705 [     main] consumer3: TERMINATED23:53:16.706 [     main] == [생산자 먼저 실행] 종료, BoundedQueueV6_4 ==Deprecated Gradle features were used in this build, making it incompatible with Gradle 9.0.You can use '--warning-mode all' to show the individual deprecation warnings and determine if they come from your own scripts or plugins.For more on this, please refer to https://docs.gradle.org/8.8/userguide/command_line_interface.html#sec:command_line_warnings in the Gradle documentation.BUILD SUCCESSFUL in 768ms2 actionable tasks: 2 executedException in thread "producer3" java.lang.IllegalStateException: Queue full	at java.base/java.util.AbstractQueue.add(AbstractQueue.java:98)	at java.base/java.util.concurrent.ArrayBlockingQueue.add(ArrayBlockingQueue.java:329)	at thread.bounded.BoundedQueueV6_4.put(BoundedQueueV6_4.java:19)	at thread.bounded.ProducerTask.run(ProducerTask.java:17)	at java.base/java.lang.Thread.run(Thread.java:1570)Exception in thread "consumer3" java.util.NoSuchElementException	at java.base/java.util.AbstractQueue.remove(AbstractQueue.java:117)	at thread.bounded.BoundedQueueV6_4.take(BoundedQueueV6_4.java:24)	at thread.bounded.ConsumerTask.run(ConsumerTask.java:16)	at java.base/java.lang.Thread.run(Thread.java:1570)11:53:16 PM: Execution finished ':BoundedMain.main()'.```- 생산을 담당하는 `add(data)` 메서드는 버퍼가 가득 찬 경우 `IllegalStateException` 이 발생한다. 오류 메시지는 `Queue full` 이다.- 소비를 담당하는 `remove()` 메서드는 버퍼가 빈 경우 `NoSuchElementException` 이 발생한다.</details>---### 🔋 **Special Value - 대기시 즉시 반환**- **offer(e)**: 지정된 요소를 큐에 추가하려고 시도하며, 큐가 가득 차면 `false` 를 반환한다.- **poll()**: 큐에서 요소를 제거하고 반환한다. 큐가 비어 있으면 `null` 을 반환한다.- **peek()**: 큐의 머리 요소를 반환하지만, 요소를 큐에서 제거하지 않는다. 큐가 비어 있으면 `null` 을 반환한다.<details><summary>BlockingQueue - 대기시 즉시 반환 코드</summary>```javapublic class BoundedQueueV6_2 implements BoundedQueue {    private BlockingQueue<String> queue;    public BoundedQueueV6_2(int max) {        this.queue = new ArrayBlockingQueue<>(max);    }    @Override    public void put(String data) {        boolean result = queue.offer(data);        log("저장 시도 결과 = " + result);    }    @Override    public String take() {        return queue.poll();    }    @Override    public String toString() {        return queue.toString();    }}```**두 메서드는 스레드가 대기하지 않는다.**- `offer(data)` 는 성공하면 `true` 를 반환하고, 버퍼가 가득 차면 즉시 `false` 를 반환한다. - `poll()` 버퍼에 데이터가 없으면 즉시 `null` 을 반환한다.```> Task :BoundedMain.main()23:45:44.003 [     main] == [생산자 먼저 실행] 시작, BoundedQueueV6_2 ==23:45:44.009 [producer1] [생산 시도] data1 -> []23:45:44.009 [producer1] 저장 시도 결과 = true23:45:44.010 [producer1] [생산 완료] data1 -> [data1]23:45:44.110 [producer2] [생산 시도] data2 -> [data1]23:45:44.110 [producer2] 저장 시도 결과 = true23:45:44.110 [producer2] [생산 완료] data2 -> [data1, data2]-> 23:45:44.211 [producer3] [생산 시도] data3 -> [data1, data2]-> 23:45:44.211 [producer3] 저장 시도 결과 = false23:45:44.212 [producer3] [생산 완료] data3 -> [data1, data2]23:45:44.317 [     main] 현재 상태 출력, 큐 데이터: [data1, data2]23:45:44.318 [     main] producer1: TERMINATED23:45:44.318 [     main] producer2: TERMINATED23:45:44.318 [     main] producer3: TERMINATED23:45:44.318 [     main] 소비자 시작23:45:44.320 [consumer1] [소비 시도]     ? <- [data1, data2]23:45:44.320 [consumer1] [소비 완료] data1 <- [data2]23:45:44.425 [consumer2] [소비 시도]     ? <- [data2]23:45:44.426 [consumer2] [소비 완료] data2 <- []-> 23:45:44.526 [consumer3] [소비 시도]     ? <- []-> 23:45:44.526 [consumer3] [소비 완료] null <- []23:45:44.631 [     main] 현재 상태 출력, 큐 데이터: []23:45:44.632 [     main] producer1: TERMINATED23:45:44.632 [     main] producer2: TERMINATED23:45:44.633 [     main] producer3: TERMINATED23:45:44.633 [     main] consumer1: TERMINATED23:45:44.634 [     main] consumer2: TERMINATED23:45:44.634 [     main] consumer3: TERMINATED23:45:44.635 [     main] == [생산자 먼저 실행] 종료, BoundedQueueV6_2 ==```- 버퍼가 가득 차있는 경우 데이터를 추가하지 않고 즉시 `false` 를 반환한다.- 버퍼에 데이터가 없는 경우 대기하지 않고 `null` 을 반환한다.</details>---### 🔋 **Blocks - 대기**- **put(e)**: 지정된 요소를 큐에 추가할 때까지 대기한다. 큐가 가득 차면 공간이 생길 때까지 대기한다. - **take()**: 큐에서 요소를 제거하고 반환한다. 큐가 비어 있으면 요소가 준비될 때까지 대기한다. - **Examine (관찰)**: 해당 사항 없음.---### 🔋 **Times Out - 시간 대기**- **offer(e, time, unit)**: 지정된 요소를 큐에 추가하려고 시도하며, 지정된 시간 동안 큐가 비워지기를 기다리다가 시간이 초과되면 `false` 를 반환한다.- **poll(time, unit)**: 큐에서 요소를 제거하고 반환한다. 큐에 요소가 없다면 지정된 시간 동안 요소가 준비되기를 기다리다가 시간이 초과되면 `null` 을 반환한다.- **Examine (관찰)**: 해당 사항 없음.<details><summary>BlockingQueue - 시간 대기 코드</summary>```javapublic class BoundedQueueV6_3 implements BoundedQueue {    private BlockingQueue<String> queue;    public BoundedQueueV6_3(int max) {        this.queue = new ArrayBlockingQueue<>(max);    }    @Override    public void put(String data) {        boolean result = false;        try {            // 대기 시간 설정 가능            result = queue.offer(data, 1, TimeUnit.NANOSECONDS);            log("저장 시도 결과 = " + result);        } catch (InterruptedException e) {            throw new RuntimeException(e);        }    }    @Override    public String take() {        try {            // 대기 시간 설정 가능            return queue.poll(2, TimeUnit.SECONDS);        } catch (InterruptedException e) {            throw new RuntimeException(e);        }    }    @Override    public String toString() {        return queue.toString();    }}```- `offer(data, 시간)` 는 성공하면 `true` 를 반환하고, 버퍼가 가득 차서 스레드가 대기해야 하는 상황이면, 지 정한 시간까지 대기한다. 대기 시간을 지나면 `false` 를 반환한다.  - 여기서는 확인을 목적으로 1 나노초( `NANOSECONDS` )로 설정했다.- `poll(시간)` 버퍼에 데이터가 없어서 스레드가 대기해야 하는 상황이면, 지정한 시간까지 대기한다. 대기 시간을 지나면 `null` 을 반환한다.  - 여기서는 2초( `SECONDS` )로 설정했다.```> Task :BoundedMain.main()23:49:50.753 [     main] == [생산자 먼저 실행] 시작, BoundedQueueV6_3 ==23:49:50.760 [producer1] [생산 시도] data1 -> []23:49:50.760 [producer1] 저장 시도 결과 = true23:49:50.760 [producer1] [생산 완료] data1 -> [data1]23:49:50.859 [producer2] [생산 시도] data2 -> [data1]23:49:50.859 [producer2] 저장 시도 결과 = true23:49:50.859 [producer2] [생산 완료] data2 -> [data1, data2]-> 23:49:50.963 [producer3] [생산 시도] data3 -> [data1, data2]-> 23:49:50.964 [producer3] 저장 시도 결과 = false23:49:50.964 [producer3] [생산 완료] data3 -> [data1, data2]23:49:51.070 [     main] 현재 상태 출력, 큐 데이터: [data1, data2]23:49:51.072 [     main] producer1: TERMINATED23:49:51.072 [     main] producer2: TERMINATED23:49:51.072 [     main] producer3: TERMINATED23:49:51.073 [     main] 소비자 시작23:49:51.074 [consumer1] [소비 시도]     ? <- [data1, data2]23:49:51.074 [consumer1] [소비 완료] data1 <- [data2]23:49:51.180 [consumer2] [소비 시도]     ? <- [data2]23:49:51.180 [consumer2] [소비 완료] data2 <- []-> 23:49:51.282 [consumer3] [소비 시도]     ? <- []23:49:51.387 [     main] 현재 상태 출력, 큐 데이터: []23:49:51.388 [     main] producer1: TERMINATED23:49:51.388 [     main] producer2: TERMINATED23:49:51.389 [     main] producer3: TERMINATED23:49:51.389 [     main] consumer1: TERMINATED23:49:51.389 [     main] consumer2: TERMINATED23:49:51.390 [     main] consumer3: TIMED_WAITING23:49:51.391 [     main] == [생산자 먼저 실행] 종료, BoundedQueueV6_3 ==-> 23:49:53.283 [consumer3] [소비 완료] null <- []```- 생산을 담당하는 `offer(data, 1나노초)` 메서드는 버퍼가 가득 찬 경우 1나노초 만큼 대기한 다음에 `false` 를 반한다.- 참고로 `false` 상황을 예시로 보여주기 위해 이렇게 짧은 시간을 선택했다.- 소비를 담당하는 `poll(2초)` 메서드는 버퍼가 빈 경우 2초 만큼 대기한 다음에 `null` 을 반환한다.- 여기서 `consumer3` 은 빈 버퍼를 2초간 대기하다가 2초 후에 `null` 을 반환 받는다.</details>