# 스레드 제어와 생명 주기<br/><br/><br/># 💡 스레드 기본 정보```javapublic class ThreadInfoMain {    public static void main(String[] args) {        // main 스레드        Thread mainThread = Thread.currentThread();        log("mainThread = " + mainThread);        log("mainThread.threadId() = " + mainThread.getId());        log("mainThread.getName() = " + mainThread.getName());        log("mainThread.getPriority() = " + mainThread.getPriority()); // 1~10(기본값 5)        log("mainThread.getThreadGroup() = " + mainThread.getThreadGroup());        log("mainThread.getState() = " + mainThread.getState());        // myThread 스레드        Thread myThread = Thread.currentThread();        log("myThread = " + myThread);        log("myThread.threadId() = " + myThread.getId());        log("myThread.getName() = " + myThread.getName());        log("myThread.getPriority() = " + myThread.getPriority()); // 1~10(기본값 5)        log("myThread.getThreadGroup() = " + myThread.getThreadGroup());        log("myThread.getState() = " + myThread.getState());    }}``````// main 스레드 출력19:24:26.874 [     main] mainThread = Thread[#1,main,5,main]19:24:26.877 [     main] mainThread.threadId() = 119:24:26.878 [     main] mainThread.getName() = main19:24:26.879 [     main] mainThread.getPriority() = 519:24:26.879 [     main] mainThread.getThreadGroup() = java.lang.ThreadGroup[name=main,maxpri=10]19:24:26.879 [     main] mainThread.getState() = RUNNABLE// myThread 출력19:24:26.880 [     main] myThread = Thread[#1,main,5,main]19:24:26.880 [     main] myThread.threadId() = 119:24:26.880 [     main] myThread.getName() = main19:24:26.880 [     main] myThread.getPriority() = 519:24:26.880 [     main] myThread.getThreadGroup() = java.lang.ThreadGroup[name=main,maxpri=10]19:24:26.880 [     main] myThread.getState() = RUNNABLE```### **🔋 스레드 ID**`log("myThread.threadId() = " + myThread.threadId());`- **`threadId()`**: **스레드의 고유 식별자**를 반환하는 메서드이다. - 이 ID는 JVM 내에서 각 스레드에 대해 유일하다. ID는 스레드가 생성될 때 할당되며, **직접 지정할 수 없다.** ### **🔋 스레드 이름** `log("myThread.getName() = " + myThread.getName());`- **`getName()`**: 스레드의 이름을 반환하는 메서드이다.  - 참고로 스레드 ID는 중복되지 않지만, **스레드 이름은 중복될 수 있다.**### **🔋 스레드 우선순위** `log("myThread.getPriority() = " + myThread.getPriority());`- **`getPriority()`**: 스레드의 우선순위를 반환하는 메서드이다. - 우선순위는 1 (가장 낮음)에서 10 (가장 높음)까지의 값으로 설정할 수 있으며, 기본값은 5이다. `setPriority()` 메서드를 사용해서 우선순위를 변경할 수 있다. - 우선순위는 스레드 스케줄러가 어떤 스레드를 우선 실행할지 결정하는 데 사용된다. - **하지만 실제 실행 순서는 JVM 구현과 운영체제에 따라 달라질 수 있다.**### **🔋 스레드 그룹** `log("myThread.getThreadGroup() = " + myThread.getThreadGroup());`<details><summary>ThreadGroup</summary>- **getThreadGroup()**: 스레드가 속한 스레드 그룹을 반환하는 메서드이다. 스레드 그룹은 스레드를 그룹화하여 관리할 수 있는 기능을 제공한다. 기본적으로 모든 스레드는 부모 스레드와 동일한 스레드 그룹에 속하게 된다. - 스레드 그룹은 여러 스레드를 하나의 그룹으로 묶어서 특정 작업(예: 일괄 종료, 우선순위 설정 등)을 수행할 수 있 다.- **부모 스레드(Parent Thread)**: 새로운 스레드를 생성하는 스레드를 의미한다. 스레드는 기본적으로 다른 스레드에 의해 생성된다. 이러한 생성 관계에서 새로 생성된 스레드는 생성한 스레드를 **부모**로 간주한다. 예를 들어 `myThread` 는 `main` 스레드에 의해 생성되었으므로 `main` 스레드가 부모 스레드이다.- `main` 스레드는 기본으로 제공되는 `main` 스레드 그룹에 소속되어 있다. 따라서 `myThread` 도 부모 스레드인 `main` 스레드의 그룹인 `main` 스레드 그룹에 소속된다.**참고**: **스레드 그룹 기능은 직접적으로 잘 사용하지는 않기 때문에, 이런 것이 있구나 정도만 알고 넘어가자**</details><br/><br/><br/># 💡 스레드의 생명 주기<img width="500" alt="스크린샷 2024-09-04 오후 7 38 27" src="https://github.com/user-attachments/assets/40a7380a-9f62-4cf6-bf3e-2d11388c7b38">---### 🔋**New (새로운 상태)**- 스레드가 생성되고 아직 시작되지 않은 상태이다.- 이 상태에서는 `Thread` 객체가 생성되지만, `start()` 메서드가 호출되지 않은 상태이다. - 예: `Thread thread = new Thread(runnable);`---### 🔋 **Runnable (실행 가능 상태)**- 스레드가 실행될 준비가 된 상태이다. 이 상태에서 스레드는 실제로 CPU에서 실행될 수 있다.- `start()` 메서드가 호출되면 스레드는 이 상태로 들어간다.- 예: `thread.start();`- 이 상태는 스레드가 실행될 준비가 되어 있음을 나타내며, 실제로 CPU에서 실행될 수 있는 상태이다. 그러나 Runnable 상태에 있는 모든 스레드가 동시에 실행되는 것은 아니다.   - **운영체제의 스케줄러가 각 스레드에 CPU 시간을 할당하여 실행하기 때문에, Runnable 상태에 있는 스레드는 스케줄러의 `실행 대기열`에 포함되어 있다가 `차례로 CPU에서 실행된다.`**- 참고로 운영체제 스케줄러의 `실행 대기열`에 있든, CPU에서 `실제 실행`되고 있든 모두 `RUNNABLE` 상태이다.   - **자바에서 둘을 구분해서 확인할 수는 없다.**- 보통 실행 상태라고 부른다.---### 🔋 Runnable 의 2가지 상태 - Ready, Running 자바의 스레드가 `RUNNABLE` 상태일 때, 운영체제의 스케줄링은 다음과 같은 상태들을 가질 수 있다.- **실행 상태(Running):** 스레드가 CPU에서 실제로 실행 중이다.- **실행 대기 상태(Ready):** 스레드가 실행될 준비가 되었지만, CPU가 바빠서 `스케줄링 큐(Scheduling Queue)`에서 대기 중이다.- 운영체제는 실행 상태의 스레드들을 잠깐만 실행하고 실행 대기 상태로 만든다. 그리고 실행 대기 상태의 스레드들을 잠깐만 실행 상태로 변경해서 실행한다. 이 과정을 계속 반복한다. ***참고로 자바에서는 두 상태를 구분할 수는 없다!!!***---### 🔋 **Blocked (차단 상태)**- 스레드가 다른 스레드에 의해 `동기화 락`을 얻기 위해 기다리는 상태이다.- 예를 들어, `synchronized` 블록에 진입하기 위해 락을 얻어야 하는 경우 이 상태에 들어간다.- 예: `synchronized (lock) { ... }` 코드 블록에 진입하려고 할 때, 다른 스레드가 이미 `lock` 의 락 을 가지고 있는 경우.---### 🔋 **Waiting (대기 상태)**- 스레드가 다른 스레드의 특정 작업이 완료되기를 무기한 기다리는 상태이다.- `wait()` , `join()` 메서드가 호출될 때 이 상태가 된다.- 스레드는 다른 스레드가 `notify()` 또는 `notifyAll()` 메서드를 호출하거나, `join()` 이 완료될 때까 지 기다린다.- 예: `object.wait();`---### 🔋 **Timed Waiting (시간 제한 대기 상태)**- 스레드가 특정 시간 동안 다른 스레드의 작업이 완료되기를 기다리는 상태이다.- `sleep(long millis)` , `wait(long timeout)` , `join(long millis)` 메서드가 호출될 때 이 상태가 된다.- 주어진 시간이 경과하거나 다른 스레드가 해당 스레드를 깨우면 이 상태에서 벗어난다.- 예: `Thread.sleep(1000);`---### 🔋 **Terminated (종료 상태)**- 스레드의 실행이 완료된 상태이다.- 스레드가 정상적으로 종료되거나, 예외가 발생하여 종료된 경우 이 상태로 들어간다. - **스레드는 한 번 종료되면 다시 시작할 수 없다.**<br/>## ⚡️ **자바 스레드의 상태 전이 과정**1. **New → Runnable**: `start()` 메서드를 호출하면 스레드가 `Runnable` 상태로 전이된다.2. **Runnable → Blocked/Waiting/Timed Waiting**: 스레드가 락을 얻지 못하거나, `wait()` 또는 `sleep()` 메서드를 호출할 때 해당 상태로 전이된다.3. **Blocked/Waiting/Timed Waiting → Runnable**: 스레드가 락을 얻거나, 기다림이 완료되면 다시 `Runnable` 상태로 돌아간다.4. **Runnable → Terminated**: 스레드의 `run()` 메서드가 완료되면 스레드는 `Terminated` 상태가 된다.<br/><br/><br/># 💡 join```javapublic class JoinMainV3 {    public static void main(String[] args) throws InterruptedException {        log("Start");        SumTask task1 = new SumTask(1, 50);        SumTask task2 = new SumTask(51, 100);        Thread thread1 = new Thread(task1, "thread-1");        Thread thread2 = new Thread(task2, "thread-2");        thread1.start();        thread2.start();        // 스레드가 종료될 때 까지 대기        log("join() - main 스레드가 thread1, thread2 종료까지 대기");        thread1.join();        thread2.join();        log("main 스레드 대기 완료");        log("task1.result = " + task1.result);        log("task2.result = " + task2.result);        int sumAll = task1.result + task2.result;        log("task1 + task2 = " + sumAll);        log("End");    }    static class SumTask implements Runnable {        private int start;        private int end;        private int result;        public SumTask(int start, int end) {            this.start = start;            this.end = end;        }        @Override        public void run() {            log("작업 시작");            sleep(2000);            int sum = 0;            for (int i = start; i <= end; i++) {                sum += i;            }            result = sum;            log("작업 완료 result: " + result);        }    }}```<img width="500" alt="스크린샷 2024-09-04 오후 8 08 01" src="https://github.com/user-attachments/assets/a10fcdb8-8378-4226-838b-341b196bb43c">`main` 스레드에서 다음 코드를 실행하게 되면 `main` 스레드는 `thread-1` , `thread-2` 가 종료될 때 까지 기다린다.     이때 `main` 스레드는 `WAITING` 상태가 된다.```javathread1.join();thread2.join();```**`join()` 을 호출하는 스레드는 대상 스레드가 `TERMINATED` 상태가 될 때 까지 대기한다.**- 이렇듯 특정 스레드가 완료될 때 까지 기다려야 하는 상황이라면 `join()` 을 사용하면 된다.- **`join()` 의 단점은 다른 스레드가 완료될 때 까지 무기한 기다리는 단점**이 있다.## ⚡️ join - 특정 시간 만큼만 대기> `join(ms)` : 호출 스레드는 특정 시간 만큼만 대기한다. 호출 스레드는 지정한 시간이 지나면 다시 `RUNNABLE` 상태가 되면서 다음 코드를 수행한다.```javapackage thread.control;import static util.MyLogger.log;import static util.ThreadUtils.sleep;public class JoinMainV4 {    public static void main(String[] args) throws InterruptedException {        log("Start");        SumTask task1 = new SumTask(1, 50);        Thread thread1 = new Thread(task1, "thread-1");                thread1.start();        //스레드가 종료될 때 까지 대기        log("join(1000) - main 스레드가 thread1 종료까지 1초 대기");        thread1.join(1000);        log("main 스레드 대기 완료");                log("task1.result = " + task1.result);    }    static class SumTask implements Runnable {        int startValue;        int endValue;        int result = 0;        public SumTask(int startValue, int endValue) {            this.startValue = startValue;            this.endValue = endValue;        }        @Override        public void run() {            log("작업 시작");            sleep(2000);            int sum = 0;            for (int i = startValue; i <= endValue; i++) {                sum += i;            }            result = sum;            log("작업 완료 result = " + result);        }    }}```<img width="500" alt="스크린샷 2024-09-04 오후 8 22 21" src="https://github.com/user-attachments/assets/c3613097-505f-4b31-9411-8fce4160727a">- 이때 `main` 스레드의 상태는 `WAITING` 이 아니라 `TIMED_WAITING` 이 된다.**다른 스레드가 끝날 때 까지 무한정 기다려야 한다면 `join()` 을 사용하고,   다른 스레드의 작업을 무한정 기다릴 수 없 다면 `join(ms)` 를 사용하면 된다.**<br/><br/><br/># 💡 interrupt`thread.interrupt();`> **`interrupt` 를 사용하면, `WAITING` , `TIMED_WAITING` 같은 대기 상태의 스레드를 직접 깨워서, 작동하는 `RUNNABLE` 상태로 만들 수 있다.**작업 중단을 지시를 하고, 거의 즉각적으로 인터럽트가 발생한 것을 확인할 수 있다.- 스레드가 인터럽트 상태일 때는, `sleep()` 처럼 `InterruptedException` 이 발생하는 메서드를 호출하거나 또는 이미 호출하고 대기 중이라면 `InterruptedException` 이 발생한다.---`Thread.currentThread().isInterrupted()`- 스레드가 인터럽트 상태인지 확인할 수 있다.- 인터럽트 상태 변경X<details><summary>Thread.currentThread().isInterrupted() 사용 예시 - interrupt 상태 변경 X</summary>```javapackage thread.control.interrupt;import static util.MyLogger.log;import static util.ThreadUtils.sleep;public class ThreadStopMainV3 {    public static void main(String[] args) {        MyTask task = new MyTask();        Thread thread = new Thread(task, "work");        thread.start();        sleep(50);        log("작업 중단 지시 thread.interrupt()");        thread.interrupt();        log("work 스레드 interrupt 상태1 = " + thread.isInterrupted());    }    static class MyTask implements Runnable {        @Override        public void run() {            while (!Thread.currentThread().isInterrupted()) { // interrupt 상태 변경 X                log("작업 중");            }            log("work 스레드 인터럽트 상태2 = " + Thread.currentThread().isInterrupted());            log("work 스레드 state = " + Thread.currentThread().getState());            try {                log("자원 정리 시도");                Thread.sleep(1000);                log("자원 정리 완료");            } catch (InterruptedException e) {                log("자원 정리 실패 - 자원 정리 중 인터럽트 발생");                log("work 스레드 인터럽트 상태3 = " + Thread.currentThread().isInterrupted());            }            log("작업 종료");        }    }}``````16:58:58.181 [     work] 작업 중16:58:58.181 [     work] 작업 중16:58:58.181 [     work] 작업 중16:58:58.180 [     main] 작업 중단 지시 thread.interrupt()16:58:58.181 [     work] 작업 중16:58:58.185 [     main] work 스레드 interrupt 상태1 = true16:58:58.185 [     work] work 스레드 인터럽트 상태2 = true16:58:58.185 [     work] work 스레드 state = RUNNABLE16:58:58.185 [     work] 자원 정리 시도16:58:58.185 [     work] 자원 정리 실패 - 자원 정리 중 인터럽트 발생16:58:58.185 [     work] work 스레드 인터럽트 상태3 = false16:58:58.185 [     work] 작업 종료```**이 코드에는 심각한 문제가 있다. 바로 `work` 스레드의 인터럽트 상태가 `true` 로 계속 유지된다는 점이다.**- `isInterrupted()` 메서드는 인터럽트의 상태를 변경하지 않는다. **단순히 인터럽트의 상태를 확인만 한다.**- 결과적으로 자원 정리를 하는 도중에 인터럽트가 발생해서, 자원 정리에 실패한다.- **자바에서 인터럽트 예외가 한 번 발생하면, 스레드의 인터럽트 상태를 다시 정상( `false` )으로 돌리는 것은 이런 이유 때문이다.**- **스레드의 인터럽트 상태를 정상으로 돌리지 않으면 이후에도 계속 인터럽트가 발생하게 된다.**- **인터럽트의 목적을 달성하면 인터럽트 상태를 다시 정상으로 돌려두어야 한다.**</details>---`Thread.interrupted()`- 스레드가 인터럽트 상태라면 `true` 를 반환하고, 해당 스레드의 인터럽트 상태를 `false` 로 변경한다. - 스레드가 인터럽트 상태가 아니라면 `false` 를 반환하고, 해당 스레드의 인터럽트 상태를 변경하지 않는다.```javapublic class ThreadStopMainV4 {    public static void main(String[] args) {        MyTask task = new MyTask();        Thread thread = new Thread(task, "work");        thread.start();        sleep(50);        log("작업 중단 지시 thread.interrupt()");        thread.interrupt();        log("work 스레드 interrupt 상태1 = " + thread.isInterrupted());    }    static class MyTask implements Runnable {        @Override        public void run() {            while (!Thread.interrupted()) { // interrupt 상태 변경 O                log("작업 중");            }            log("work 스레드 인터럽트 상태2 = " + Thread.currentThread().isInterrupted());            log("work 스레드 state = " + Thread.currentThread().getState());            try {                log("자원 정리 시도");                Thread.sleep(1000);                log("자원 정리 완료");            } catch (InterruptedException e) {                log("자원 정리 실패 - 자원 정리 중 인터럽트 발생");                log("work 스레드 인터럽트 상태3 = " + Thread.currentThread().isInterrupted());            }            log("작업 종료");        }    }}``````...21:01:40.032 [     work] 작업 중21:01:40.032 [     work] 작업 중21:01:40.032 [     main] 작업 중단 지시 thread.interrupt()21:01:40.032 [     work] 작업 중21:01:40.035 [     work] work 스레드 인터럽트 상태2 = false21:01:40.035 [     main] work 스레드 interrupt 상태1 = true21:01:40.035 [     work] work 스레드 state = RUNNABLE21:01:40.035 [     work] 자원 정리 시도21:01:41.040 [     work] 자원 정리 완료21:01:41.041 [     work] 작업 종료```- `work` 스레드는 인터럽트 상태이다. `Thread.interrupted()` 의 결과는 `true` 가 된다.- `Thread.interrupted()` 는 이때 `work` 스레드의 인터럽트 상태를 정상( `false` )으로 변경한다.> **자바는 인터럽트 예외가 한 번 발생하면, 스레드의 인터럽트 상태를 다시 정상( `false` )으로 돌린다.**  > **스레드의 인터럽트 상태를 정상으로 돌리지 않으면 이후에도 계속 인터럽트가 발생하게 된다.**   > **인터럽트의 목적을 달성하면 인터럽트 상태를 다시 정상으로 돌려두어야 한다.**단순히, `Thread.currentThread().isInterrupted()` 를 사용하여, 스레드의 인터럽트 상태만 확인한다면,  스레드의 인터럽트 상태를 정상으로 돌리지 않기 때문에 이후에도 계속 인터럽트가 발생하게 된다.  **따라서, `Thread.interrupted()` 를 사용하여, 스레드의 인터럽트 상태를 직접 체크해서 정상으로 돌려두어야 한다.****물론 꼭 이것만이 정답은 아니다. 예를 들어 너무 긴급한 상황이어서 자원 정리도 하지 않고, 최대한 빨리 스레드를 종료 해야 한다면 해당 스레드를 다시 인터럽트 상태로 변경하는 것도 방법이다.**<br/><br/><br/># 💡 yield어떤 스레드를 얼마나 실행할지는 운영체제가 스케줄링을 통해 결정한다.   그런데 특정 스레드가 크게 바쁘지 않은 상황 이어서 다른 스레드에 CPU 실행 기회를 양보하고 싶을 수 있다.    **이렇게 `양보`하면 스케줄링 큐에 대기 중인 다른 스레드 가 CPU 실행 기회를 더 빨리 얻을 수 있다.****<u>yield()의 작동</u>**- `Thread.yield()` 메서드는 현재 실행 중인 스레드가 자발적으로 CPU를 양보하여 다른 스레드가 실행될 수 있도록 한다.- `yield()` 메서드를 호출한 스레드는 **`RUNNABLE` 상태를 유지하면서 CPU를 양보**한다. 즉, 이 스레드는 다시 스케줄링 큐에 들어가면서 다른 스레드에게 CPU 사용 기회를 넘긴다.> `yield()` 는 운영체제 의 스케줄러에게 단지 `힌트`를 제공할 뿐, **강제적인 실행 순서를 지정하지 않는다. 그리고 반드시 다른 스레드가 실행되는 것도 아니다!!!!!!**  > `yield()` 는 `RUNNABLE` 상태를 유지하기 때문에, **양보할 사람이 없다면 본인 스레드가 계속 실행될 수 있다!!!**```javapackage thread.control.printer;import static util.MyLogger.log;import java.util.Queue;import java.util.Scanner;import java.util.concurrent.ConcurrentLinkedQueue;public class MyPrinterV4 {    public static void main(String[] args) {        Printer printer = new Printer();        Thread thread = new Thread(printer, "printer");        thread.start();        Scanner userInput = new Scanner(System.in);        while (true) {            log("프린터할 문서를 입력하세요. 종료 (q): ");            String job = userInput.nextLine();            if (job.equals("q")) {                thread.interrupt();                break;            }            printer.addJob(job);        }    }    static class Printer implements Runnable {        Queue<String> jobQueue = new ConcurrentLinkedQueue<>(); // 여러 스레드가 동시에 접근하는 queue 는 ConcurrentLinkedQueue 를 사용해야 한다.        @Override        public void run() {            while (!Thread.interrupted()) {                if (jobQueue.isEmpty()) {                    Thread.yield(); // 추가                    continue;                }                try {                    String job = jobQueue.poll();                    log("출력 시작: " + job + ", 대기 문서: " + jobQueue);                    Thread.sleep(3000); //출력에 걸리는 시간                    log("출력 완료: " + job);                } catch (InterruptedException e) {                    log("인터럽트!");                    break;                }            }            log("프린터 종료");        }        public void addJob(String job) {            jobQueue.add(job);        }    }}``````javawhile (!Thread.interrupted()) {     if (jobQueue.isEmpty()) {        continue;      }    ... }```- 이 코드를 보면 인터럽트가 발생하기 전까지 계속 인터럽트의 상태를 체크하고 또 `jobQueue` 의 상태를 확인한다. 문제는 쉴 틈 없이 CPU에서 이 로직이 계속 반복해서 수행된다는 점이다. - 1초에 while문을 수억 번 반복할 수도 있다! - 결과적으로 CPU 자원을 많이 사용하게 된다.```javawhile (!Thread.interrupted()) {     if (jobQueue.isEmpty()) {        Thread.yield(); // 추가        continue;      }    ... }```- 현재 작동하는 스레드가 아주 많다고 가정해보자.- 인터럽트도 걸리지 않고, `jobQueue` 도 비어있는데, 이런 체크 로직에 CPU 자원을 많이 사용하게 되면, 정작 필요한 스레드들의 효율이 상대적으로 떨어질 수 있다.- 차라리 그 시간에 다른 스레드들을 더 많이 실행해서 `jobQueue` 에 필요한 작업을 빠르게 만들어 넣어주는게 더 효율적일 것이다.그래서 위와 같이 `jobQueue` 에 작업이 비어있으면 `yield()` 를 호출해서, **다른 스레드에 작업을 양보하는게 전체 관점에서 보면 더 효율적이다.**