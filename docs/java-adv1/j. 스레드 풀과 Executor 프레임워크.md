# 스레드 풀과 Executor 프레임워크<br/><br/><br/># 💡스레드를 직접 사용할 때의 문제점1. **스레드 생성 시간**으로 인한 성능 문제 2. **스레드 관리** 문제3. `Runnable` 인터페이스의 불편함<br/>### 🔋 **1. 스레드 생성 비용으로 인한 성능 문제****`스레드가 무거운 이유`는 아래와 같다.**1. **메모리 할당**: 각 스레드는 자신만의 `호출 스택(call stack)`을 가지고 있어야 한다. 스레드를 생성할 때는 이 호출 스택을 위한 메모리를 할당해야 한다.2. **운영체제 자원 사용**: **스레드를 생성하는 작업**은 `운영체제 커널 수준`에서 이루어지며, `시스템 콜(system call)`을 통해 처리된다. 이는 CPU와 메모리 리소스를 소모하는 작업이다.3. **운영체제 스케줄러 설정**: 새로운 스레드가 생성되면 `운영체제의 스케줄러`는 이 스레드를 관리하고 실행 순서를 조정해야 한다. 이는 **운영체제의 스케줄링 알고리즘**에 따라 **추가적인 오버헤드**가 발생할 수 있다.**스레드 하나는 `보통 1MB 이상의 메모리`를 사용한다.**스레드를 생성하는 작업은 상대적으로 무겁다. 단순히 자바 객체를 하나 생성하는 것과는 비교할 수 없을 정도로 큰 작업이다.      > ***스레드의 생성 비용*** 때문에 `생성한 스레드를 재사용하는 방법`을 고려할 수 있다.--- ### 🔋 **2. 스레드 관리 문제**> **서버의 CPU, 메모리 자원은 한정되어 있기 때문에,** ***스레드는 무한하게 만들 수 없다.***- 평소 동시에 100개 정도의 스레드면 충분했는데, 갑자기 10000개의 스레드가 필요한 상황 이 된다면 CPU, 메모리 자원이 버티지 못할 것이다.**시스템이 버틸 수 있는, 최대 스레드의 수 까지만 스레드를 생성할 수 있게 관리해야 한다.**`안전한 종료`를 위해 실행 중인 스레드가 남은 작업은 모두 수행한 다음에 프로그램을 종료하고 싶다거나, 또는 급하게 종료해야 해서 인터럽트 등의 신호를 주고 스레드를 종료하고 싶다고 가정해보자.      ***이런 경우에도 스레드가 어딘가에 `관리`가 되어 있어야한다.***---### 🔋 **3. Runnable 인터페이스의 불편함**```javapublic interface Runnable {    void run();}```- **반환 값이 없다**: `실행 결과`를 얻기 위해서는 `별도의 메커니즘`을 사용해야 한다. 쉽게 이야기해서 **스레드의 실행 결과를 직접 받을 수 없다.**- **예외 처리**: `run()` 메서드는 `체크 예외(checked exception)`를 던질 수 없다. `체크 예외의 처리`는 **메서드 내부 에서 처리해야 한다.**<br/><br/>## ⚡️ 해결> **`스레드 생성 비용으로 인한 성능 문제(1번)`, `스레드 관리 문제(2번)`를 해결하려면 스레드를 생성하고 관리하는 `풀(Pool)`이 필요하다.**<img width="500" alt="스크린샷 2024-09-19 오후 2 20 56" src="https://github.com/user-attachments/assets/bc979690-e846-4641-875b-ae6899104a87">- **작업을 완료한 스레드는 종료하는게 아니라, `다시 스레드 풀에 반납`한다. 스레드1은 이후에 `다시 재사용` 될 수 있다.**사실 스레드 풀이 별것이 아니다. 그냥 컬렉션에 스레드를 보관하고 재사용할 수 있게 하면 된다.             <u>**하지만**</u>- `스레드 풀`에 있는 스레드는 처리할 작업이 없다면, `대기 상태(WAITING)`로 관리, 작업 요청이 오면 `RUNNABLE` 상태로 변경해줘야 한다.- 또한, `생산자 소비자 문제`:  `어떤 생산자`가 `작업(task)`를 만들고, 스레드 풀에 있는 스레드가 `소비자`가 되는 것을 전부 관리**이 모든 것들을 구현하기는 매우 복잡하다.**> 이 모든 것을 해결해주는 것이 `Executor 프레임워크`이다.     > `Executor 프레임워크`는 `스레드 풀`, `스레드 관리`, `Runnable` 의 문제점은 물론이고, `생산자 소비자 문제`까지 한방에 해결해주는 ***자바 멀티스레드 최고의 도구이다.***- 그래서 `실무에서는` **스레드를 직접 하나하나 생성해서 사용하는 일이 드물다.**<br/><br/><br/># 💡 Executor 프레임워크```javapackage java.util.concurrent;public interface Executor {    void execute(Runnable command);}``````javapublic interface ExecutorService extends Executor, AutoCloseable {    <T> Future<T> submit(Callable<T> task);        @Override    default void close() {...}}```- `Executor` 인터페이스를 확장해서 작업 제출과 제어 기능을 추가로 제공한다.- 주요 메서드: `submit()`, `close()`- **`Executor 프레임워크`를 사용할 때는 대부분 이 인터페이스(`ExecutorService`)를 사용한다.**- **`ExecutorService` 인터페이스의 기본 구현체는 `ThreadPoolExecutor` 이다.**- `Spring 프레임워크` 등 여러 가지 라이브러리 들이 멀티스레드 기술을 쓸 때 ***내부에서 `Executor 프레임워크`를 자주 사용한다.***---### 🔋 Executor 프레임워크의 상태를 확인하기 위한 로그 출력 유틸리티```javapublic abstract class ExecutorUtils {    public static void printState(ExecutorService executorService) {        if (executorService instanceof ThreadPoolExecutor poolExecutor) {            int pool = poolExecutor.getPoolSize();            int active = poolExecutor.getActiveCount();            int queuedTasks = poolExecutor.getQueue().size();            long completedTask = poolExecutor.getCompletedTaskCount();            log("[pool=" + pool + ", active=" + active + ", queuedTasks=" + queuedTasks + ", completedTasks=" + completedTask + "]");        } else {            log(executorService);        }    }    public static void printState(ExecutorService executorService, String taskName) {        if (executorService instanceof ThreadPoolExecutor poolExecutor) {            int pool = poolExecutor.getPoolSize();            int active = poolExecutor.getActiveCount();            int queuedTasks = poolExecutor.getQueue().size();            long completedTask = poolExecutor.getCompletedTaskCount();            log(taskName + " -> [pool=" + pool + ", active=" + active + ", queuedTasks=" + queuedTasks + ", completedTasks=" + completedTask + "]");        } else {            log(executorService);        }    }}```- `pool` : 스레드 풀에서 관리되는 스레드의 숫자 - `active` : 작업을 수행하는 스레드의 숫자 - `queuedTasks` : 큐에 대기중인 작업의 숫자 - `completedTask` : 완료된 작업의 숫자---<br/>## ⚡️ ExecutorService 간단한 예시<details><summary>ExecutorService 예시 코드</summary>```javapublic class RunnableTask implements Runnable {    private final String name;    private int sleepMs = 1000;    public RunnableTask(String name) {        this.name = name;    }    public RunnableTask(String name, int sleepMs) {        this.name = name;        this.sleepMs = sleepMs;    }    @Override    public void run() {        log(name + " 시작");        sleep(sleepMs); // 작업 시간 시뮬레이션        log(name + " 완료");    }}``````javapublic class ExecutorBasicMain {    public static void main(String[] args) {        ExecutorService es = new ThreadPoolExecutor(2, 2, 0, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>());        log("== 초기 상태 ==");        printState(es);        es.execute(new RunnableTask("taskA"));        es.execute(new RunnableTask("taskB"));        es.execute(new RunnableTask("taskC"));        es.execute(new RunnableTask("taskD"));        log("== 작업 수행 중 ==");        printState(es);        sleep(3000);        log("== 작업 수행 완료 ==");        printState(es);        es.shutdown(); // es.close()와 비슷한 기능, 차이가 있다.        log("== shutdown 완료 ==");        printState(es);    }}```</details>```> Task :ExecutorBasicMain.main()15:26:33.367 [     main] == 초기 상태 ==15:26:33.377 [     main] [pool=0, active=0, queuedTasks=0, completedTasks=0]15:26:33.377 [     main] == 작업 수행 중 ==15:26:33.378 [     main] [pool=2, active=2, queuedTasks=2, completedTasks=0]15:26:33.378 [pool-1-thread-1] taskA 시작15:26:33.378 [pool-1-thread-2] taskB 시작15:26:34.384 [pool-1-thread-2] taskB 완료15:26:34.384 [pool-1-thread-1] taskA 완료15:26:34.384 [pool-1-thread-2] taskC 시작15:26:34.385 [pool-1-thread-1] taskD 시작15:26:35.386 [pool-1-thread-1] taskD 완료15:26:35.387 [pool-1-thread-2] taskC 완료15:26:36.383 [     main] == 작업 수행 완료 ==15:26:36.384 [     main] [pool=2, active=0, queuedTasks=0, completedTasks=4]15:26:36.385 [     main] == shutdown 완료 ==15:26:36.386 [     main] [pool=0, active=0, queuedTasks=0, completedTasks=4]```<img width="500" alt="스크린샷 2024-09-19 오후 3 30 25" src="https://github.com/user-attachments/assets/85140804-4da3-4989-add2-f9fd8ef76bd5">- `ThreadPoolExecutor` 를 `생성한 시점`에 스레드 풀에 ***스레드를 미리 만들어두지는 않는다.***- 최초의 작업이 들어오면 **이때 작업을 처리하기 위해 스레드를 만든다.**---<img width="500" alt="스크린샷 2024-09-19 오후 3 23 17" src="https://github.com/user-attachments/assets/bc3fa30e-4f7a-4634-8962-8312cf8d1367">`ThreadPoolExecutor(ExecutorService)` 는 크게 2가지 요소- `스레드 풀(Thread Pool)`: 스레드를 관리한다.- `BlockingQueue` : ***작업을 보관***한다. `생산자 소비자 문제`를 해결하기 위해 단순한 큐가 아니라, **`BlockingQueue` 를 사용한다.**- **생산자**: `es.execute(작업)` 를 호출하면 내부에서 `BlockingQueue` 에 작업을 보관한다. `main` 스레드가 생산자가 된다.- **소비자**: 스레드 풀에 있는 스레드가 소비자이다. 이후에 소비자 중에 하나가 `BlockingQueue` 에 들어있는 작업 을 받아서 처리한다.**ThreadPoolExecutor 생성자의 속성**- `corePoolSize` : 스레드 풀에서 관리되는 기본 스레드의 수- `maximumPoolSize` : 스레드 풀에서 관리되는 최대 스레드 수- `keepAliveTime`, `TimeUnit unit` : 기본 스레드 수를 초과해서 만들어진 스레드가 생존할 수 있는 대기 시간이다. 이 시간 동안 처리할 작업이 없다면 초과 스레드는 제거된다. - `BlockingQueue workQueue` : 작업을 보관할 블로킹 큐- `new ThreadPoolExecutor(2,2,0, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>());`---<img width="500" alt="스크린샷 2024-09-19 오후 3 37 05" src="https://github.com/user-attachments/assets/619d08de-c084-4a81-a37b-3cb6a6b81ae8">- 스레드 풀의 스레드가 작업을 실행할 때, **실제로 꺼내는 것은 아니고,** ***`스레드의 상태`가 변경된다고 이해하면 된다.***<br/><br/><br/># 💡 Runnable 의 불편함```javapublic interface Runnable {    void run();}```- **반환 값이 없다**: `run()` 메서드는 반환 값을 가지지 않는다. 스레드가 실행한 결과를 멤버 변수에 넣어두고, `join()` 등을 사용해서 스레드가 종료되길 기다린 다음에 멤버 변수를 통해 값을 받아야 한다.- **예외 처리**: `run()` 메서드는 체크 예외(checked exception)를 던질 수 없다. 체크 예외의 처리는 메서드 내부 에서 처리해야 한다.작업 스레드는 간단히 값을 `return` 을 통해 반환하고, 요청 스레드는 그 반환 값을 바로 받을 수 있다면 코드가 훨씬 더 간결해질 것이다.      > **이런 문제를 해결하기 위해 `Executor 프레임워크`는 `Callable` 과 `Future` 라는 인터페이스를 도입했다.**<br/><br/><br/># 💡 Future## ⚡️ Callable```javapackage java.util.concurrent;public interface Callable<V> {     V call() throws Exception;}```- `Callable` 의 `call()` 은 반환 타입이 제네릭 `V` 이다. **따라서 `값을 반환할 수 있다.`**- `throws Exception` 예외가 선언되어 있다. **따라서 해당 인터페이스를 구현하는 모든 메서드는 체크 예외인 `Exception` 과 `그 하위 예외`를 모두 던질 수 있다.**```javapublic class CallableMainV1 {    public static void main(String[] args) throws ExecutionException, InterruptedException {        ExecutorService es = Executors.newFixedThreadPool(1);        Future<Integer> future = es.submit(new MyCallable());        Integer result = future.get();        log("result value = " + result);        es.shutdown();    }    static class MyCallable implements Callable<Integer> {        @Override        public Integer call() throws Exception {            log("Callable 시작");            sleep(2000);            int value = new Random().nextInt(10);            log("create value = " + value);            log("Callable 완료");            return value;        }    }}````ExecutorService es = new ThreadPoolExecutor(1,1,0, TimeUnit.MILLISECONDS, newLinkedBlockingQueue<>());` `==``ExecutorService es = Executors.newFixedThreadPool(1);`- `java.util.concurrent.Executors` 가 제공하는 `newFixedThreadPool(size)` 을 사용하면 편리하게 `ExecutorService` 를 생성할 수 있다.---Callable 을 사용한 구현은 Runnable 을 사용한 구현과 비슷하지만, ***결과를 필드에 담아두는 것이 아니라, `결과를 반환한다`는 점이다.***- `MyCallable` 인스턴스가 `블로킹 큐`에 전달되고, 스레드 풀의 스레드 중 하나가 이 작업을 실행할 것이다. - 이때 작업의 처리 결과는 직접 반환되는 것이 아니라 **`Future` 라는 특별한 인터페이스를 통해 반환된다.**<u>**Executor 프레임워크의 강점**</u>> 요청 스레드가 **결과를 받아야 하는 상황**이라면, ***`Callable` 을 사용한 방식은 `Runnable` 을 사용하는 방식보다 훨씬 편리하다.***- 단순하게 `ExecutorService` 에 필요한 작업을 요청하고 결과를 받아서 쓰면 된다!- 복잡한 멀티스레드를 매우 편리하게 사용할 수 있는 것이 바로 Executor 프레임워크의 큰 강점이다.<br/><br/>## ⚡️ Future> `Future` 는 **미래의 결과를 받을 수 있는 객체**라는 뜻이다. `Future<Integer> future = es.submit(new MyCallable());`- `MyCallable` 이 즉시 실행되어서 즉시 결과를 반환하는 것은 불가능하다. 왜냐하면 `MyCallable` 은 즉시 실행되는 것이 아니다. 스레드 풀의 스레드가 미래의 어떤 시점에 이 코드를 대신 실행해야 한다.- 언제 실행이 완료되어서 결과를 반환할 지 알 수 없다.- `Future` 객체를 통해 **전달한 작업의 미래 결과**를 받을 수 있다.<details><summary>Future 예시</summary>```javapublic class CallableMainV2 {    public static void main(String[] args) throws ExecutionException, InterruptedException {        ExecutorService es = Executors.newFixedThreadPool(1);        log("submit() 호출");        Future<Integer> future = es.submit(new MyCallable());        log("future 즉시 반환, future = " + future);        log("future.get() [블로킹] 메서드 호출 시작 -> main 스레드 WAITING");        Integer result = future.get();        log("future.get() [블로킹] 메서드 호출 완료 -> , main 스레드 RUNNABLE");        log("result value = " + result);        log("future 완료, future = " + future);        es.shutdown();    }    static class MyCallable implements Callable<Integer> {        @Override        public Integer call() throws Exception {            log("Callable 시작");            sleep(2000);            int value = new Random().nextInt(10);            log("create value = " + value);            log("Callable 완료");            return value;        }    }}``````> Task :CallableMainV2.main()16:54:08.208 [     main] submit() 호출16:54:08.209 [pool-1-thread-1] Callable 시작16:54:08.210 [     main] future 즉시 반환, future = java.util.concurrent.FutureTask@f6f4d33[Not completed, task = thread.executor.future.CallableMainV2$MyCallable@4a574795]16:54:08.210 [     main] future.get() [블로킹] 메서드 호출 시작 -> main 스레드 WAITING16:54:10.222 [pool-1-thread-1] create value = 716:54:10.222 [pool-1-thread-1] Callable 완료16:54:10.223 [     main] future.get() [블로킹] 메서드 호출 완료 -> , main 스레드 RUNNABLE16:54:10.223 [     main] result value = 716:54:10.224 [     main] future 완료, future = java.util.concurrent.FutureTask@f6f4d33[Completed normally]```</details><img width="500" alt="스크린샷 2024-09-19 오후 4 56 06" src="https://github.com/user-attachments/assets/15ad1844-da93-424f-9a62-b87ba784fcf2">`es.submit(taskA)`- `Future` 는 인터페이스이다. 이때 **생성되는 `실제 구현체`**는 `FutureTask` 이다.- **`Future` 는 내부에 `taskA` `작업의 완료 여부`와, `작업의 결과 값`을 가진다.**---<img width="500" alt="스크린샷 2024-09-19 오후 4 56 23" src="https://github.com/user-attachments/assets/139d17ee-bb81-403e-a708-5abc358cea27">- `taskA` 를 감싸고 있는 `Future` 가 대신 `블로킹 큐`에 담긴다.- `future = java.util.concurrent.FutureTask@f6f4d33[Not completed, task = thread.executor.future.CallableMainV2$MyCallable@4a574795]`- **`Future` 의 구현체는 `FutureTask`이다.**- 작업을 전달할 때 생성된 `Future` 는 ***즉시 반환된다는 점***이 핵심이다.  - 생성한 `Future` 를 즉시 반환하기 때문에 **`요청 스레드`는 대기하지 않고, 자유롭게 본인의 다음 코드를 호출할 수 있다.**---<img width="500" alt="스크린샷 2024-09-19 오후 4 56 50" src="https://github.com/user-attachments/assets/e97187fc-8ac6-4c0b-9e67-d5b8e257123b">- `Future` 의 구현체인 `FutureTask` 는 `Runnable` 인터페이스도 함께 구현하고 있다. - 스레드1은 `FutureTask` 의 `run()` 메서드를 수행한다.  - `run()` 메서드가 `taskA` 의 `call()` 메서드를 호출하고 그 결과를 받아서 처리한다.  - `FutureTask.run() -> MyCallable.call()`---<br/><u>**`Future.get()`**</u>- **`Future`가 완료 상태**: `Future` 가 완료 상태면 `Future` 에 결과도 포함되어 있다.   - 이 경우 요청 스레드는 대기하지 않고, 값을 즉시 반환받을 수 있다.- **`Future`가 완료 상태가 아님**: `taskA` 가 아직 수행되지 않았거나 또는 수행 중이라는 뜻이다.   - 이때는 어쩔 수 없이 ***`요청 스레드`가 결과를 받기 위해 대기(`WAITING`)해야 한다.*** 요청 스레드가 마치 락을 얻을 때처럼, 결과를 얻기 위해 대기한다.<u>**블로킹 메서드**</u>     - `Thread.join()`, `future.get()` 과 같은 메서드는 **다른 작업이 완료될 때 까지 작업을 바로 수행하지 않고 기다리는 메서드**다.     - **`호출한 스레드`는 지정된 작업이 완료될 때까지 블록(대기) 되어 다른 작업을 수행할 수 없다.**<br/><br/>## ⚡️ Future 가 필요한 이유**Future 를 잘 활용**- 총 2초의 시간```javaFuture<Integer> future1 = es.submit(task1); // non-blockingFuture<Integer> future2 = es.submit(task2); // non-blockingInteger sum1 = future1.get(); // blocking, 2초 대기 Integer sum2 = future2.get(); // blocking, 즉시 반환```<img width="500" alt="스크린샷 2024-09-19 오후 5 42 33" src="https://github.com/user-attachments/assets/9c3496ca-8c8d-4e77-ba59-e920cab782a1">`Future<Integer> future1 = es.submit(task1);` 를 호출할 때, Future 인터페이스의 구현체인 FutureTask 객체를 생성한다.   그리고, `ExecutorService` 의 `스레드 풀(Thread Pool)`에 있는 스레드 중 하나가 task 내부의 `call()` 을 호출하면서 작업을 시작한다.---**Future를 잘못 활용한 예1**- 총 4초의 시간```javaFuture<Integer> future1 = es.submit(task1); // non-blocking Integer sum1 = future1.get(); // blocking, 2초 대기Future<Integer> future2 = es.submit(task2); // non-blocking Integer sum2 = future2.get(); // blocking, 2초 대기```**Future를 잘못 활용한 예2**- 총 4초의 시간```javaInteger sum1 = es.submit(task1).get(); // get()에서 블로킹 Integer sum2 = es.submit(task2).get(); // get()에서 블로킹```---> ***`Future` 는 요청 스레드를 블로킹(대기) 상태로 만들지 않고, 필요한 요청을 모두 수행할 수 있게 해준다.***      > **필요한 모든 요청을 한 다음에 `Future.get()` 을 통해 블로킹 상태로 대기하며 결과를 받으면 된다.**      > **이런 이유로 `ExecutorService` 는 결과를 직접 반환하지 않고, `Future` 를 반환한다.**<br/><br/>## ⚡️ Future 의 기능```javapackage java.util.concurrent;public interface Future<V> {    boolean cancel(boolean mayInterruptIfRunning);    boolean isCancelled();    boolean isDone();        V get() throws InterruptedException, ExecutionException;    V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;        enum State {        RUNNING, SUCCESS, FAILED, CANCELLED    }        default State state() {} }```**`boolean cancel(boolean mayInterruptIfRunning)`**- **기능**: 아직 완료되지 않은 작업을 취소한다. - **매개변수**: `mayInterruptIfRunning`  - `cancel(true)` : ***`Future` 를 취소 상태로 변경한다. 이때 작업이 실행중이라면 `Thread.interrupt()` 를 호출해서 작업을 중단한다.***  - `cancel(false)` : ***`Future` 를 취소 상태로 변경한다. 단 이미 실행 중인 작업을 중단하지는 않는다.***- **반환값**: 작업이 성공적으로 취소된 경우 `true` , 이미 완료되었거나 취소할 수 없는 경우 `false`- **설명**: 작업이 실행 중이 아니거나 아직 시작되지 않았으면 취소하고, 실행 중인 작업의 경우 `mayInterruptIfRunning` 이 `true` 이면 중단을 시도한다.- **참고**: **취소 상태의 `Future` 에 `Future.get()` 을 호출하면 `CancellationException` 런타임 예외가 발생 한다.****`boolean isCancelled()`**- **기능**: 작업이 취소되었는지 여부를 확인한다.- **반환값**: 작업이 취소된 경우 `true` , 그렇지 않은 경우 `false`- **설명**: 이 메서드는 작업이 `cancel()` 메서드에 의해 취소된 경우에 `true` 를 반환한다.**`boolean isDone()`**- **기능**: 작업이 완료되었는지 여부를 확인한다.- **반환값**: 작업이 완료된 경우 `true` , 그렇지 않은 경우 `false`- **설명**: **작업이 정상적으로 완료되었거나, 취소되었거나, 예외가 발생하여 종료된 경우에 `true` 를 반환한다.****`State state()`**- **기능**: `Future` 의 상태를 반환한다. 자바 19부터 지원한다.  - `RUNNING` : 작업 실행 중   - `SUCCESS` : 성공 완료   - `FAILED` : 실패 완료   - `CANCELLED` : 취소 완료**`V get()`**- **기능**: 작업이 완료될 때까지 대기하고, 완료되면 결과를 반환한다. - **반환값**: 작업의 결과- **예외**  - `InterruptedException` : 대기 중에 현재 스레드가 인터럽트된 경우 발생  - `ExecutionException` : 작업 계산 중에 예외가 발생한 경우 발생- **설명**: **작업이 완료될 때까지 `get()` 을 호출한 현재 스레드를 대기(블록킹)한다. 작업이 완료되면 결과를 반환한다.****`V get(long timeout, TimeUnit unit)`**- **기능**: `get()` 과 같은데, 시간 초과되면 예외를 발생시킨다. - **매개변수**:  - `timeout` : 대기할 최대 시간  - `unit: timeout` 매개변수의 시간 단위 지정- **반환값**: 작업의 결과- **예외**:  - `InterruptedException` : 대기 중에 현재 스레드가 인터럽트된 경우 발생   - `ExecutionException` : 계산 중에 예외가 발생한 경우 발생  - `TimeoutException` : 주어진 시간 내에 작업이 완료되지 않은 경우 발생- **설명**: **지정된 시간 동안 결과를 기다린다. 시간이 초과되면 `TimeoutException` 을 발생시킨다.**> Future.get()` 은 작업의 결과 값을 받을 수도 있고, 예외를 받을 수도 있다. 마치 싱글 스레드 상황에서 일반적인 메 서드를 호출하는 것 같다. Executor 프레임워크가 얼마나 잘 설계되어 있는지 알 수 있는 부분이다.<br/><br/><br/># 💡 ExecutorService - 주요 메서드```javapublic interface ExecutorService extends Executor, AutoCloseable {     // 종료 메서드    void shutdown();    List<Runnable> shutdownNow();    boolean isShutdown();    boolean isTerminated();    boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;        // 단일 실행    <T> Future<T> submit(Callable<T> task);    <T> Future<T> submit(Runnable task, T result);    Future<?> submit(Runnable task);        // 다수 실행    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException;    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException;    <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException;    <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;        @Override    default void close(){...}}```**`invokeAll()`**- `<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException`  - 모든 `Callable` 작업을 제출하고, 모든 작업이 완료될 때까지 기다린다.  - `<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException`   - 지정된 시간 내에 모든 `Callable` 작업을 제출하고 완료될 때까지 기다린다.**`invokeAny()`**- `<T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException`  - 하나의 `Callable` 작업이 완료될 때까지 기다리고, 가장 먼저 완료된 작업의 결과를 반환한다. 완료되지 않은 나머지 작업은 취소한다.- `<T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException`  - 지정된 시간 내에 하나의 `Callable` 작업이 완료될 때까지 기다리고, 가장 먼저 완료된 작업의 결과를 반환한다.   - 완료되지 않은 나머지 작업은 취소한다.**`void execute(Runnable command)`** - `Runnable` 작업을 제출한다. 반환값이 없다.**`<T> Future<T> submit(Callable<T> task)`** - `Callable` 작업을 제출하고 결과를 반환받는다.**`Future<?> submit(Runnable task)`** - `Runnable` 작업을 제출하고 결과를 반환받는다.> `ExecutorService.submit()` 에는 반환 결과가 있는 `Callable` 뿐만 아니라 반환 결과가 없는 `Runnable` 도 사용할 수 있다.      `Future<?> future = executor.submit(new MyRunnable());`> **`Runnable` 은 반환 값이 없기 때문에 `future.get()` 을 호출할 경우 `null` 을 반환한다.     결과가 없다 뿐이지 나머지는 똑같다. 작업이 완료될 때 까지 요청 스레드가 블로킹 되는 부분도 같다.**