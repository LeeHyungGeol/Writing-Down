# 동시성 컬렉션<br/><br/><br/># 💡 동시성 컬렉션이 필요한 이유> **`java.util` 패키지에 소속되어 있는 컬렉션 프레임워크는 `원자적인 연산`을 제공할까?**- 하나의 `ArrayList` 인스턴스에 **여러 스레드가 동시에 접근**해도 괜찮을까?- **`스레드 세이프(Thread Safe)`**: 여러 스레드가 동시에 접근해도 괜찮은 것```javapublic interface SimpleList {    int size();    void add(Object e);    Object get(int index);}``````javapublic class BasicList implements SimpleList{    private static final int DEFAULT_CAPACITY = 5;    private Object[] elementData;    private int size;    public BasicList() {        this.elementData = new Object[DEFAULT_CAPACITY];    }    ...    @Override    public void add(Object e) {        elementData[size] = e;        sleep(100); // 멀티스레드 문제를 쉽게 확인하기 위해 넣어주는 코드        size++;    }        ...}```<u>**add() - 원자적이지 않은 연산**</u>- 내부에 있는 배열에 데이터를 추가, size 도 1 증가 -> `원자적이지 않은 연산`- `size++;` 연산도 `원자적이지 않은 연산`이다.---```javapublic class SimpleListMainV2 {    public static void main(String[] args) throws InterruptedException {        test(new BasicList());//        test(new SyncList());//        test(new SyncProxyList(new BasicList()));    }    private static void test(SimpleList list) throws InterruptedException {        log(list.getClass().getSimpleName());        // A를 리스트에 저장하는 코드        Runnable addA = new Runnable() {            @Override            public void run() {                list.add("A");                log("Thread-1: list.add(A)");            }        };        // B를 리스트에 저장하는 코드        Runnable addB = new Runnable() {            @Override            public void run() {                list.add("B");                log("Thread-2: list.add(B)");            }        };        Thread thread1 = new Thread(addA, "Thread-1");        Thread thread2 = new Thread(addB, "Thread-2");        thread1.start();        thread2.start();        thread1.join();        thread2.join();        log(list);    }}``````> Task :SimpleListMainV2.main()17:13:00.202 [     main] BasicList17:13:00.310 [ Thread-1] Thread-1: list.add(A)17:13:00.310 [ Thread-2] Thread-2: list.add(B)17:13:00.310 [     main] [B, null] size=2, capacity=5```- `size` 는 2인데, 데이터는 B 하나만 입력되어 있다!<u>***컬렉션 프레임워크 대부분은 스레드 세이프 하지 않다.***</u>- **멀티스레드 상황**에서 여러 스레드가 동시에 컬렉션에 접근하는 경우라면 `java.util` 패키지가 제공하는 **`일반적인 컬렉션`들은 사용하면 안된다!**---> **여러 스레드**가 접근해야 한다면 `synchronized` , `Lock` 등을 통해 `안전한 임계 영역`을 적절히 만들면 문제를 해결할 수 있다.```javapublic class SyncList implements SimpleList{    private static final int DEFAULT_CAPACITY = 5;    private Object[] elementData;    private int size;    public SyncList() {        this.elementData = new Object[DEFAULT_CAPACITY];    }    @Override    public synchronized int size() {        return size;    }    @Override    public synchronized void add(Object e) {        elementData[size] = e;        sleep(100); // 멀티스레드 문제를 쉽게 확인하기 위해 넣어주는 코드        size++;    }    @Override    public synchronized Object get(int index) {        return elementData[index];    }    @Override    public synchronized String toString() {        return Arrays.toString(Arrays.copyOf(elementData, size)) + " size=" + size + ", capacity=" + elementData.length;    }}``````> Task :SimpleListMainV2.main()17:19:55.838 [     main] SyncList17:19:55.945 [ Thread-1] Thread-1: list.add(A)17:19:56.045 [ Thread-2] Thread-2: list.add(B)17:19:56.045 [     main] [A, B] size=2, capacity=5```- `synchronized` 를 이용하여 멀티스레드 상황에서 안전하게 사용할 수 있도록 해서 문제를 해결했다.<u>**하지만!**</u>      **모든 컬렉션을 다 복사해서 동기화 용으로 새로 구현해야 한다. 이것은 매우 비효율적이다.**<br/><br/><br/># 💡 프록시 도입> **기존 코드를 그대로 사용**하면서 `synchronized` 기능만 **살짝 추가**하고 싶다면 어떻게 하면 좋을까?<br/>## ⚡️ **프록시(Proxy)**> **`프록시(Proxy)`**: 대리자, 대신 처리해주는 자- 여기서는 `프록시`가 대신 동기화( `synchronized` ) 기능을 처리해주는 것 이다.```javapublic class SyncProxyList implements SimpleList {    private SimpleList target;    public SyncProxyList(SimpleList target) {        this.target = target;    }    @Override    public synchronized int size() {        return target.size();    }    @Override    public synchronized void add(Object e) {        target.add(e);    }    @Override    public synchronized Object get(int index) {        return target.get(index);    }    @Override    public synchronized String toString() {        return target.toString() + " by " + this.getClass().getSimpleName();    }}``````> Task :SimpleListMainV2.main()17:41:47.935 [     main] SyncProxyList17:41:48.041 [ Thread-1] Thread-1: list.add(A)17:41:48.146 [ Thread-2] Thread-2: list.add(B)17:41:48.146 [     main] [A, B] size=2, capacity=5 by SyncProxyList```---## ⚡️ 프록시 구조 분석<u>**정적 의존 관계**</u><img width="500" alt="스크린샷 2024-09-15 오후 5 46 42" src="https://github.com/user-attachments/assets/02a91811-ea54-4a59-81dd-054c4cd67cea">- 그림과 같이 `정적인 클래스의 의존 관계`를 `정적 의존 관계`라 한다.- `test()` 메서드는 `SimpleList` 라는 인터페이스에만 의존한다. -> <u>**이것을 추상화에 의존한다고 표현한다.**</u>- `SimpleList` 인터페이스의 구현체 중에 어떤 것을 사용하든, **클라이언트인 `test()` 의 코드는 전혀 변경하지 않아도 된다.**---<u>**런타임 의존 관계**</u><img width="500" alt="스크린샷 2024-09-15 오후 5 47 08" src="https://github.com/user-attachments/assets/842d888d-fb7e-4d98-831e-56200190fb83"><img width="500" alt="스크린샷 2024-09-15 오후 5 47 34" src="https://github.com/user-attachments/assets/5d3f2173-b1cf-4ed5-901e-dc60100e764b">1. ***프록시인 `SyncProxyList` 는 `synchronized` 를 적용한다.*** 그리고 나서 `target` 에 있는 `add()` 를 호출한 다.2. 원본 대상인 `BasicList(x001)` 의 `add()` 가 호출되고, 호출이 끝나면 결과를 반환한다.3. `SyncProxyList` 에 있는 `add()` 로 흐름이 돌아온다. ***메서드를 반환하면서 `synchronized` 를 해제***한다.---<u>**프록시 정리**</u>- 프록시는 내부에 원본을 가지고 있다. 그래서 프록시가 필요한 일부의 일을 처리하고, 그다음에 원본을 호출하는 구조를 만들 수 있다. 여기서 프록시는 `synchronized` 를 통한 동기화를 적용한다. - 프록시가 동기화를 적용하고 원본을 호출하기 때문에 원본 코드도 이미 동기화가 적용된 상태로 호출된다.> ***여기서 중요한 핵심은 원본 코드인 `BasicList` 를 전혀 손대지 않고, 프록시인 `SyncProxyList` 를 통해 `동기화 기능을 적용`했다는 점이다.***---<u>**프록시 패턴**</u>> **`프록시 패턴(Proxy Pattern)`**: ***어떤 객체에 대한 접근을 제어하기 위해 그 객체의 대리인 또는 인터페이스 역할을 하는 객체를 제공하는 패턴이다.*** - `프록시 객체`는 **실제 객체에 대한 참조를 유지**하면서, **그 객체에 접근하거나 행동을 수행하기 전에 추가적인 처리를 할 수 있도록 한다.****프록시 패턴의 주요 목적**- **접근 제어**: **실제 객체에 대한 접근을 제한하거나 통제**할 수 있다.- **성능 향상**: **실제 객체의 생성을 지연시키거나 캐싱하여 성능을 최적화**할 수 있다.- **부가 기능 제공**: 실제 객체에 **추가적인 기능(로깅, 인증, 동기화 등)**을 **투명**하게 제공할 수 있다.<br/><br/><br/># 💡 Collections.synchronizedXxx - 프록시모든 자료구조에 `synchronized`, `Lock`, `CAS` 등을 사용해서 `동기화`를 해두면 좋겠지만, 정도의 차이가 있지만 성능과 트레이드 오프가 있다.결국 ***동기화를 사용하지 않는 것이 가장 빠르다!!!***> 좋은 대안으로는 `synchronized` 를 대신 적용해 주는 `프록시`를 만드는 방법이 있다.**자바는 컬렉션을 위한 `프록시 기능`을 제공한다.****`Collections.synchronizedList(target)`**```javapublic static <T> List<T> synchronizedList(List<T> list) {     return new SynchronizedRandomAccessList<>(list);}```**`Collections` 는 다음과 같이 다양한 `synchronized` `동기화 메서드`를 지원한다. 다양한 `동기화 프록시`를 만들어낼 수 있다.**- `synchronizedList()`- `synchronizedCollection()` - `synchronizedMap()` - `synchronizedSet()` - `synchronizedNavigableMap()` - `synchronizedNavigableSet()` - `synchronizedSortedMap()` - `synchronizedSortedSet()`<u>**synchronized 프록시 방식의 단점**</u>- 첫째, **동기화 오버헤드가 발생한다.**   - 비록 `synchronized` 키워드가 멀티스레드 환경에서 안전한 접근을 보장하지만,   - **각 메서드 호출 시마다 `동기화 비용이 추가`된다. 이로 인해 성능 저하가 발생할 수 있다.**- 둘째, 전체 컬렉션에 대해 동기화가 이루어지기 때문에, **잠금 범위가 넓어질 수 있다.**   - 이는 잠금 경합(lock contention)을 증가시키고, 병렬 처리의 효율성을 저하시키는 요인이 된다.   - **`모든 메서드`에 대해 동기화를 적용하다 보면, 특정 스레드가 컬렉션을 사용하고 있을 때 `다른 스레드들이 대기해야 하는 상황`이 빈번해질 수 있다.** - 셋째, **정교한 동기화가 불가능하다.**   - `synchronized` 프록시를 사용하면 `컬렉션 전체에 대한 동기화`가 이루어지지만,   - **특정 부분이나 메서드에 대해 선택적으로 동기화를 적용하는 것은 어렵다.**   - 이는 과도한 동기화로 이어질 수 있다.> ***`JAVA`는 이런 단점을 보완하기 위해 `java.util.concurrent` 패키지에 동시성 컬렉션(concurrent collection)을 제공한다.***<br/><br/><br/># 💡 동시성 컬렉션> **`java.util.concurrent` 패키지에는 `고성능 멀티스레드 환경`을 지원하는 `다양한 동시성 컬렉션 클래스들`을 제공한다.**     > 여기에 다양한 성능 최적화 기법들이 적용되어 있는데, `synchronized` , `Lock`( `ReentrantLock` ), `CAS` , `분할 잠금 기술(segment lock)`등 다양한 방법을 섞어서 매우 정교한 동기화를 구현하면서 동시에 성능도 최적화했다.<details><summary>분할 잠금 기술(segment lock)</summary>분할 잠금 기술(segment lock)은 락을 하나가 아니라 여러개의 락을 쓰는 것이다.예를 들어서, hashMap 의 bucket 에서 bucket 별로 따로 락을 거는 것이다.그러면 동시에 여러 스레드가 접근한다 할지라도 서로 다른 bucket 을 사용할 때는 서로 충돌할 일이 없다. 락을 나눠 버린 것이다.서로 다른 bucket 을 사용할 때는 스레드가 병렬로 실행된다. 그래서 다 같이 실행되다가, 같은 bucket 을 쓰는 상황에서만 락을 사용하기 때문에, 락을 최대한 분산해서 사용하는 것이고 그래서 대기하는 스레드를 최대한 줄이는 것이다.</details>## ⚡️ 동시성 컬렉션 종류- `List`  - `CopyOnWriteArrayList` -> `ArrayList` 의 대안- `Set`  - `CopyOnWriteArraySet` -> `HashSet` 의 대안  - `ConcurrentSkipListSet` -> `TreeSet` 의 대안(정렬된 순서 유지, `Comparator` 사용 가능)- `Map`  - `ConcurrentHashMap` : `HashMap` 의 대안  - `ConcurrentSkipListMap` : `TreeMap` 의 대안(정렬된 순서 유지, `Comparator` 사용 가능) - `Queue`  - `ConcurrentLinkedQueue` : 동시성 큐, 비 차단(non-blocking) 큐이다.- `Deque`   - `ConcurrentLinkedDeque` : 동시성 데크, 비 차단(non-blocking) 큐이다.참고로 `LinkedHashSet` , `LinkedHashMap` 처럼 입력 순서를 유지하는 동시에 멀티스레드 환경에서 사용할 수 있는 `Set` , `Map` 구현체는 제공하지 않는다.     필요하다면 `Collections.synchronizedXxx()` 를 사용해야 한다.### 🔋 스레드를 차단하는 블로킹 큐- `BlockingQueue`  - `ArrayBlockingQueue`    - 크기가 고정된 블로킹 큐     - 공정(fair) 모드를 사용할 수 있다. 공정(fair) 모드를 사용하면 성능이 저하될 수 있다.   - `LinkedBlockingQueue`    - 크기가 무한하거나 고정된 블로킹 큐  - `PriorityBlockingQueue`    - 우선순위가 높은 요소를 먼저 처리하는 블로킹 큐  - `SynchronousQueue`    - 데이터를 저장하지 않는 블로킹 큐로, 생산자가 데이터를 추가하면 소비자가 그 데이터를 받을 때까지 대기한다.     - 생산자-소비자 간의 직접적인 핸드오프(hand-off) 메커니즘을 제공한다.     - 쉽게 이야기해서 중간에 큐 없이 생산자, 소비자가 직접 거래한다.  - `DelayQueue`    - 지연된 요소를 처리하는 블로킹 큐로, 각 요소는 지정된 지연 시간이 지난 후에야 소비될 수 있다.     - 일정 시간이 지난 후 작업을 처리해야 하는 스케줄링 작업에 사용된다.  > 자바가 제공하는 동시성 컬렉션은 멀티스레드 상황에 최적의 성능을 낼 수 있도록 다양한 최적화 기법이 적용되어 있다. 따라서 `Collections.synchronizedXxx` 를 사용하는 것 보다 더 좋은 성능을 제공한다.      > 당연한 이야기지만 동시성은 결국 성능과 트레이드 오프가 있다. 따라서 단일 스레드가 컬렉션을 사용하는 경우에는 동시성 컬렉션이 아닌 일반 컬렉션을 사용해야 한다.     > 세상에서 가장 해결하기 어려운 버그가 멀티스레드로 인해 발생한 버그이다. 적절히 횔용하여 버그를 예방하고 성능을 최적화 하는 것이 중요하다.