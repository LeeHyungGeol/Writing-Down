package thread.bounded;import static util.MyLogger.log;import static util.ThreadUtils.sleep;import java.util.ArrayDeque;import java.util.Queue;public class BoundedQueueV2 implements BoundedQueue {    private final Queue<String> queue = new ArrayDeque<>();    private final int max;    public BoundedQueueV2(int max) {        this.max = max;    }    @Override    public synchronized void put(String data) {        while (queue.size() == max) {            log("[put] 큐가 가득 참, 생산자 대기");//            sleep(1000);            Thread.yield();        }        queue.offer(data);    }    @Override    public synchronized String take() {        while (queue.isEmpty()) {            log("[take] 큐에 데이터가 없음, 소비자 대기");//            sleep(1000);            Thread.yield();        }        return queue.poll();    }    // 원칙적으로는 여기에도 synchronized 를 붙여줘야 한다.    // A 스레드가 큐에 접근 중일 때, B 스레드가 toString() 을 호출한다면 기대하지 않는 값을 얻을 수 있기 때문에 원칙적으로는 synchronized 를 붙여줘야 한다.    @Override    public String toString() {        return queue.toString();    }}